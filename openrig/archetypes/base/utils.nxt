{
    "version": "1.17", 
    "alias": "utils", 
    "color": "#aa007f", 
    "mute": false, 
    "solo": false, 
    "meta_data": {
        "positions": {
            "/check_scene": [
                -3747.0910472190335, 
                -1227.9833078320517
            ], 
            "/cluster_control": [
                -1960.0, 
                -1116.7283777522657
            ], 
            "/cluster_control/create": [
                0.0, 
                0.0
            ], 
            "/cluster_to_skincluster": [
                -2700.0, 
                -520.0
            ], 
            "/control": [
                -2700.0, 
                -760.0
            ], 
            "/deformers_one_to_one": [
                -4002.9889203295616, 
                89.07568080238673
            ], 
            "/export_blendShape": [
                -3280.519660268955, 
                -1535.0186968358055
            ], 
            "/export_cluster": [
                -3267.3282270803547, 
                -1869.1882802141834
            ], 
            "/export_control_curve_data": [
                -3280.0, 
                -880.0
            ], 
            "/export_control_orients": [
                -3280.0, 
                -1140.0
            ], 
            "/export_curve_data": [
                -3280.0, 
                -1040.0
            ], 
            "/export_data": [
                -3740.0, 
                -960.0
            ], 
            "/export_deformer": [
                -3807.4233078550164, 
                -1629.1216051180836
            ], 
            "/export_deformer_order_data": [
                -3280.0, 
                -800.0
            ], 
            "/export_joint_position_data": [
                -3280.0, 
                -720.0
            ], 
            "/export_psd": [
                -3268.4583838141507, 
                -1388.6108197128112
            ], 
            "/export_sdk_data": [
                -3280.0, 
                -1220.0
            ], 
            "/export_sets_data": [
                -3280.0, 
                -960.0
            ], 
            "/export_skincluster": [
                -3760.987429523665, 
                -1407.7660052419712
            ], 
            "/export_wire": [
                -3287.361980141383, 
                -1688.706700778269
            ], 
            "/flip_deformer_map": [
                -2700.0, 
                -640.0
            ], 
            "/import_blendshapes": [
                -2740.0, 
                -1080.0
            ], 
            "/import_psd": [
                -2734.26585400694, 
                -1183.019470435003
            ], 
            "/import_sets": [
                -3280.0, 
                -420.0
            ], 
            "/import_weight_directory": [
                -1980.0, 
                -480.0
            ], 
            "/lash_transfer": [
                -3043.845095933396, 
                89.96711893350017
            ], 
            "/load_curve_data": [
                -3280.0, 
                -320.0
            ], 
            "/load_data": [
                -3740.0, 
                -420.0
            ], 
            "/load_deformer_order_data": [
                -3280.0, 
                -220.0
            ], 
            "/load_joint_data": [
                -3280.0, 
                -120.0
            ], 
            "/load_maya_file": [
                -1980.0, 
                -200.0
            ], 
            "/load_node_data": [
                -3280.0, 
                -520.0
            ], 
            "/load_sdk_data": [
                -3280.0, 
                -600.0
            ], 
            "/mirror_cluster": [
                -1960.0, 
                -1680.0
            ], 
            "/mirror_control_curves": [
                -2360.0, 
                -1760.0
            ], 
            "/mirror_curves": [
                -1960.0, 
                -1760.0
            ], 
            "/mirror_deformer": [
                -2360.0, 
                -1640.0
            ], 
            "/mirror_joints": [
                -2740.0, 
                -1500.0
            ], 
            "/mirror_sdk": [
                -2740.0, 
                -1620.0
            ], 
            "/mirror_skincluster": [
                -2360.0, 
                -1500.0
            ], 
            "/mirror_transforms": [
                -2700.0, 
                -300.0
            ], 
            "/mirror_wire": [
                -1960.0, 
                -1560.0
            ], 
            "/project_data": [
                -3706.367289100843, 
                89.09848202724703
            ], 
            "/save_maya_file": [
                -2677.6979302650007, 
                90.63774425461799
            ], 
            "/select_sdks": [
                -1960.0, 
                -1320.0
            ], 
            "/space_switch": [
                -1973.2459786194056, 
                -592.9149283927943
            ], 
            "/transfer_data": [
                -3360.8128891010633, 
                89.71184653282357
            ], 
            "/wire_to_skincluster": [
                -2700.0, 
                -420.0
            ], 
            "/yank_cluster": [
                -1960.0, 
                -1220.0
            ], 
            "/yank_skincluster": [
                -1960.0, 
                -1460.0
            ]
        }, 
        "collapse": {
            "/center": false, 
            "/center/spine": false, 
            "/center/spine/controls": false, 
            "/cluster_control": true, 
            "/control": true, 
            "/deformers_one_to_one": true, 
            "/export_cluster": false, 
            "/export_control_curve_data": true, 
            "/export_control_orients": true, 
            "/export_curve_data": true, 
            "/export_data": true, 
            "/export_deformer": true, 
            "/export_deformer/export_data": true, 
            "/export_deformer_order_data": true, 
            "/export_joint_position_data": true, 
            "/export_psd": false, 
            "/export_sdk_data": true, 
            "/export_sets_data": true, 
            "/export_skincluster": true, 
            "/export_skincluster/check_scene": true, 
            "/export_wire": false, 
            "/left": false, 
            "/transfer_data": true, 
            "/wire_to_skincluster": false
        }
    }, 
    "nodes": {
        "/": {
            "child_order": [
                "check_scene", 
                "cluster_control", 
                "cluster_to_skincluster", 
                "control", 
                "export_blendShape", 
                "export_cluster", 
                "export_control_curve_data", 
                "export_control_orients", 
                "export_curve_data", 
                "export_data", 
                "export_deformer", 
                "export_deformer_order_data", 
                "export_joint_position_data", 
                "export_psd", 
                "export_sdk_data", 
                "export_sets_data", 
                "export_skincluster", 
                "export_wire", 
                "flip_deformer_map", 
                "import_blendshapes", 
                "import_psd", 
                "import_sets", 
                "import_weight_directory", 
                "load_curve_data", 
                "load_data", 
                "load_deformer_order_data", 
                "load_joint_data", 
                "load_maya_file", 
                "load_node_data", 
                "load_sdk_data", 
                "mirror_cluster", 
                "mirror_control_curves", 
                "mirror_curves", 
                "mirror_deformer", 
                "mirror_joints", 
                "mirror_sdk", 
                "mirror_skincluster", 
                "mirror_transforms", 
                "mirror_wire", 
                "save_maya_file", 
                "select_sdks", 
                "space_switch", 
                "wire_to_skincluster", 
                "yank_cluster", 
                "yank_skincluster"
            ], 
            "code": [
                "# maya imports", 
                "import maya.cmds as mc", 
                "import maya.api.OpenMaya as om", 
                "import maya.mel as mm", 
                "import math", 
                "", 
                "# python imports", 
                "import os", 
                "import numpy", 
                "import traceback", 
                "from collections import OrderedDict", 
                "", 
                "# openrig imports", 
                "import openrig.maya.riglib.spline as rig_spline", 
                "import openrig.maya.riglib.bindmesh as bindmesh", 
                "import openrig.maya.psd as rig_psd", 
                "import openrig.maya.riglib.ikfk as rig_ikfk", 
                "import openrig.maya.riglib.control as rig_control", 
                "import openrig.maya.riglib.wire as rig_wire", 
                "import openrig.maya.riglib.bindmesh as rig_bindmesh", 
                "import openrig.maya.wrap as rig_wrap", 
                "import openrig.maya.joint as rig_joint", 
                "import openrig.maya.cluster as rig_cluster", 
                "import openrig.maya.skinCluster as rig_skinCluster", 
                "import openrig.maya.weights as rig_weights", 
                "import openrig.maya.deformer as rig_deformer", 
                "import openrig.maya.attr as rig_attribute", 
                "import openrig.maya.curve as rig_curve", 
                "import openrig.maya.transform as rig_transform", 
                "import openrig.maya.blendShape as rig_blendShape", 
                "import openrig.maya.shape as rig_shape", 
                "import openrig.maya.weightObject as weight_object", 
                "import openrig.shared.common as rig_common", 
                "", 
                "# data modules", 
                "import openrig.maya.data.node_data as node_data", 
                "import openrig.maya.data.joint_data as joint_data", 
                "import openrig.maya.data.sdk_data as sdk_data", 
                "import openrig.maya.data.curve_data as curve_data", 
                "import openrig.maya.data.sets_data as sets_data", 
                "import openrig.maya.data.deformer_order_data as deformer_order_data", 
                "import openrig.maya.data.psd_data as psd_data"
            ]
        }, 
        "/check_scene": {
            "attrs": {
                "data_type": {
                    "type": "raw", 
                    "value": "my_data_type"
                }, 
                "filepath": {
                    "type": "raw", 
                    "value": "my_file_path"
                }
            }, 
            "code": [
                "'''", 
                "Warn the user if the element in the scene is different from the active graph element that", 
                "data is going to be written to.", 
                "'''", 
                "", 
                "scene_element = None", 
                "active_element = '${element}'", 
                "data_type = '${data_type}'", 
                "filepath = '${filepath}'", 
                "", 
                "# Find scene element", 
                "model_nodes = mc.ls('model')", 
                "if model_nodes:", 
                "    model = mc.ls(model_nodes[-1], long=1)[0]", 
                "    scene_element = model.split('|')[1]", 
                "    ", 
                "message = 'Exporting: [ {} ] to [ {} ]'.format(data_type, active_element)", 
                "", 
                "", 
                "if scene_element:", 
                "    if scene_element != active_element:", 
                "        message = 'WARNING: Exporting [ {} ] from [ {} ] to [ {} ]'.format(data_type, scene_element, active_element)", 
                "", 
                "if filepath:", 
                "    message += '\\n\\n{}'.format(filepath)", 
                "      ", 
                "response = mc.confirmDialog( title='Confirm',", 
                "                    message=message,", 
                "                    button=['Yes','No'], ", 
                "                    defaultButton='Yes', ", 
                "                    cancelButton='No', ", 
                "                    dismissString='No' )", 
                "if response == 'No':", 
                "    mc.error('Data Export - Aborting')", 
                ""
            ]
        }, 
        "/cluster_control": {
            "instance": "", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "True"
                }, 
                "align_to_node": {
                    "comment": "What we will align the top node in the hierarchy of the control  to.", 
                    "type": "raw", 
                    "value": "${parent}"
                }, 
                "align_translation": {
                    "type": "bool", 
                    "value": "True"
                }, 
                "color": {
                    "comment": "Color of the control. 0-31", 
                    "type": "int", 
                    "value": "0"
                }, 
                "control_name": {
                    "comment": "The name of the control being created.", 
                    "type": "str", 
                    "value": "'control_one'"
                }, 
                "control_type": {
                    "comment": "The shape to be used for the control", 
                    "type": "str", 
                    "value": "'sphere'"
                }, 
                "display_handle": {
                    "comment": "Whether or not to display the handle", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "geometry": {
                    "comment": "Name of geometry to put the cluster on.", 
                    "type": "str", 
                    "value": "'body_geo'"
                }, 
                "hide_attrs": {
                    "comment": "Array of attributes to hide on the control being created.", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "hierarchy": {
                    "comment": "Hierarchy suffix list. This will create the hierarchy above the control useing the control name plus suffix name", 
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "parent": {
                    "comment": "The name of the parent for the control hierarchy of the control being created.", 
                    "type": "str", 
                    "value": "''"
                }, 
                "tag_as_control": {
                    "comment": "Whether or not to untag this as a control", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "transform_type": {
                    "comment": "The type of transform you want to use for the control. (i.e. joint, transform)", 
                    "type": "str", 
                    "value": "'transform'"
                }, 
                "type": {
                    "comment": "Type of control. This is good for seperating the difference between different parts of the rig. ", 
                    "type": "str", 
                    "value": "'body'"
                }
            }
        }, 
        "/cluster_control/create": {
            "code": [
                "# create the lip lower cluster", 
                "rig_cluster.create(${geometry}, name=${control_name}, parent=${parent})", 
                "", 
                "# rename the cluster and control                                    ", 
                "mc.rename(${control_name}, '{}_cluster'.format(${control_name}))", 
                "mc.rename('{}_ctrl'.format(${control_name}), ${control_name})", 
                "#mc.xform(\"{}_nul\".format(${control_name}), ws=True, matrix=mc.xform(${align_to_node}, q=True, ws=True, matrix=True))", 
                "# lock attributes if it's in the hide_attrs attribute", 
                "if ${hide_attrs}:", 
                "    rig_attribute.lockAndHide(${control_name}, ${hide_attrs})", 
                "                            ", 
                "# This will align to the node passed to the align_to_node attribute.", 
                "if ${align_to_node}:", 
                "    if ${align_translation} and ${align_rotation}:", 
                "        rig_transform.align('{}_nul'.format(${control_name}), ${align_to_node})", 
                "    elif ${align_translation}:", 
                "        rig_transform.alignTranslate('{}_nul'.format(${control_name}), ${align_to_node})", 
                "    elif ${align_rotation}:", 
                "        rig_transform.alignRotate('{}_nul'.format(${control_name}), ${align_to_node})", 
                "        ", 
                "if ${tag_as_control}:", 
                "    mc.setAttr(\"{}.displayHandle\".format(${control_name}), int(${display_handle}))", 
                "    rig_control.tagAsControl(${control_name}, type=${type})", 
                "rig_attribute.lockAndHide([${control_name}], ${hide_attrs})"
            ]
        }, 
        "/cluster_to_skincluster": {
            "instance": "", 
            "enabled": true, 
            "comment": "This node will be used to convert clusters to skinClusters\n", 
            "attrs": {
                "cluster_list": {
                    "comment": "List of cluster you want to convert", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "deformer_name": {
                    "comment": "Deformer ", 
                    "type": "str", 
                    "value": "''"
                }, 
                "keep_clusters": {
                    "comment": "Whether or not to keep the clusters around", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "comment": "The root parent", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "root_pre_matrix": {
                    "comment": "Node the will be used for the preMatrix", 
                    "type": "str", 
                    "value": "'trs_aux'"
                }, 
                "target_geometry": {
                    "comment": "Geometry you want to put the defomer on", 
                    "type": "raw", 
                    "value": "mc.listRelatives(mc.ls(mc.ls('model', dag=1, s=1, ni=1), type='mesh'), p=1)"
                }
            }, 
            "code": [
                "import traceback", 
                "", 
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    rig_cluster.convertClustersToSkinCluster(${deformer_name}, ${target_geometry}, ${cluster_list}, ${keep_clusters}, ${root_parent}, ${root_pre_matrix})", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                "", 
                ""
            ]
        }, 
        "/control": {
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "comment": "This node is a utility to ensure when you want to creat a control you get the updated results and they're all create the same.", 
            "attrs": {
                "align_rotation": {
                    "comment": "Whether or not to align the rotation of the control to the align_to_node", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "align_to_node": {
                    "comment": "What we will align the top node in the hierarchy of the control  to.", 
                    "type": "str", 
                    "value": "''"
                }, 
                "align_translation": {
                    "comment": "Whether or not to align the translation of the control to the align_to_node", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "color": {
                    "comment": "Color of the control. 0-31", 
                    "type": "int", 
                    "value": "0"
                }, 
                "control_name": {
                    "comment": "The name of the control being created.", 
                    "type": "str", 
                    "value": "'control_one'"
                }, 
                "control_type": {
                    "comment": "The shape to be used for the control", 
                    "type": "str", 
                    "value": "'sphere'"
                }, 
                "hide_attrs": {
                    "comment": "Array of attributes to hide on the control being created.", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "hierarchy": {
                    "comment": "Hierarchy suffix list. This will create the hierarchy above the control useing the control name plus suffix name", 
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "parent": {
                    "comment": "The name of the parent for the control hierarchy of the control being created.", 
                    "type": "str", 
                    "value": "''"
                }, 
                "rotationOrder": {
                    "comment": "The rotation order that will be used for this control. This can be overidden by data files being imported. ", 
                    "type": "str", 
                    "value": "'xyz'"
                }, 
                "transform_type": {
                    "comment": "The type of transform you want to use for the control. (i.e. joint, transform)", 
                    "type": "str", 
                    "value": "'transform'"
                }, 
                "type": {
                    "comment": "Type of control. This is good for seperating the difference between different parts of the rig. ", 
                    "type": "str", 
                    "value": "'body'"
                }
            }
        }, 
        "/control/create": {
            "comment": "This will actually run the code to create the control", 
            "code": [
                "# create the gimbal control for the end control", 
                "control_hierarchy = rig_control.create(name=${control_name},", 
                "                            controlType=${control_type},", 
                "                            hierarchy=${hierarchy},", 
                "                            transformType=${transform_type},", 
                "                            hideAttrs=${hide_attrs},", 
                "                            parent=${parent},", 
                "                            color=${color},", 
                "                            type=${type},", 
                "                            rotateOrder=${rotationOrder})", 
                "                            ", 
                "# lock attributes if it's in the hide_attrs attribute", 
                "if ${hide_attrs}:", 
                "    rig_attribute.lockAndHide(${control_name}, ${hide_attrs})", 
                "                            ", 
                "# This will align to the node passed to the align_to_node attribute.", 
                "if ${align_to_node}:", 
                "    if ${align_translation} and ${align_rotation}:", 
                "        rig_transform.align(control_hierarchy[0], ${align_to_node})", 
                "    elif ${align_translation}:", 
                "        rig_transform.alignTranslate(control_hierarchy[0], ${align_to_node})", 
                "    elif ${align_rotation}:", 
                "        rig_transform.alignRotate(control_hierarchy[0], ${align_to_node})"
            ]
        }, 
        "/export_blendShape": {
            "instance": "/export_deformer", 
            "child_order": [
                "export_data"
            ], 
            "attrs": {
                "deformer_type": {
                    "type": "raw", 
                    "value": "blendShape"
                }
            }
        }, 
        "/export_blendShape/export_data": {
            "code": [
                "import gzip", 
                "import shutil", 
                "from threading import Thread", 
                "from functools import partial", 
                "    ", 
                "def zip_data_file(filepath):", 
                "    import shutil", 
                "    import gzip", 
                "    with open(filepath, 'rb') as f_in:", 
                "        with gzip.open(filepath+'.gz', 'wb') as f_out:", 
                "            shutil.copyfileobj(f_in, f_out)", 
                "", 
                "deformer_nodes = list()", 
                "if mc.objExists(${model_group}):", 
                "    for mesh in ${mesh_list}:", 
                "        # Get nodes", 
                "        deformer_nodes = mc.ls(mc.listHistory(mesh, pdo=True, il=True), type=\"${deformer_type}\")", 
                "        if not deformer_nodes:", 
                "            continue", 
                "        if ${exclude_node_list}:", 
                "            deformer_nodes = list(set(deformer_nodes).difference(set(${exclude_node_list})))", 
                "        if ${include_node_list}:", 
                "            deformer_nodes = list(set(deformer_nodes).intersection(set(${include_node_list})))", 
                "        ", 
                "        # Export Weights", 
                "        file_list = rig_weights.exportWeights(mesh, deformer_nodes, r'${dir_path}')", 
                "        print('\\nexported '+str(len(deformer_nodes))+\" ${deformer_type}\"+' deformers')", 
                " ", 
                "        # Zip weight files", 
                "        for filepath in file_list:", 
                "            print('Compressing in background: {}.gz'.format(filepath))", 
                "            zip_func = partial(zip_data_file, filepath)", 
                "            # Compress in a background thread", 
                "            p1 = Thread(target=zip_func)", 
                "            p1.start() ", 
                "            ", 
                "        # Export deltas", 
                "        for deformer in deformer_nodes:", 
                "            target_ids = rig_blendShape.getTargetIds(deformer)", 
                "            if not target_ids:", 
                "                continue", 
                "            # Format ids for export command", 
                "            target_ids = [(0, x) for x in target_ids]", 
                "            # Export", 
                "            if mc.nodeType(mesh) != 'transform':", 
                "                mesh = mc.listRelatives(mesh, p=1)[0]", 
                "            filepath = '${dir_path}/{}__{}.shp'.format(mesh, deformer)", 
                "            print('exporting deltas', mesh, deformer, filepath)", 
                "            mc.blendShape(deformer, e=1, export=filepath, exportTarget=target_ids)", 
                "            ", 
                ""
            ]
        }, 
        "/export_cluster": {
            "instance": "/export_deformer", 
            "attrs": {
                "deformer_type": {
                    "value": "cluster"
                }
            }
        }, 
        "/export_control_curve_data": {
            "instance": "/export_data", 
            "child_order": [
                "check_scene"
            ], 
            "attrs": {
                "data_class": {
                    "type": "raw", 
                    "value": "CurveData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "curve_data"
                }, 
                "filename": {
                    "type": "raw", 
                    "value": "control_positions.data"
                }, 
                "node_list": {
                    "type": "raw", 
                    "value": "mc.listRelatives(mc.ls(\"*.__control__\", o=1), s=1, ni=1, type=\"nurbsCurve\") or []"
                }
            }
        }, 
        "/export_control_curve_data/check_scene": {
            "attrs": {
                "data_type": {
                    "type": "raw", 
                    "value": "control curve positions"
                }
            }
        }, 
        "/export_control_orients": {
            "instance": "/export_data", 
            "child_order": [
                "check_scene"
            ], 
            "attrs": {
                "filename": {
                    "type": "raw", 
                    "value": "control_orients.data"
                }, 
                "node_list": {
                    "value": "mc.ls(\"*_ort\", type=\"transform\")"
                }
            }
        }, 
        "/export_control_orients/check_scene": {
            "attrs": {
                "data_type": {
                    "value": "control orients"
                }
            }
        }, 
        "/export_curve_data": {
            "instance": "/export_data", 
            "child_order": [
                "check_scene"
            ], 
            "attrs": {
                "data_class": {
                    "type": "raw", 
                    "value": "CurveData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "curve_data"
                }, 
                "filename": {
                    "type": "raw", 
                    "value": "curve_positions.data"
                }, 
                "node_list": {
                    "type": "list", 
                    "value": "[mc.listRelatives(shape, p=True, ni=True)[0] for shape in mc.ls(type=\"nurbsCurve\", ni=True)]"
                }
            }
        }, 
        "/export_curve_data/check_scene": {
            "attrs": {
                "data_type": {
                    "type": "raw", 
                    "value": "curve positions"
                }
            }
        }, 
        "/export_data": {
            "instance": "", 
            "child_order": [
                "check_scene", 
                "get_data", 
                "export_data"
            ], 
            "enabled": true, 
            "comment": "Abstract node for exporting data. Also make sure that your node_list attribute is looking for nodes that exist in the scene.", 
            "attrs": {
                "data_class": {
                    "comment": "The class inside the model you're using for data_type attribute", 
                    "type": "raw", 
                    "value": "NodeData"
                }, 
                "data_dir": {
                    "comment": "data directory to store the file", 
                    "type": "NoneType"
                }, 
                "data_type": {
                    "comment": "The data type you will be storing. These are modules in openrig.maya.newData", 
                    "type": "raw", 
                    "value": "node_data"
                }, 
                "filename": {
                    "comment": "The name of the file you will be storing the data into.", 
                    "type": "raw", 
                    "value": "data.data"
                }, 
                "filepath": {
                    "comment": "File path you wish to export your data to.", 
                    "type": "raw", 
                    "value": "${data_dir}/${filename}"
                }, 
                "node_list": {
                    "comment": "List of nodes you wish to export", 
                    "type": "list", 
                    "value": "[]"
                }
            }, 
            "code": [
                ""
            ]
        }, 
        "/export_data/check_scene": {
            "instance": "/check_scene", 
            "enabled": true
        }, 
        "/export_data/export_data": {
            "enabled": true, 
            "code": [
                "data_object = ${data_type}.${data_class}()", 
                "", 
                "# Populated on the get_data node", 
                "nodes = STAGE.export_nodes", 
                "", 
                "filepath = r\"${filepath}\"", 
                "if os.path.isfile(filepath):", 
                "    data_object.read(filepath)", 
                "else:", 
                "    mc.warning('Export - Filepath [ {} ] does not exist. We will create the file for you.'.format(filepath)) ", 
                "", 
                "if nodes: ", 
                "    data_object.gatherDataIterate(nodes)", 
                "    data_object.write(filepath)", 
                "    print('Export - Writing: {}'.format(filepath))", 
                "else:", 
                "    mc.warning('Export - No nodes found to write')"
            ]
        }, 
        "/export_data/get_data": {
            "enabled": true, 
            "code": [
                "# Get the nodes", 
                "STAGE.export_nodes = ${node_list}", 
                ""
            ]
        }, 
        "/export_deformer": {
            "child_order": [
                "check_scene", 
                "export_data"
            ], 
            "comment": "This is the abstract node for exporting all deformers that are not a skinCluster, PSD/Blendshape", 
            "attrs": {
                "deformer_type": {
                    "comment": "Node type for the deformer you want to export. "
                }, 
                "dir_path": {
                    "comment": "Directory path to where you want to export the deformers"
                }, 
                "exclude_node_list": {
                    "comment": "Nodes you want to exclude", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "include_node_list": {
                    "comment": "Node you want to include that won't be pulled from the mesh_list", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "mesh_list": {
                    "comment": "List of meshes we will be grabbing the deformers from", 
                    "type": "raw", 
                    "value": "mc.ls(mc.listRelatives(${model_group}, ad=True, type=('mesh', 'nurbsCurve')), ni=True)"
                }, 
                "model_group": {
                    "comment": "The model group where the geometry lives", 
                    "type": "str", 
                    "value": "'model'"
                }
            }
        }, 
        "/export_deformer/check_scene": {
            "instance": "/check_scene", 
            "attrs": {
                "data_type": {
                    "type": "raw", 
                    "value": "${deformer_type} deformers"
                }, 
                "filepath": {
                    "value": "${dir_path}"
                }
            }
        }, 
        "/export_deformer/export_data": {
            "code": [
                "deformer_nodes = list()", 
                "if mc.objExists(${model_group}):", 
                "    for mesh in ${mesh_list}:", 
                "        deformer_nodes = mc.ls(mc.listHistory(mesh, pdo=True, il=True), type=\"${deformer_type}\")", 
                "        if ${exclude_node_list}:", 
                "            deformer_nodes = list(set(deformer_nodes).difference(set(${exclude_node_list})))", 
                "        if ${include_node_list}:", 
                "            deformer_nodes = list(set(deformer_nodes).intersection(set(${include_node_list})))", 
                "        rig_weights.exportWeights(mesh, deformer_nodes, r'${dir_path}')", 
                "        print('\\nexported '+str(len(deformer_nodes))+\" ${deformer_type}\"+' deformers')", 
                "    ", 
                "", 
                "    ", 
                ""
            ]
        }, 
        "/export_deformer_order_data": {
            "instance": "/export_data", 
            "child_order": [
                "check_scene"
            ], 
            "attrs": {
                "data_class": {
                    "type": "raw", 
                    "value": "DeformerOrderData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "deformer_order_data"
                }, 
                "filename": {
                    "type": "raw", 
                    "value": "deformer_order.data"
                }, 
                "node_list": {
                    "type": "list", 
                    "value": "[mc.listRelatives(node, p=True)[0] for node in mc.ls(type=\"mesh\")+mc.ls(type=\"nurbsCurve\")]"
                }
            }
        }, 
        "/export_deformer_order_data/check_scene": {
            "attrs": {
                "data_type": {
                    "value": "deformer order"
                }
            }
        }, 
        "/export_joint_position_data": {
            "instance": "/export_data", 
            "child_order": [
                "check_scene"
            ], 
            "enabled": true, 
            "attrs": {
                "data_class": {
                    "type": "raw", 
                    "value": "JointData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "joint_data"
                }, 
                "filename": {
                    "type": "raw", 
                    "value": "joint_positions.data"
                }, 
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls(mc.listRelatives(\"bind\", ad=True),type=\"joint\", ni=True) + mc.ls(\"*_pivot\",type=\"joint\", ni=True)"
                }
            }
        }, 
        "/export_joint_position_data/check_scene": {
            "attrs": {
                "data_type": {
                    "value": "joint positions"
                }
            }
        }, 
        "/export_psd": {
            "child_order": [
                "check_scene", 
                "export_data"
            ], 
            "attrs": {
                "data_type": {
                    "type": "raw", 
                    "value": "PSDData"
                }, 
                "dir_path": {
                    "comment": "Path to the directory you wish to export your psd data", 
                    "type": "NoneType"
                }, 
                "exclude_group_list": {
                    "comment": "List of psd groups you don't want to export", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "group_list": {
                    "type": "raw", 
                    "value": "rig_psd.getAllGroups()"
                }
            }
        }, 
        "/export_psd/check_scene": {
            "instance": "/check_scene", 
            "attrs": {
                "filepath": {
                    "value": "${dir_path}"
                }
            }
        }, 
        "/export_psd/export_data": {
            "code": [
                "import gzip", 
                "import shutil", 
                "from threading import Thread", 
                "from functools import partial", 
                "", 
                "def zip_data_file(filepath):", 
                "    import shutil", 
                "    import gzip", 
                "    with open(filepath, 'rb') as f_in:", 
                "        with gzip.open(filepath+'.gz', 'wb') as f_out:", 
                "            shutil.copyfileobj(f_in, f_out)", 
                "            ", 
                "", 
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    if not mc.pluginInfo('poseInterpolator', q=1, l=1):  ", 
                "        mc.loadPlugin('poseInterpolator')", 
                "", 
                "    dir_path = r'${dir_path}'", 
                "    for group in ${group_list}:", 
                "        node_list = rig_psd.getGroupChildren(group)", 
                "        nodes_mel = rig_common.pyListToMelArray(node_list)", 
                "            ", 
                "        print('poseInterpolatorExport(\"{}/{}.pose\", {}, {})'.format(dir_path, group, nodes_mel, 1))", 
                "        #mm.eval('poseInterpolatorExport(\"{}/{}.pose\", {}, {})'.format(dir_path, group, nodes_mel, 1))", 
                "        ", 
                "        data_obj = psd_data.${data_type}()", 
                "        data_obj.gatherDataIterate(node_list)", 
                "        data_file = r'{}/{}_poseControls.data'.format(dir_path, group)", 
                "        data_obj.write(data_file)", 
                "        print('Writing: ', data_file)", 
                "", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)"
            ]
        }, 
        "/export_sdk_data": {
            "instance": "/export_data", 
            "execute_in": "", 
            "comment": "This node is used to export sdk data from the current scene. Make sure your filepath attribute is set properly. Also make sure that your node_list attribute is looking for nodes that exist in the scene.", 
            "attrs": {
                "data_class": {
                    "type": "raw", 
                    "value": "SdkData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "sdk_data"
                }, 
                "filename": {
                    "type": "raw", 
                    "value": "sdk.data"
                }, 
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls(type=[\"animCurveUU\", \"animCurveUA\", \"animCurveUL\", \"animCurveUT\"])"
                }
            }
        }, 
        "/export_sets_data": {
            "instance": "/export_data", 
            "attrs": {
                "data_class": {
                    "value": "SetsData"
                }, 
                "data_type": {
                    "value": "sets_data"
                }, 
                "filename": {
                    "value": "sets_data.data"
                }, 
                "node_list": {
                    "value": "mc.ls(type='objectSet')"
                }
            }
        }, 
        "/export_skincluster": {
            "child_order": [
                "check_scene", 
                "export_data"
            ], 
            "comment": "This will ensure all skinClusters in the scene are exported\n", 
            "attrs": {
                "dir_path": {
                    "comment": "Directory where you want to store your skinClusters", 
                    "type": "NoneType"
                }, 
                "mesh_list": {
                    "comment": "list of mesh's you want to export skinClusters for", 
                    "type": "raw", 
                    "value": "mc.listRelatives(model_grp, ad=1, type=('mesh', 'nurbsCurve'))"
                }, 
                "model_group": {
                    "comment": "name of the model group where we will search for the mesh list", 
                    "type": "str", 
                    "value": "'model'"
                }, 
                "skincluster_list": {
                    "comment": "List of skinClusters you want to export", 
                    "type": "raw", 
                    "value": "mc.ls(type=\"skinCluster\")"
                }
            }
        }, 
        "/export_skincluster/check_scene": {
            "instance": "/check_scene", 
            "attrs": {
                "data_type": {
                    "type": "raw", 
                    "value": "skinclusters"
                }, 
                "filepath": {
                    "value": "${dir_path}"
                }
            }
        }, 
        "/export_skincluster/export_data": {
            "code": [
                "# remove the localization on the skinClusters if it has been localized", 
                "rig_skinCluster.removeLocalize(${skincluster_list})", 
                "skincluster_directory = r'${dir_path}'", 
                "", 
                "model_grp = ${model_group}", 
                "sc_nodes = list()", 
                "if mc.objExists(model_grp):", 
                "    for mesh in ${mesh_list}:", 
                "        sc = mc.ls(mc.listHistory(mesh, pdo=1, il=1), type='skinCluster')", 
                "        if sc:", 
                "            sc_nodes.append(sc[0])", 
                "for sc in sc_nodes:", 
                "    geo = mc.deformer(sc, g=1, q=1)", 
                "    if geo:", 
                "        geo = mc.listRelatives(geo, p=1)[0]", 
                "        if sc != (geo+'_skinCluster'):", 
                "            sc = mc.rename(sc, geo + '_skinCluster')", 
                "        print('exporting ' + sc)", 
                "        rig_weights.exportWeights(geo, sc, skincluster_directory)", 
                "", 
                "print('\\nexported '+str(len(sc_nodes))+' skinClusters'),", 
                ""
            ]
        }, 
        "/export_wire": {
            "instance": "/export_deformer", 
            "attrs": {
                "deformer_type": {
                    "value": "wire"
                }
            }
        }, 
        "/flip_deformer_map": {
            "comment": "This node will take the selected map you're painting and flip the map for you.", 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    # Get Selection or highlighted", 
                "    #", 
                "    sel = mc.ls(sl=1, dag=1, s=1, ni=1)", 
                "    if not sel:", 
                "        sel = mc.ls(hl=1, dag=1, s=1, ni=1)", 
                "", 
                "    map = None", 
                "    ctx = mc.currentCtx()", 
                "    if ctx == 'artAttrBlendShapeContext':", 
                "        deformer = mc.artAttrCtx(ctx, q=True, attrSelected=True).split('.')[1]", 
                "        map = mc.textScrollList('blendShapeTargetList', q=True, si=True)[0]", 
                "    if ctx == 'artAttrContext':", 
                "        deformer = mc.artAttrCtx(ctx, q=True, attrSelected=True).split('.')[1]", 
                "            ", 
                "        ", 
                "    # Mirror", 
                "    #", 
                "    mirror_info = ''", 
                "    for shape in sel:", 
                "        rig_weights.flipWeights(deformer,map,shape)", 
                "        mirror_info += '\\nFlipped: ' + deformer", 
                "            ", 
                "    if mirror_info:", 
                "        print(mirror_info)", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)"
            ]
        }, 
        "/import_blendshapes": {
            "enabled": true, 
            "attrs": {
                "directory_path": {
                    "type": "NoneType"
                }, 
                "load_deltas": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls(type=\"poseInterpolator\")"
                }, 
                "psd_group": {
                    "type": "str", 
                    "value": "'psd_grp'"
                }, 
                "psd_group_parent": {
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "psd_name_list": {
                    "type": "list", 
                    "value": "[]"
                }
            }, 
            "code": [
                "import os", 
                "import gzip", 
                "import shutil", 
                "", 
                "for name in ${psd_name_list}:    ", 
                "    if not os.path.isdir(r'${directory_path}'):", 
                "        mc.warning('${directory_path} does not exist!!! Skipping loading PSDs')", 
                "        break", 
                "    file_pose = r'${directory_path}/{}.pose'.format(name)", 
                "    file_shape_list = [shape_file for shape_file in os.listdir(r'${directory_path}') if \".shp\" in shape_file and name in shape_file]", 
                "    if os.path.isfile(file_pose):", 
                "        print('Loading PSD File: [ {} ]'.format(file_pose))", 
                "        # DELTAS and WEIGHTS", 
                "        #", 
                "        if ${load_deltas}:", 
                "            # Import shapes", 
                "            mc.select(cl=True)", 
                "            for file_shape in file_shape_list:", 
                "                file_name = file_shape.split(\".\")[1]", 
                "                ", 
                "                mc.blendShape(ip=os.path.join(r'${directory_path}' ,file_shape),  ", 
                "                               name=file_name, ignoreSelected=True, topologyCheck=False, suppressDialog=True)", 
                "            # Weights       ", 
                "            deformer = '{}_psd'.format(name)", 
                "            if mc.objExists(deformer):", 
                "                geos = mc.deformer(deformer, q=True, g=True)", 
                "                for geo in geos:", 
                "                    geo = mc.listRelatives(geo, p=1)[0]", 
                "                    file_name = '{}__{}.xml'.format(geo, deformer)", 
                "                    filepath = os.path.join(r'${directory_path}', file_name)", 
                "                    if os.path.exists(filepath) or os.path.exists(filepath+'.gz'):", 
                "                        # Unzip", 
                "                        #       Compare when the zip file was written, if it is more than a minute newer", 
                "                        #       than the non-zipped, unzip. If no un-zipped file exists it will unzip ", 
                "                        #       because of the large default diff_time.", 
                "                        diff_time = 10000", 
                "                        if os.path.exists(filepath) and os.path.exists(filepath+'.gz'):", 
                "                            diff_time = os.stat(filepath+'.gz').st_mtime - os.stat(filepath).st_mtime", 
                "                            ", 
                "                        if diff_time > 60.0:", 
                "                            if os.path.exists(filepath+'.gz'):", 
                "                                print('unzipping', filepath+'.gz')", 
                "                                with gzip.open(filepath+'.gz', 'rb') as f:", 
                "                                    file_content = f.read()", 
                "                                    # Write uncompressed file", 
                "                                    g = open(filepath, 'w')", 
                "                                    g.write(file_content)", 
                "                                    g.close()", 
                "                        else:", 
                "                            print('No need to unzip weights, file is update date')", 
                "                        # Import", 
                "                        print('Loading Weights filepath: [ {} ]'.format(file_pose))", 
                "                        rig_weights.importWeights(geo, deformer, filepath)", 
                "    else:", 
                "        print('Warning: PSD File does not exist [ {} ]'.format(file_pose))"
            ]
        }, 
        "/import_psd": {
            "enabled": true, 
            "attrs": {
                "directory_path": {
                    "type": "NoneType"
                }, 
                "load_deltas": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls(type=\"poseInterpolator\")"
                }, 
                "psd_group": {
                    "type": "str", 
                    "value": "'psd_grp'"
                }, 
                "psd_group_parent": {
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "psd_name_list": {
                    "type": "list", 
                    "value": "[]"
                }
            }, 
            "code": [
                "import os", 
                "import gzip", 
                "import shutil", 
                "", 
                "for name in ${psd_name_list}:    ", 
                "    if not os.path.isdir(r'${directory_path}'):", 
                "        mc.warning('${directory_path} does not exist!!! Skipping loading PSDs')", 
                "        break", 
                "    #data_file = os.path.join(r'${directory_path}','{}_poseControls.data'.format(name))", 
                "    data_file = r'${directory_path}/{}_poseControls.data'.format(name)", 
                "", 
                "    print('data file', data_file)", 
                "    if os.path.isfile(data_file):", 
                "        # DELTAS and WEIGHTS", 
                "        #", 
                "        if ${load_deltas}:", 
                "            pass", 
                "                  ", 
                "        # INTERPOLATORS", 
                "        #", 
                "        else:          ", 
                "            # Import pose interpolators - Selection must be cleared for this command to work", 
                "            mc.select(cl=True)", 
                "            ", 
                "            data_obj = psd_data.PSDData()", 
                "            data_obj.read(data_file)            ", 
                "            data = data_obj.getData()", 
                "            for node in data.keys():    ", 
                "                driver_name_list = mc.ls([data[node]['drivers'][driver]['driver_name'] for driver in data[node]['drivers']])", 
                "                rig_psd.addInterp(name=node.replace('Shape', ''), driver=driver_name_list)", 
                "            current_group_list = [mc.getAttr('{}.directoryName'.format(parent_attr)) for parent_attr in mc.ls('poseInterpolatorManager.poseInterpolatorDirectory[*]')]", 
                "            if not name in current_group_list:", 
                "                mm.eval('performInterpolatorCreateGroup(`ls %s`)' % ' '.join(data.keys()))", 
                "                mc.setAttr(\"poseInterpolatorManager.poseInterpolatorDirectory[{}].directoryName\".format(len(current_group_list)), name, type=\"string\")", 
                "            # Import pose control data", 
                "            nodes = ${node_list}", 
                "            data_obj.applyData(nodes)", 
                "            ", 
                "    else:", 
                "        print('Warning: PSD File does not exist [ {} ]'.format(data_file))", 
                "", 
                "# Move nodes into a group", 
                "if ${node_list}:", 
                "    if not mc.objExists(${psd_group}):", 
                "        mc.group(empty=True, n=${psd_group})", 
                "    if mc.objExists(${psd_group_parent}):", 
                "        mc.parent(${psd_group}, ${psd_group_parent})", 
                "    if mc.ls(${node_list}):", 
                "        nodes = mc.listRelatives(${node_list}, p=True)", 
                "        mc.parent(${node_list}, ${psd_group})", 
                "    if mc.objExists('numericPSD_geo'):", 
                "        mc.parent('numericPSD_geo', ${psd_group})", 
                ""
            ]
        }, 
        "/import_sets": {
            "instance": "/load_data", 
            "attrs": {
                "data_class": {
                    "value": "SetsData"
                }, 
                "data_type": {
                    "value": "sets_data"
                }
            }
        }, 
        "/import_weight_directory": {
            "enabled": true, 
            "attrs": {
                "directory_path": {
                    "type": "str", 
                    "value": "''"
                }, 
                "exclude_filter": {
                    "type": "str", 
                    "value": "''"
                }, 
                "include_filter": {
                    "type": "str", 
                    "value": "''"
                }
            }, 
            "code": [
                "rig_weights.applyWtsDir(${directory_path}, includeFilter=${include_filter}, excludeFilter=${exclude_filter})"
            ]
        }, 
        "/load_curve_data": {
            "instance": "/load_data", 
            "enabled": true, 
            "attrs": {
                "apply": {
                    "comment": "Whether or not to apply the data or just load it into memory.", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "attributes": {
                    "comment": "Which attributes to use when loading the data. ", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "data_class": {
                    "type": "raw", 
                    "value": "CurveData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "curve_data"
                }, 
                "nodes": {
                    "comment": "Joint array that we want to load the joint data onto", 
                    "type": "raw", 
                    "value": "mc.ls(type=\"nurbsCurve\")"
                }
            }
        }, 
        "/load_data": {
            "attrs": {
                "apply": {
                    "type": "bool", 
                    "value": "True"
                }, 
                "attributes": {
                    "type": "list", 
                    "value": "[]"
                }, 
                "data_class": {
                    "type": "raw", 
                    "value": "NodeData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "node_data"
                }, 
                "filepath": {
                    "type": "str", 
                    "value": "''"
                }, 
                "kwargs": {
                    "type": "dict", 
                    "value": "{}"
                }, 
                "nodes": {
                    "type": "list", 
                    "value": "[]"
                }
            }, 
            "code": [
                "# first create the data object the user is passing in.", 
                "data_object = ${data_type}.${data_class}()", 
                "# create a list from the filepath in case we pass multiple filepath's", 
                "filepath_list = rig_common.toList(${filepath})", 
                "# loop through the filepath's and comp them.", 
                "comp = False", 
                "for filepath in filepath_list:", 
                "    if os.path.isfile(filepath):", 
                "        if comp:", 
                "            comp_data_object = ${data_type}.${data_class}()", 
                "            comp_data_object.read(filepath)", 
                "            data_object = comp_data_object + data_object", 
                "        else:", 
                "            data_object.read(filepath)", 
                "            comp = True", 
                "    else:", 
                "        mc.warning('{} does not exist'.format(filepath)) ", 
                "        ", 
                "if ${apply}:", 
                "    nodes = ${nodes}", 
                "    attributes = ${attributes}", 
                "    if attributes:", 
                "        data_object.applyData(nodes, attributes=attributes, **${kwargs})", 
                "    else:", 
                "        data_object.applyData(nodes, **${kwargs})"
            ]
        }, 
        "/load_deformer_order_data": {
            "instance": "/load_data", 
            "enabled": true, 
            "attrs": {
                "apply": {
                    "comment": "Whether or not to apply the data or just load it into memory.", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "attributes": {
                    "comment": "Which attributes to use when loading the data. ", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "data_class": {
                    "type": "raw", 
                    "value": "DeformerOrderData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "deformer_order_data"
                }, 
                "nodes": {
                    "type": "list", 
                    "value": "[mc.listRelatives(node, p=True)[0] for node in mc.ls(type=\"mesh\")+mc.ls(type=\"nurbsCurve\")]"
                }
            }
        }, 
        "/load_joint_data": {
            "instance": "/load_data", 
            "enabled": true, 
            "attrs": {
                "apply": {
                    "comment": "Whether or not to apply the data or just load it into memory.", 
                    "type": "raw", 
                    "value": true
                }, 
                "attributes": {
                    "comment": "Which attributes to use when loading the data. ", 
                    "type": "list", 
                    "value": "[]"
                }, 
                "data_class": {
                    "type": "raw", 
                    "value": "JointData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "joint_data"
                }, 
                "kwargs": {
                    "type": "dict", 
                    "value": "{}"
                }, 
                "nodes": {
                    "comment": "Joint array that we want to load the joint data onto", 
                    "type": "raw", 
                    "value": "mc.ls(type=\"joint\")"
                }
            }
        }, 
        "/load_maya_file": {
            "enabled": true, 
            "attrs": {
                "filepath": {
                    "comment": "Path to file we want to load", 
                    "type": "NoneType"
                }
            }, 
            "code": [
                "mc.undoInfo(openChunk=1) ", 
                "filepath = r\"${filepath}\"", 
                "try: ", 
                "    if os.path.isfile(filepath):", 
                "        mc.file(filepath, i=True, force=True)", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1) ", 
                ""
            ]
        }, 
        "/load_node_data": {
            "instance": "/load_data", 
            "enabled": true, 
            "attrs": {
                "apply": {
                    "comment": "Whether or not to apply the orients once the file is loaded.", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "attributes": {
                    "comment": "attribute filter override in case you want to apply specific attributes.", 
                    "type": "list", 
                    "value": "[]"
                }
            }
        }, 
        "/load_sdk_data": {
            "instance": "/load_data", 
            "enabled": true, 
            "attrs": {
                "apply": {
                    "type": "bool", 
                    "value": "True"
                }, 
                "attributes": {
                    "type": "list", 
                    "value": "[]"
                }, 
                "data_class": {
                    "type": "raw", 
                    "value": "SdkData"
                }, 
                "data_type": {
                    "type": "raw", 
                    "value": "sdk_data"
                }, 
                "nodes": {
                    "type": "list", 
                    "value": "[]"
                }
            }
        }, 
        "/mirror_cluster": {
            "instance": "/mirror_deformer", 
            "attrs": {
                "deformer_type": {
                    "type": "raw", 
                    "value": "cluster"
                }
            }
        }, 
        "/mirror_control_curves": {
            "instance": "/mirror_curves", 
            "attrs": {
                "node_list": {
                    "value": "mc.listRelatives(mc.listRelatives(mc.ls(\"*.__control__\", o=1), s=1, ni=1, type='nurbsCurve'), p=1) or []"
                }
            }
        }, 
        "/mirror_curves": {
            "comment": "Mirror all curves. This is the abstract version of mirroring curves.\n", 
            "attrs": {
                "node_list": {
                    "comment": "Node list of curves transforms", 
                    "type": "raw", 
                    "value": " mc.listRelatives(mc.ls(type='nurbsCurve'), p=True) or []"
                }
            }, 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    controls = rig_control.getControls()", 
                "    if controls:", 
                "        # Store current pose", 
                "        rig_control.setPoseAttr(controls, 5)", 
                "        # Got to bind pose", 
                "        rig_control.toPoseAttr(controls, 0)", 
                "    # Mirror", 
                "    for node in ${node_list}:", 
                "        if rig_common.getSideToken(node) is 'l':", 
                "            rig_curve.mirror(node)", 
                "    if controls:", 
                "        # Restore pose", 
                "        rig_control.toPoseAttr(controls, 5)", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                ""
            ]
        }, 
        "/mirror_deformer": {
            "comment": "The abstract node for mirroring deformers that aren't a skinCluster.", 
            "attrs": {
                "deformer_type": {
                    "comment": "Deformer type you want to mirror", 
                    "type": "raw", 
                    "value": "cluster"
                }, 
                "mirror_selected": {
                    "type": "bool", 
                    "value": "False"
                }
            }, 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    deformer_type = '${deformer_type}'", 
                "    ", 
                "    # Get Selection or highlighted", 
                "    #", 
                "    sel = mc.ls(sl=1, dag=1, s=1, ni=1)", 
                "    if not sel:", 
                "        sel = mc.ls(hl=1, dag=1, s=1, ni=1)", 
                "    map = None", 
                "    if ${mirror_selected}:", 
                "        ctx = mc.currentCtx()", 
                "        '''", 
                "        if ctx == 'artAttrBlendShapeContext':", 
                "            deformer = mc.artAttrCtx(ctx, q=True, attrSelected=True).split('.')[1]", 
                "            geo = mc.deformer(deformer, q=True, g=True)[0]", 
                "            map = mc.textScrollList('blendShapeTargetList', q=True, si=True)[0]", 
                "        '''", 
                "        if 'artAttrContext' in ctx or 'artAttrCtx' in ctx:", 
                "            deformer = mc.artAttrCtx(ctx, q=True, attrSelected=True).split('.')[1]", 
                "            sel = mc.deformer(deformer, q=True, g=True)", 
                "        ", 
                "    # Mirror", 
                "    #", 
                "    mirror_info = ''", 
                "    for shape in sel:", 
                "        destination_shape = rig_common.getMirrorName(shape)", 
                "        if ${mirror_selected}:", 
                "            destination_deformer = rig_common.getMirrorName(deformer) or deformer", 
                "            rig_weights.mirrorWeights(deformer, shape, destination_deformer, destination_shape, map)", 
                "            mirror_info += '\\nMirrored: ' + deformer", 
                "        else:", 
                "            deformers = [deformer for deformer in mc.ls(mc.listHistory(shape, pdo=1, il=1), type=deformer_type) if 'r' != rig_common.getSideToken(deformer)]", 
                "            for deformer in deformers:", 
                "                destination_deformer = rig_common.getMirrorName(deformer) or deformer", 
                "                rig_weights.mirrorWeights(deformer, shape, destination_deformer, destination_shape, None)", 
                "                mirror_info += '\\nMirrored: ' + deformer", 
                "            ", 
                "    if mirror_info:", 
                "        print(mirror_info)", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                ""
            ]
        }, 
        "/mirror_joints": {
            "comment": "This is the node used to mirror joints based on the node_list attribute", 
            "attrs": {
                "node_list": {
                    "comment": "The joints you wish to mirror", 
                    "type": "raw", 
                    "value": "mc.ls('*_bind', type='joint')"
                }
            }, 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    jointList = list()", 
                "    faceJointList = list()", 
                "    for node in ${node_list}:", 
                "        if rig_common.getSideToken(node) is 'l':", 
                "            path = mc.ls(node, l=True)[0]", 
                "            if '|skull_bind|' in path:", 
                "                faceJointList.append(node)", 
                "            else:", 
                "                jointList.append(node)", 
                "", 
                "    rig_joint.rotateToOrient(jointList+faceJointList)", 
                "    rig_joint.mirror(jointList, mode='rotate', zeroRotate=True)", 
                "    rig_joint.mirror(faceJointList, mode='translate', zeroRotate=True)", 
                "", 
                "    # Freeze rotations", 
                "    #mc.makeIdentity(${node_list}, apply=1, t=0, r=1, s=0, pn=1)", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                ""
            ]
        }, 
        "/mirror_sdk": {
            "comment": "Mirror node for SDK's. To change what's being mirrored, ,change the node_list attribute as well as the replace and search attributes.", 
            "attrs": {
                "node_list": {
                    "comment": "SDK nodes you want to mirror", 
                    "type": "raw", 
                    "value": "mc.ls(type=[\"animCurveUU\", \"animCurveUA\", \"animCurveUL\", \"animCurveUT\"])"
                }, 
                "replace": {
                    "comment": "This is what you're replacing the search attribute with when found.", 
                    "type": "raw", 
                    "value": "_r_"
                }, 
                "search": {
                    "comment": "This is what will be searched for to be replaced in the name of the sdk", 
                    "type": "raw", 
                    "value": "_l_"
                }
            }, 
            "code": [
                "currentData = sdk_data.SdkData()", 
                "currentData.gatherDataIterate(${node_list})", 
                "data = currentData.getData()", 
                "for k in data.keys():", 
                "    data[k.replace('${search}','${replace}')] = data[k]", 
                "", 
                "currentData.applyData(data.keys())", 
                ""
            ]
        }, 
        "/mirror_skincluster": {
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    rig_skinCluster.removeLocalize(mc.ls(type=\"skinCluster\"))", 
                "    controls = rig_control.getControls()", 
                "    if controls:", 
                "        # Store current pose", 
                "        rig_control.setPoseAttr(controls, 5)", 
                "        # Got to bind pose", 
                "        rig_control.toPoseAttr(controls, 0)", 
                "    # Mirror", 
                "    sel = mc.ls(sl=1, dag=1, s=1, ni=1)", 
                "    if not sel:", 
                "        sel = mc.ls(hl=1, dag=1, s=1, ni=1)", 
                "    for s in sel:", 
                "        sc = mc.ls(mc.listHistory(s, pdo=1, il=1), type='skinCluster')", 
                "        if sc:", 
                "            sc = sc[0]", 
                "            # smoother - World space mirroring messes up interpenetratin parts of the mesh", 
                "            #            at times, so add a smoother at the begging of the chain to remove", 
                "            #            most interpenetration to resolve this issue.", 
                "            delta_mush = mc.deltaMush(s, frontOfChain=1)[0]", 
                "            mc.setAttr(delta_mush+'.displacement', 0)", 
                "            mc.copySkinWeights(ss=sc, ds=sc, mirrorMode='YZ', ", 
                "                               surfaceAssociation='closestPoint', ", 
                "                               influenceAssociation=('label', 'closestJoint'))", 
                "            mc.delete(delta_mush)", 
                "            print(\"mirrored \" + sc),", 
                "    if controls:", 
                "        # Restore pose", 
                "        rig_control.toPoseAttr(controls, 5)", 
                "", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                ""
            ]
        }, 
        "/mirror_transforms": {
            "attrs": {
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls(type=\"transform\")"
                }, 
                "position_vector": {
                    "type": "tuple", 
                    "value": "(-1, 1, 1)"
                }, 
                "replace": {
                    "type": "str", 
                    "value": "'_r_'"
                }, 
                "rotate_vector": {
                    "type": "tuple", 
                    "value": "(-1, 1, 1)"
                }, 
                "scale_vector": {
                    "type": "tuple", 
                    "value": "(1, 1, -1)"
                }, 
                "search": {
                    "type": "str", 
                    "value": "'_l_'"
                }
            }, 
            "code": [
                "rig_transform.mirror(${node_list}, search=${search}, replace=${replace}, posVector=${position_vector}, rotVector=${rotate_vector}, scaleVector=${scale_vector})"
            ]
        }, 
        "/mirror_wire": {
            "instance": "/mirror_deformer", 
            "attrs": {
                "deformer_type": {
                    "value": "wire"
                }
            }
        }, 
        "/save_maya_file": {
            "attrs": {
                "dir_path": {
                    "type": "raw", 
                    "value": "${file::build}"
                }, 
                "file_name": {
                    "type": "raw", 
                    "value": "${element}_${variant}_${file_type}.ma"
                }, 
                "file_type": {
                    "type": "raw", 
                    "value": "rig"
                }
            }, 
            "code": [
                "import os.path", 
                "", 
                "dir_path = '${dir_path}'", 
                "file_path = '${dir_path}/${file_name}'", 
                "", 
                "if os.path.exists(dir_path):", 
                "", 
                "    mc.file(rename=file_path)", 
                "    mc.file(save=True, type=\"mayaAscii\")", 
                "    print 'Saved ${file_type} file: ' + file_path"
            ]
        }, 
        "/select_sdks": {
            "attrs": {
                "sdk_name_list": {
                    "type": "raw", 
                    "value": "mc.ls(\"*_def_auto*\", type=[\"animCurveUU\", \"animCurveUA\", \"animCurveUL\", \"animCurveUT\"])"
                }
            }, 
            "code": [
                "mc.select(${sdk_name_list})", 
                "        "
            ]
        }, 
        "/space_switch": {
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "str", 
                    "value": "''"
                }, 
                "constraint_node": {
                    "type": "str", 
                    "value": "''"
                }, 
                "constraint_type": {
                    "type": "str", 
                    "value": "'orient'"
                }, 
                "default_target_index": {
                    "type": "int", 
                    "value": "0"
                }, 
                "name_default": {
                    "type": "str", 
                    "value": "'local'"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "[]"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "''"
                }, 
                "space_attribute_name": {
                    "type": "str", 
                    "value": "'space'"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "[]"
                }
            }, 
            "code": [
                "import maya.cmds as mc", 
                "import openrig.maya.riglib.spaces", 
                "", 
                "if mc.objExists(${constraint_node}) and mc.objExists(${attribute_node}):", 
                "    group=openrig.maya.riglib.spaces.create(${constraint_node}, ${attribute_node}, parent=${parent},spaceAttrName=${space_attribute_name}, nameDefault=${name_default} )", 
                "    if ${target_list} and ${name_list}:", 
                "        openrig.maya.riglib.spaces.addSpace(${constraint_node}, ${target_list}, ${name_list}, group, ${attribute_node}, ${constraint_type})", 
                "        mc.setAttr('{}.{}'.format(${attribute_node}, ${space_attribute_name}), ${default_target_index})", 
                "        ", 
                ""
            ]
        }, 
        "/wire_to_skincluster": {
            "enabled": "/", 
            "comment": "This node will be used to convert wires to skinClusters\n", 
            "attrs": {
                "deformer_name": {
                    "comment": "Deformer ", 
                    "type": "str", 
                    "value": "''"
                }, 
                "joint_depth": {
                    "comment": "How far to go to keep make sure the deformation happens correctly", 
                    "type": "int", 
                    "value": "3"
                }, 
                "keep_wires": {
                    "comment": "Whether or not to keep the wires", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "comment": "The root parent", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "root_pre_matrix": {
                    "comment": "Node the will be used for the preMatrix", 
                    "type": "str", 
                    "value": "'trs_aux'"
                }, 
                "target_geometry": {
                    "comment": "Geometry you want to put the defomer on", 
                    "type": "raw", 
                    "value": "mc.listRelatives(mc.ls(mc.ls('model', dag=1, s=1, ni=1), type='mesh'), p=1)"
                }, 
                "wire_list": {
                    "comment": "List of wires you wish to convert", 
                    "type": "list", 
                    "value": "[]"
                }
            }, 
            "code": [
                "import traceback", 
                "", 
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    rig_wire.convertWiresToSkinCluster(${deformer_name}, ${target_geometry}, ${wire_list}, ${keep_wires}, ${root_parent}, ${root_pre_matrix}, ${joint_depth})   ", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                ""
            ]
        }, 
        "/yank_cluster": {}, 
        "/yank_skincluster": {
            "comment": "This node is used to pull influences around to calculate a falloff based on a smoother version of the weighting.", 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    selection_list = mc.ls(sl=True, dag=True, s=True, ni=True)", 
                "    if not selection_list:", 
                "        selection_list = mc.ls(hl=True, dag=True, s=True, ni=True)", 
                "    if selection_list:", 
                "        skincluster = mc.ls(mc.listHistory(selection_list, pdo=True, il=True), type='skinCluster')", 
                "        if skincluster:", 
                "            deltamush_list = mc.ls(mc.listHistory(selection_list, pdo=True, il=True), type='deltaMush')", 
                "            if deltamush_list:", 
                "                for deltamush in deltamush_list:", 
                "                    mc.setAttr('{}.envelope'.format(deltamush), 1)", 
                "            target = mc.listRelatives(selection_list, p=True)[0]", 
                "            base = mc.duplicate(target)[0]", 
                "            weight_list = list()", 
                "            skincluster = skincluster[0]", 
                "            influence_list = mc.skinCluster(skincluster, q=True, inf=True)", 
                "            for influence in influence_list:", 
                "                matrix_connection = mc.listConnections('{}.worldMatrix[0]'.format(influence), p=True, d=True, s=True)", 
                "                influence_index = None", 
                "                for connection in matrix_connection:", 
                "                    node = connection.split('.')[0]", 
                "                    if node == skincluster:", 
                "                        influence_index = connection.split('[')[1].split(']')[0]", 
                "                if influence_index:", 
                "                    temp_influence = mc.duplicate(influence, po=True)[0]", 
                "                    mc.connectAttr('{}.worldMatrix[0]'.format(temp_influence), '{}.matrix[{}]'.format(skincluster, influence_index), f=True)", 
                "                    mc.move(1, 0, 0, temp_influence, r=True, worldSpaceDistance=True) ", 
                "                    weight_list.append(rig_shape.getDeltas(base, target))", 
                "                    mc.connectAttr('{}.worldMatrix[0]'.format(influence), '{}.matrix[{}]'.format(skincluster, influence_index), f=True)                         ", 
                "                    mc.delete(temp_influence)", 
                "            # Set Weights", 
                "            rig_weights.setWeights(skincluster, weight_object.WeightObject(maps=influence_list, weights=weight_list)) ", 
                "            if deltamush_list:", 
                "                for deltamush in deltamush_list:", 
                "                    mc.setAttr('{}.envelope'.format(deltamush), 0)", 
                "            mc.delete(base)     ", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)"
            ]
        }
    }
}