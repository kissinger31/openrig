{
    "version": "1.17", 
    "alias": "rig_components", 
    "color": "#55aaff", 
    "mute": false, 
    "solo": false, 
    "meta_data": {
        "positions": {
            "/anim_rig": [
                -48.75260724841539, 
                -1668.6955542942744
            ], 
            "/arm": [
                -860.0, 
                400.0
            ], 
            "/auto_parent": [
                -860.0, 
                300.0
            ], 
            "/blink": [
                -1220.0, 
                200.0
            ], 
            "/blink/blink_rig_setup/upper/socket": [
                0.0, 
                0.0
            ], 
            "/blink/create": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_clusters/lower": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_clusters/upper": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_collision": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_collision/lid_squash": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_collision/lid_squash/connect": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_rig_setup": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_rig_setup/lid_wire": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_rig_setup/lid_wire/rename_controls": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_rig_setup/upper/cluster_rig": [
                0.0, 
                0.0
            ], 
            "/blink/create/blink_rig_setup/upper/curve_rig": [
                0.0, 
                0.0
            ], 
            "/blink/create/controls": [
                0.0, 
                0.0
            ], 
            "/blink/create/controls/eye_socket/control/connect": [
                0.0, 
                0.0
            ], 
            "/blink/create/controls/eye_socket/control/selection_handle": [
                0.0, 
                0.0
            ], 
            "/blink/create/controls/lower_lid/control": [
                0.0, 
                0.0
            ], 
            "/blink/create/controls/lower_lid/drivers": [
                0.0, 
                0.0
            ], 
            "/blink/create/controls/upper_lid/control/driver": [
                0.0, 
                0.0
            ], 
            "/blink/create/controls/upper_lid/node": [
                0.0, 
                0.0
            ], 
            "/blink/create/eye_drag": [
                0.0, 
                0.0
            ], 
            "/blink/create/eye_socket": [
                0.0, 
                0.0
            ], 
            "/blink/create/eye_socket/control": [
                0.0, 
                0.0
            ], 
            "/blink/create/node2": [
                0.0, 
                0.0
            ], 
            "/blink/create/scale_compensate": [
                0.0, 
                0.0
            ], 
            "/brow": [
                -460.0, 
                300.0
            ], 
            "/brow/brow_inner": [
                0.0, 
                0.0
            ], 
            "/brow/brow_main/align_orientation": [
                0.0, 
                0.0
            ], 
            "/brow/brow_main/connect": [
                0.0, 
                0.0
            ], 
            "/brow/brow_peak": [
                0.0, 
                0.0
            ], 
            "/brow/corrugator": [
                0.0, 
                0.0
            ], 
            "/brow/create": [
                0.0, 
                0.0
            ], 
            "/brow/curve_rig": [
                0.0, 
                0.0
            ], 
            "/brow/curve_rig/create": [
                0.0, 
                0.0
            ], 
            "/brow/curve_rig/wire_deformer": [
                0.0, 
                0.0
            ], 
            "/control2": [
                -2692.632401497651, 
                658.9052191923134
            ], 
            "/foot": [
                -1220.0, 
                300.0
            ], 
            "/left": [
                1473.2730781054697, 
                -1720.7771333894118
            ], 
            "/leg": [
                -460.0, 
                400.0
            ], 
            "/limb": [
                -1220.0, 
                400.0
            ], 
            "/load_joint_data": [
                -1481.6869960946144, 
                -934.6882129642566
            ], 
            "/load_maya_file": [
                -1679.5428579798536, 
                -1154.5937434281623
            ], 
            "/look_at": [
                -1600.0, 
                200.0
            ], 
            "/look_at/create/space_switch": [
                0.0, 
                0.0
            ], 
            "/mouth": [
                -860.0, 
                200.0
            ], 
            "/mouth/bind_geometry": [
                0.0, 
                0.0
            ], 
            "/mouth/create": [
                0.0, 
                0.0
            ], 
            "/mouth/lip": [
                0.0, 
                0.0
            ], 
            "/mouth/lip/bindmesh_bind": [
                0.0, 
                0.0
            ], 
            "/mouth/lip/create": [
                0.0, 
                0.0
            ], 
            "/mouth/lip/create/setup_controls": [
                0.0, 
                0.0
            ], 
            "/mouth/lip/create/tweak_controls": [
                0.0, 
                0.0
            ], 
            "/mouth/lip_main/create/setup_sdk": [
                0.0, 
                0.0
            ], 
            "/mouth/lip_main/create/wire_deformer": [
                0.0, 
                0.0
            ], 
            "/mouth/rig_sets": [
                0.0, 
                0.0
            ], 
            "/neck": [
                -1580.0, 
                300.0
            ], 
            "/node2": [
                -1717.2223999251441, 
                495.45646287148423
            ], 
            "/spine": [
                -1580.0, 
                400.0
            ], 
            "/spine/psd_drivers": [
                0.0, 
                0.0
            ], 
            "/tongue": [
                -460.0, 
                200.0
            ], 
            "/tongue/controls": [
                0.0, 
                0.0
            ], 
            "/tongue/create": [
                0.0, 
                0.0
            ], 
            "anim_rig/init": [
                30.0, 
                250.0
            ], 
            "arm/clavicle": [
                30.0, 
                147.0
            ], 
            "arm/clavicle/clavicle_connect": [
                0.0, 
                0.0
            ], 
            "arm/clavicle/control": [
                30.0, 
                43.0
            ], 
            "arm/clavicle/control/node": [
                0.0, 
                0.0
            ], 
            "arm/limb/create": [
                30.0, 
                648.0
            ], 
            "left/arm/hand": [
                30.0, 
                1149.0
            ], 
            "left/arm/limb/create": [
                30.0, 
                605.0
            ], 
            "leg/node": [
                0.0, 
                0.0
            ], 
            "limb/create/connect": [
                0.0, 
                0.0
            ], 
            "limb/create/fk/controls": [
                0.0, 
                0.0
            ], 
            "limb/create/ik": [
                30.0, 
                86.0
            ], 
            "limb/create/ik/controls": [
                0.0, 
                0.0
            ], 
            "limb/create/ik/controls/visibility": [
                0.0, 
                0.0
            ], 
            "limb/create/ik/offset": [
                0.0, 
                0.0
            ], 
            "limb/create/param": [
                0.0, 
                0.0
            ], 
            "limb/create/param/stretch": [
                0.0, 
                0.0
            ], 
            "spline/controls/fk": [
                0.0, 
                0.0
            ], 
            "spline/controls/fk/hip_swivel": [
                681.0122705254066, 
                8.882768745983565
            ], 
            "spline/controls/fk/hip_swivel/connect": [
                0.0, 
                0.0
            ], 
            "spline/controls/fk/torso": [
                568.497199742948, 
                57.737996848893154
            ], 
            "spline/controls/fk/torso/position": [
                0.0, 
                0.0
            ], 
            "spline/controls/ik": [
                0.0, 
                0.0
            ], 
            "spline/controls/ik/chest": [
                0.0, 
                0.0
            ], 
            "spline/controls/ik/chest_top": [
                0.0, 
                0.0
            ]
        }, 
        "collapse": {
            "/arm": true, 
            "/auto_parent": true, 
            "/auto_parent/duplicate_chain": false, 
            "/blink": true, 
            "/brow": true, 
            "/center": false, 
            "/center/face_lower": false, 
            "/center/face_lower/mouth_main": false, 
            "/center/neck": false, 
            "/center/neck/controls": false, 
            "/center/neck/controls/head_gimbal": false, 
            "/center/spine": false, 
            "/center/spine/controls": false, 
            "/center/spine/controls/ik": false, 
            "/center/spine/controls/ik/hip_pivot": false, 
            "/foot": true, 
            "/left": false, 
            "/left/blink": false, 
            "/left/blink/blink_rig_setup": false, 
            "/left/blink/blink_rig_setup/lid_wire": false, 
            "/left/blink/blink_rig_setup/lid_wire/rename_controls": false, 
            "/left/blink/blink_rig_setup/socket": false, 
            "/left/blink/create": false, 
            "/left/blink/create/blink_collision": false, 
            "/left/blink/create/blink_rig_setup": false, 
            "/left/blink/create/blink_rig_setup/upper": false, 
            "/left/blink/create/blink_rig_setup/upper/cluster_rig": false, 
            "/left/brow": false, 
            "/left/brow/curve_rig": false, 
            "/left/brow/curve_rig/create": false, 
            "/left/leg": false, 
            "/left/leg/limb": false, 
            "/left/leg/limb/auto_clav_world_space": false, 
            "/leg": true, 
            "/limb": true, 
            "/limb/create": false, 
            "/limb/create/param": false, 
            "/limb/create/param/match_attributes": false, 
            "/look_at": true, 
            "/look_at/create": true, 
            "/mouth": true, 
            "/neck": true, 
            "/spine": true, 
            "/tongue": true
        }
    }, 
    "nodes": {
        "/arm": {
            "child_order": [
                "clavicle", 
                "limb", 
                "hand"
            ], 
            "enabled": true, 
            "comment": "Parent node for the arm build. Everything used to create an arm should be put under this node", 
            "attrs": {
                "SIDE": {
                    "comment": "Side attribute uppercase", 
                    "type": "raw", 
                    "value": "L"
                }, 
                "clavicle_anchor": {
                    "type": "str", 
                    "value": "'chest_top'"
                }, 
                "clavicle_control": {
                    "comment": "The name of the control being used for the clavicle", 
                    "type": "str", 
                    "value": "'clavicle_${side}'"
                }, 
                "clavicle_joint": {
                    "comment": "The name of the joint being used for the clavicle", 
                    "type": "str", 
                    "value": "'clavicle_${side}_bind'"
                }, 
                "component_parent": {
                    "comment": "The parent for this component", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "mirror_swing": {
                    "comment": "Whether we should mirror the translate behavior of the swing when we're on the right side.", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "name": {
                    "comment": "Name of the group for the component", 
                    "type": "raw", 
                    "value": "arm_${side}"
                }, 
                "param_node": {
                    "comment": "Name of the parameter node where all of the attributes will live for this component.", 
                    "type": "raw", 
                    "value": "arm_${SIDE}"
                }, 
                "side": {
                    "comment": "Side attribute lowercase", 
                    "type": "raw", 
                    "value": "l"
                }, 
                "side_multiplier": {
                    "type": "int", 
                    "value": "1"
                }, 
                "swing_control": {
                    "comment": "This is the name of the control that will be used as the swing control for the arm.", 
                    "type": "str", 
                    "value": "'shoulderSwing_${side}'"
                }, 
                "swing_nul_offset": {
                    "type": "tuple", 
                    "value": "(-90 * ${side_multiplier}, 0, 0)"
                }
            }
        }, 
        "/arm/clavicle": {
            "child_order": [
                "control"
            ], 
            "enabled": true
        }, 
        "/arm/clavicle/control": {
            "instance": "/control", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "raw", 
                    "value": "${clavicle_joint}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${clavicle_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'square'"
                }, 
                "hide_attrs": {
                    "value": "['v', 'sx', 'sy', 'sz']"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'auto_offset', 'ort']"
                }
            }
        }, 
        "/arm/hand": {
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "anchor": {
                    "type": "str", 
                    "value": "'wrist_${side}_bind'"
                }, 
                "clavicle_control": {
                    "type": "str", 
                    "value": "'clavicle_${side}'"
                }, 
                "group_name": {
                    "type": "str", 
                    "value": "'hand_${side}_grp'"
                }, 
                "joint_list": {
                    "type": "list", 
                    "value": "['ring_001_${side}_bind', 'middle_001_${side}_bind', 'index_001_${side}_bind',  'pinkyCup_${side}_bind',   'thumbCup_${side}_bind']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${component_parent}"
                }
            }
        }, 
        "/arm/hand/create": {
            "enabled": true, 
            "code": [
                "# check to make sure the group for this part has been created.", 
                "if not mc.objExists(${group_name}):", 
                "   mc.createNode('transform', n=${group_name})", 
                "", 
                "# check to see if the anchor exists in the scene", 
                "if mc.objExists(${anchor}):", 
                "    mc.pointConstraint(${anchor}, ${group_name})", 
                "    mc.orientConstraint(${anchor}, ${group_name})", 
                "else:", 
                "    mc.warning('{} doesn notexists in the current Maya session!'.format(${anchor}))", 
                "", 
                "", 
                "# loop through all of the parent joints in the fingers.", 
                "parent = ${group_name}", 
                "for jnt in ${joint_list}:", 
                "    # get all of the children of the main finger joints we're using. We have to reverse the", 
                "    # list to get the order we want.", 
                "    children = mc.listRelatives(jnt, ad=True, type='joint')", 
                "    children.reverse()", 
                "", 
                "    # create the first finger control", 
                "    finger_ctrl_hierarchy = rig_control.create(name=jnt.replace('_bind', ''),", 
                "                                        controlType='square',", 
                "                                        hierarchy=['nul','ort'],", 
                "                                        parent=parent)", 
                "", 
                "    # move the control and then constrain the joint to the control.", 
                "    jnt_position = mc.xform(jnt, q=True, ws=True, matrix=True)", 
                "    mc.xform(finger_ctrl_hierarchy[0], ws=True, matrix=jnt_position)", 
                "    mc.pointConstraint(finger_ctrl_hierarchy[-1], jnt)", 
                "    mc.orientConstraint(finger_ctrl_hierarchy[-1], jnt)", 
                "    mc.connectAttr('{}.s'.format(finger_ctrl_hierarchy[-1]), '{}.s'.format(jnt))", 
                "", 
                "    # reset the parent hierarchy to be the control.", 
                "    parent = finger_ctrl_hierarchy[-1]", 
                "", 
                "    # loop throught the children to create controls for them", 
                "    for child_joint in children:", 
                "        if child_joint == children[-1]:", 
                "            parent = ${group_name}", 
                "            break", 
                "        # create the control for the child joints.", 
                "        child_ctrl_hierarchy = rig_control.create(name=child_joint.replace('_bind', ''),", 
                "                                        controlType='square',", 
                "                                        hierarchy=['nul','ort'],", 
                "                                        parent=parent)", 
                "        child_joint_position = mc.xform(child_joint, q=True, ws=True, matrix=True)", 
                "", 
                "        # move the control and then create the constraints.", 
                "        mc.xform(child_ctrl_hierarchy[0], ws=True, matrix=child_joint_position)", 
                "        mc.pointConstraint(child_ctrl_hierarchy[-1], child_joint)", 
                "        mc.orientConstraint(child_ctrl_hierarchy[-1], child_joint)", 
                "        mc.connectAttr('{}.s'.format(child_ctrl_hierarchy[-1]), '{}.s'.format(child_joint))", 
                "", 
                "", 
                "        # set the parent to be the control we just created.", 
                "        parent = child_ctrl_hierarchy[-1]", 
                "if ${parent}:", 
                "    if mc.objExists(${parent}):", 
                "        # parent the group the the name of this part", 
                "        mc.parent(${group_name}, ${parent})"
            ]
        }, 
        "/arm/limb": {
            "instance": "/limb", 
            "child_order": [
                "swing", 
                "set_zero_pose", 
                "create", 
                "auto_clav", 
                "set_control_defaults", 
                "fk_spaces", 
                "ik_spaces", 
                "auto_clav_world_space", 
                "spaces_pv"
            ], 
            "enabled": true, 
            "attrs": {
                "fk_control_list": {
                    "type": "list", 
                    "value": "[\"shoulder_fk_${side}\", \"elbow_fk_${side}\", \"wrist_fk_${side}\", \"wrist_fk_gimbal_${side}\"]"
                }, 
                "ik_control_list": {
                    "type": "list", 
                    "value": "[\"arm_pv_${side}\", \"arm_ik_${side}\", \"wrist_ik_gimbal_${side}\", \"arm_ik_mpivot_${side}\"]"
                }, 
                "joint_list": {
                    "type": "list", 
                    "value": "[\"shoulder_${side}_bind\", \"elbow_${side}_bind\", \"wrist_${side}_bind\"]"
                }, 
                "pv_aim_node": {
                    "type": "raw", 
                    "value": "'{}_pvAimNode'.format(${clavicle_control})"
                }, 
                "twist_joint_list": {
                    "type": "list", 
                    "value": "[\"shoulderNoTwist_${side}_bind\",  \"elbowTwist_${side}_bind\",  \"wristTwist_${side}_bind\"]"
                }
            }
        }, 
        "/arm/limb/auto_clav": {
            "instance": "/auto_parent", 
            "enabled": true
        }, 
        "/arm/limb/auto_clav_world_space": {
            "enabled": true, 
            "attrs": {
                "world_space_node": {
                    "type": "raw", 
                    "value": "${component_parent}"
                }
            }, 
            "code": [
                "orient = 'shoulderSwing_${side}_ortSpaces_world'", 
                "parent = 'chest_top'", 
                "attr = 'shoulderSwing_${side}.space'", 
                "add_matrix = 'clavicle_${side}_addRotation_multMatrix'", 
                "", 
                "space_grp = mc.createNode('transform', n=orient+'_autoClav_nul', p=orient)", 
                "space = mc.createNode('transform', n=orient+'_autoClav', p=space_grp)", 
                "mc.parent(space_grp, parent)", 
                "con = mc.orientConstraint(${world_space_node}, space, mo=1)[0]", 
                "mc.connectAttr(attr, con+'.rigW0')", 
                "mc.connectAttr(space+'.matrix', add_matrix+'.matrixIn[3]')"
            ]
        }, 
        "/arm/limb/create": {
            "child_order": [
                "fk", 
                "ik", 
                "param", 
                "connect", 
                "clavicle_connect", 
                "bendy_limb"
            ], 
            "attrs": {
                "anchor": {
                    "value": "${clavicle_anchor}"
                }
            }
        }, 
        "/arm/limb/create/clavicle_connect": {
            "enabled": true, 
            "code": [
                "ik_joint_list = STAGE.ikfk_system.getIkJointList()", 
                "fk_control_list = ${fk_control_list}", 
                "", 
                "# Hookup clavicle connect nul, the direct connection for the rotate allow keeps the auto", 
                "# clav from causint a double rotation on the shoulder", 
                "clavicle_connect = mc.duplicate(${clavicle_control}, po=1, n='{}_connect'.format(${clavicle_control}))[0]", 
                "rig_control.untagAsControl(clavicle_connect)", 
                "mc.parent(clavicle_connect, '{}_nul'.format(${clavicle_control}))", 
                "mc.connectAttr('{}.r'.format(${clavicle_control}), '{}.r'.format(clavicle_connect))", 
                "mc.connectAttr('{}.s'.format(${clavicle_control}), '{}.s'.format(clavicle_connect))", 
                "", 
                "# This allows the translates to come through with auto clav", 
                "upper_limb_nul = mc.createNode('transform', n='{}_nul'.format(fk_control_list[0]))", 
                "mc.xform(upper_limb_nul, ws=True, matrix=mc.xform(fk_control_list[0], q=True, ws=True, matrix=True))", 
                "clavicle_connect_translate = mc.duplicate('{}_nul'.format(${swing_control}), po=1, n='{}_connect_trans'.format(${clavicle_control}))[0]", 
                "mc.parent((fk_control_list[0], STAGE.stretch_target_joint_list[0]), upper_limb_nul)", 
                "mc.parent(clavicle_connect_translate, ${clavicle_control})", 
                "mc.pointConstraint(clavicle_connect_translate, clavicle_connect)", 
                "", 
                "# getting rid of the point constraint for now. Not sure we need it.", 
                "mc.orientConstraint(${clavicle_control}, ${clavicle_joint})", 
                "", 
                "# parent the shoulderSwing control to the clavicle control.", 
                "mc.parent(upper_limb_nul, ${swing_control}+\"_nul\")", 
                "mc.parentConstraint(${swing_control}, ik_joint_list[0], mo=True)", 
                "mc.parent('{}_nul'.format(${swing_control}), clavicle_connect)", 
                "", 
                "# Connect to passed anchor", 
                "#", 
                "if mc.objExists(${anchor}):", 
                "    try:", 
                "        mc.parent('{}_nul'.format(${clavicle_control}), ${clavicle_anchor}) ", 
                "    except:", 
                "        print \"{}_nul is already parented to {}.\".format(${clavicle_control}, ${clavicle_anchor})", 
                "else:", 
                "    # parent the clavicle to the group of this part.", 
                "    mc.parent('{}_nul'.format(${clavicle_control}), self.name)", 
                "    mc.warning('Anchor object [ {} ] does not exist.'.format(${clavicle_anchor})) ", 
                "    ", 
                "# Clavicle specific PSD setup and aim for translating", 
                "#", 
                "clavicle_jnt = ${clavicle_joint}", 
                "trans_bind = clavicle_jnt.replace('${side}_bind', 'trans_${side}_bind')", 
                "if mc.objExists(trans_bind):  ", 
                "", 
                "    # PSD driver - transform that picks up the auto clav and anim control rotation", 
                "    clavicle_driver_par = mc.duplicate(clavicle_connect, po=True, n='{}_driver_par'.format(${clavicle_control}))[0]", 
                "    clavicle_driver = mc.duplicate(clavicle_connect, po=True, n='{}_driver'.format(${clavicle_control}))[0]", 
                "    rig_control.untagAsControl(clavicle_driver_par)", 
                "    rig_control.untagAsControl(clavicle_driver)", 
                "    ", 
                "    distance_upper_jnt = \"${name}_upper_dist_jnt\"", 
                "    side = '${side}'", 
                "    aimVector = (-1, 0, 0)", 
                "    if side is 'r':", 
                "        aimVector = (1, 0, 0)", 
                "    ", 
                "    # Connect psd driver", 
                "    mc.parent(clavicle_driver, clavicle_driver_par)", 
                "    mc.parent(clavicle_driver_par,  ${clavicle_anchor})", 
                "    mc.delete(mc.orientConstraint(trans_bind, clavicle_driver_par))", 
                "    mc.orientConstraint(trans_bind, clavicle_driver)", 
                "mc.parentConstraint(${swing_control}, upper_limb_nul,mo=True)"
            ]
        }, 
        "/arm/limb/fk_spaces": {
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "str", 
                    "value": "'shoulderSwing_${side}'"
                }, 
                "constraint_node": {
                    "type": "str", 
                    "value": "'shoulderSwing_${side}_ort'"
                }, 
                "default_target_index": {
                    "type": "int", 
                    "value": "1"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "['world']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'shoulderSwing_${side}_nul'"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "['rig']"
                }
            }
        }, 
        "/arm/limb/ik_spaces": {
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "str", 
                    "value": "'arm_ik_${side}'"
                }, 
                "constraint_node": {
                    "type": "str", 
                    "value": "'arm_ik_${side}_ort'"
                }, 
                "constraint_type": {
                    "type": "str", 
                    "value": "'parent'"
                }, 
                "name_default": {
                    "value": "'world'"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "['chest', 'head', 'hip_swivel', 'hips']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'${name}'"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "['chest_bind', 'skull_bind', 'hip_swivel', 'hips_bind']"
                }
            }
        }, 
        "/arm/limb/set_control_defaults": {
            "child_order": [
                "set_fk_controls", 
                "set_swing_control", 
                "set_ik_controls", 
                "set_joint_orients"
            ], 
            "attrs": {
                "zero_control_list": {
                    "type": "raw", 
                    "value": "[${swing_control}] + ${fk_control_list}"
                }
            }
        }, 
        "/arm/limb/set_control_defaults/set_swing_control": {
            "code": [
                "mc.setAttr('{}.r'.format(${swing_control}), *mc.getAttr('{}.r'.format(self.fk_control_list[0]))[0])", 
                "mc.setAttr('{}.r'.format(self.fk_control_list[0]), 0,0,0)"
            ]
        }, 
        "/arm/limb/spaces_pv": {
            "instance": "/space_switch", 
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "str", 
                    "value": "'arm_pv_${side}'"
                }, 
                "constraint_node": {
                    "type": "str", 
                    "value": "'arm_pv_${side}_nul'"
                }, 
                "constraint_type": {
                    "type": "str", 
                    "value": "'parent'"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "['chest', 'hand']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${component_parent}"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "['chest_bind', 'wrist_fk_${side}_offset_pv']"
                }
            }
        }, 
        "/arm/limb/swing": {
            "child_order": [
                "control"
            ], 
            "enabled": true
        }, 
        "/arm/limb/swing/control": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "mirror_swing", 
                "pv_aim_node", 
                "orient_swing"
            ], 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "str", 
                    "value": "'shoulder_${side}_bind'"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${swing_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'square'"
                }, 
                "hide_attrs": {
                    "value": "['v', 'sx', 'sy', 'sz']"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": [
                        "nul", 
                        "mirror_ort", 
                        "ort"
                    ]
                }
            }
        }, 
        "/arm/limb/swing/control/mirror_swing": {
            "enabled": true, 
            "code": [
                "# get the aim direction", 
                "joint_list = ${joint_list}", 
                "aim_distance = mc.getAttr('{}.t'.format(joint_list[1]))[0]", 
                "aim_attr, aim_vector = rig_transform.getDistanceVector(aim_distance)", 
                "side_pos = mc.xform(joint_list[1], q=True, ws=True, t=True)", 
                "", 
                "# set the Ort node to be mirrored from the other side", 
                "if side_pos[0] < 0:   ", 
                "    mc.setAttr(\"{}_ort.r{}\".format(${clavicle_control}, aim_attr.strip(\"-\")), 180)", 
                "    mc.setAttr(\"{}_ort.s{}\".format(${clavicle_control}, aim_attr.strip(\"-\")), -1)", 
                "    # mirror the swing also if it is required by the build", 
                "    if ${mirror_swing}:", 
                "        mc.setAttr('{}.r{}'.format(${control_name}+'_mirror_ort', aim_attr.strip('-')), 180)", 
                "        mc.setAttr('{}.s{}'.format(${control_name}+'_mirror_ort', aim_attr.strip('-')), -1)"
            ]
        }, 
        "/arm/limb/swing/control/orient_swing": {
            "code": [
                "# zero out the shoulder swing", 
                "#STAGE.swing_position = mc.xform(${swing_control}, q=True, ws=True, matrix=True)", 
                "", 
                "nul = ${swing_control}+'_nul'", 
                "if mc.objExists(nul):", 
                "    mc.xform(nul, ws=True, rotation=${swing_nul_offset})", 
                "", 
                "#set the swing to be in the same space as it's parent.", 
                "mc.setAttr('{}.r'.format(${swing_control}), 0, 0, 0)"
            ]
        }, 
        "/arm/limb/swing/control/pv_aim_node": {
            "enabled": true, 
            "code": [
                "# make the node we can aim the wrist pv driver at for pv space switching to follow hand.", 
                "pvAimNode = mc.duplicate('{}_nul'.format(${clavicle_control}), po=True, rr=True, name=${pv_aim_node})[0]", 
                "# parent the duplicate to the clavicles anchor", 
                "if mc.objExists(${clavicle_anchor}):", 
                "    mc.parent(pvAimNode, ${clavicle_anchor})"
            ]
        }, 
        "/auto_parent": {
            "child_order": [
                "duplicate_chain", 
                "connect", 
                "param_node", 
                "psd"
            ], 
            "enabled": true, 
            "comment": "This component handles the auto clavicle. ", 
            "attrs": {
                "SIDE": {
                    "comment": "Side attribute that is uppercase", 
                    "type": "raw", 
                    "value": "L"
                }, 
                "amount": {
                    "type": "float", 
                    "value": ".3"
                }, 
                "auto_blend_attribute": {
                    "comment": "The attribute we will use for the blending between auto clav or no auto clav", 
                    "type": "str", 
                    "value": "'autoClav'"
                }, 
                "auto_clav_anchor": {
                    "comment": "What will be driving the auto clavicle system", 
                    "type": "str", 
                    "value": "'arm_${side}_anchor_grp'"
                }, 
                "component_parent": {
                    "comment": "Parent for the component", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "ik_blend_attribute": {
                    "comment": "The attribute being used for the IK and FK  blending", 
                    "type": "str", 
                    "value": "'arm_${side}_rvr.output.outputX'"
                }, 
                "ik_joint_list": {
                    "comment": "Name joint list being used for the IK system", 
                    "type": "list", 
                    "value": "['shoulder_${side}_bind_ik','elbow_${side}_bind_ik','wrist_${side}_bind_ik']"
                }, 
                "input_control_list": {
                    "comment": "Controls that will be driving the auto clav setup", 
                    "type": "list", 
                    "value": "['shoulderSwing_${side}', 'shoulder_fk_${side}']"
                }, 
                "name": {
                    "comment": "Name for the group where the nodes will live for this component", 
                    "type": "raw", 
                    "value": "${side}_autoClav"
                }, 
                "name_list": {
                    "comment": "Name of the nodes for the auto clavicle", 
                    "type": "list", 
                    "value": "['${parent_control}_auto_start', '${parent_control}_auto_mid', '${parent_control}_auto_end']"
                }, 
                "param_node": {
                    "comment": "Paramter node that will b e used and where attribute live for the limb", 
                    "type": "raw", 
                    "value": "arm_${SIDE}"
                }, 
                "parent_control": {
                    "comment": "parent control for the auto clavicle nodes", 
                    "type": "raw", 
                    "value": "clavicle_${side}"
                }, 
                "side": {
                    "comment": "Side attribute that is lowercase", 
                    "type": "raw", 
                    "value": "l"
                }
            }
        }, 
        "/auto_parent/connect": {
            "enabled": true, 
            "code": [
                "# we do list manipulation, so I am going to declare a variable here.", 
                "input_control_list = ${input_control_list}", 
                "", 
                "# Combine the rotation of the input controls", 
                "add_rotation_matrix = mc.createNode('multMatrix', n='${parent_control}_addRotation_multMatrix')", 
                "# Matrix multiplication is done in reverse order of hierarchy", 
                "input_control_list.reverse()", 
                "for input_control, i in zip(input_control_list, xrange(len(input_control_list))):", 
                "    mc.connectAttr('{}.matrix'.format(input_control), '{}.matrixIn[{}]'.format(add_rotation_matrix, i))", 
                "", 
                "offset = mc.duplicate(input_control_list[1], po=1, n='{}_clav_offset'.format(input_control_list[0]))[0]", 
                "rig_control.untagAsControl(offset)", 
                "mc.connectAttr('{}.inverseMatrix'.format(offset), '{}.matrixIn[{}]'.format(add_rotation_matrix, 2))", 
                "", 
                "add_rotation = mc.createNode('decomposeMatrix', n='${parent_control}_addRotation_dcmpMatrix')", 
                "mc.connectAttr('{}.matrixSum'.format(add_rotation_matrix), '{}.inputMatrix'.format(add_rotation))", 
                "", 
                "# Drive the auto ik upper joint with driven keys so it sill works with ik blend", 
                "fk = '{}.outputRotate'.format(add_rotation)", 
                "auto = STAGE.joint_list[0]", 
                "for axis in ['X', 'Y', 'Z']:", 
                "    mc.setDrivenKeyframe('{}.rotate{}'.format(auto, axis), currentDriver='{}{}'.format(fk, axis),", 
                "                         dv=-180, itt=\"spline\", ott= \"spline\", value=-180)", 
                "    mc.setDrivenKeyframe('{}.rotate{}'.format(auto, axis), currentDriver='{}{}'.format(fk, axis),", 
                "                         dv=180, itt=\"spline\", ott=\"spline\", value=180)", 
                "    key = mc.listConnections('{}.rotate{}'.format(auto, axis), s=True, d=False)[0]", 
                "    mc.setAttr(key+'.preInfinity', 1)", 
                "    mc.setAttr(key+'.postInfinity', 1)", 
                "", 
                "input_ik_handle = mc.listConnections('{}.message'.format(${ik_joint_list}[0]), type='ikHandle')", 
                "# Copy input ik connections", 
                "if input_ik_handle:", 
                "    input_ik_handle = input_ik_handle[0]", 
                "    par = mc.listRelatives(input_ik_handle, p=True)", 
                "    if par:", 
                "        mc.parent(STAGE.auto_ik_handle, par[0])", 
                "    mc.connectAttr(${ik_blend_attribute}, '{}.ikBlend'.format(STAGE.auto_ik_handle))", 
                "    # Pole vector constraint", 
                "    pv_con = mc.listConnections('{}.poleVectorX'.format(input_ik_handle))", 
                "    if pv_con:", 
                "        pv_target = mc.poleVectorConstraint(pv_con[0], q=True, targetList=True)[0]", 
                "        mc.poleVectorConstraint(pv_target, STAGE.auto_ik_handle)", 
                "        ", 
                "# Add blend attributes", 
                "mc.addAttr('${parent_control}', ln=${auto_blend_attribute}, at='double', min=0, max=1, dv=1, k=1)"
            ]
        }, 
        "/auto_parent/duplicate_chain": {
            "enabled": true, 
            "code": [
                "# create the group for the component", 
                "if not mc.objExists('${name}'):", 
                "    mc.createNode('transform', name='${name}')", 
                "    if mc.objExists(${component_parent}):", 
                "        mc.parent('${name}', ${component_parent})", 
                "", 
                "STAGE.joint_list = rig_joint.duplicateChain(${ik_joint_list}, names=${name_list}, parent=${auto_clav_anchor})", 
                "for jnt in STAGE.joint_list:", 
                "    mc.setAttr('{}.rotateOrder'.format(jnt), 0)", 
                "STAGE.auto_ik_handle = mc.ikHandle(sj=STAGE.joint_list[0],  ee=STAGE.joint_list[-1],", 
                "                          sol=\"ikRPsolver\", name='${parent_control}_auto_ikHandle')[0]", 
                "mc.hide(STAGE.auto_ik_handle)", 
                "mc.parent(STAGE.auto_ik_handle, '${name}')"
            ]
        }, 
        "/auto_parent/param_node": {
            "enabled": true, 
            "code": [
                "if mc.objExists('${param_node}'):", 
                "    # create proxy attribute on the paramNode for the auotClav", 
                "    mc.addAttr('${param_node}', ln=${auto_blend_attribute}, at=\"double\", min=0, max=1, dv=0, keyable=True, proxy='${parent_control}.{}'.format(${auto_blend_attribute}))", 
                "    ", 
                "    mc.addAttr('${param_node}', ln=\"clavicleCtrl\", dt=\"string\")", 
                "    mc.setAttr(\"${param_node}.clavicleCtrl\", '${parent_control}', type=\"string\")"
            ]
        }, 
        "/auto_parent/psd": {
            "child_order": [
                "poses", 
                "connect", 
                "remove_extra_neutrals"
            ], 
            "enabled": true, 
            "code": [
                ""
            ]
        }, 
        "/auto_parent/psd/connect": {
            "code": [
                "# Joint for inserting auto rotation into the parent controls hierarchy", 
                "driver = STAGE.joint_list[0]", 
                "", 
                "# get the ikBlend attr so we can make sure the driver ik system is in fk mode", 
                "param = '${param_node}'", 
                "if mc.objExists(param):", 
                "    param_orig_ikfk_state = mc.getAttr('{}.ikfk'.format(param))", 
                "    # Set to fk mode", 
                "    mc.setAttr('{}.ikfk'.format(param), 1)", 
                "", 
                "# Make a joint the is only the swing of the auto joint", 
                "# Aim constrain it to the middle auto joint", 
                "auto_joint_swing = mc.duplicate(driver, n='{}_swing'.format(driver), po=True)[0]", 
                "vector = [1, 0, 0]", 
                "if '${side}' == 'r':", 
                "    vector = [-1, 0, 0]", 
                "mc.aimConstraint(STAGE.joint_list[1], auto_joint_swing,", 
                "                 weight=True, aimVector=vector,", 
                "                 worldUpType=\"none\", mo=True,", 
                "                 upVector=[0, 0, 0])", 
                "                 ", 
                "parent_control_par = mc.listRelatives('${parent_control}', p=True)[0]", 
                "# Go up one more to the nul, because the ort is getting inverted", 
                "parent_control_par = mc.listRelatives(parent_control_par, p=True)[0]", 
                "", 
                "# Pair blend - blends the auto rotation", 
                "pb = mc.createNode('pairBlend', n='${parent_control}_auto_pb')", 
                "mc.setAttr('{}.rotInterpolation'.format(pb), 1)", 
                "mc.connectAttr('{}.rotate'.format(auto_joint_swing), '{}.inRotate2'.format(pb))", 
                "", 
                "# Offset pair blend for keeping the auto parent from affect the bind pose", 
                "pb_offset = mc.createNode('pairBlend', n='${parent_control}_auto_offset_pb')", 
                "mc.setAttr('{}.rotInterpolation'.format(pb_offset), 1)", 
                "mc.connectAttr('{}.outRotateX'.format(pb_offset), '{}.rotateAxisX'.format(parent_control_par))", 
                "mc.connectAttr('{}.outRotateY'.format(pb_offset), '{}.rotateAxisY'.format(parent_control_par))", 
                "mc.connectAttr('{}.outRotateZ'.format(pb_offset), '{}.rotateAxisZ'.format(parent_control_par))", 
                "", 
                "# Connect rotation", 
                "mc.connectAttr('{}.outRotateX'.format(pb), '{}.rx'.format(parent_control_par))", 
                "mc.connectAttr('{}.outRotateY'.format(pb), '{}.ry'.format(parent_control_par))", 
                "mc.connectAttr('{}.outRotateZ'.format(pb), '{}.rz'.format(parent_control_par))", 
                "mc.setAttr('{}.rotateAxisX'.format(parent_control_par), k=True)", 
                "mc.setAttr('{}.rotateAxisY'.format(parent_control_par), k=True)", 
                "mc.setAttr('{}.rotateAxisZ'.format(parent_control_par), k=True)", 
                "", 
                "# Make a pose interpolator to control the strength of the auto behaviour in different poses", 
                "pose_interp = rig_psd.addInterp('${parent_control}_auto_poseInterpolator', driver=driver,createNeutralPose=False)", 
                "mc.setAttr('{}.interpolation'.format(pose_interp), 1)", 
                "mc.setAttr('{}.outputSmoothing'.format(pose_interp), 1)", 
                "mc.setAttr('{}.regularization'.format(pose_interp), 100)", 
                "", 
                "# Add upper fk as the pose control", 
                "pose_control = ${input_control_list}[0]", 
                "rig_psd.addPoseControl(pose_interp, '{}.rotate'.format(pose_control))", 
                "", 
                "# Create a mesh plane to hold the blendShape the poseInterpolators connect to", 
                "psd_numeric_geo = 'numericPSD_geo'", 
                "psd_numeric_bs = 'numeric_psd'", 
                "if not mc.objExists(psd_numeric_geo):", 
                "    psd_numeric_geo = mc.polyPlane(n=psd_numeric_geo, sx=1, sy=1, ch=0)[0]", 
                "    mc.hide(psd_numeric_geo)", 
                "if not mc.objExists(psd_numeric_bs):", 
                "    mc.blendShape(psd_numeric_geo, n=psd_numeric_bs)", 
                "", 
                "# Ensure the neutral pose comes first", 
                "neutral_pose = 'neutral'", 
                "rig_psd.addPose(pose_interp, neutral_pose)", 
                "", 
                "# poses", 
                "pose_dict = STAGE.pose_dict", 
                "", 
                "# Used to combine psd output into one numeric value", 
                "add = mc.createNode('plusMinusAverage', n='${parent_control}_poseInterp_add')", 
                "", 
                "for pose in pose_dict:", 
                "    pose_name = '${parent_control}_{}'.format(pose)", 
                "    if pose == 'neutral':", 
                "        pose_name = pose", 
                "    attr = pose_dict[pose]['attr']", 
                "    value = pose_dict[pose]['value']", 
                "    driven_key_value = pose_dict[pose]['auto']", 
                "    falloff = pose_dict[pose]['falloff']", 
                "", 
                "    # Add pose", 
                "    mc.setAttr('{}.{}'.format(pose_control, attr), *value)", 
                "    pose_name = rig_psd.addPose(pose_interp, pose_name)", 
                "    pose_index = rig_psd.getPoseIndex(pose_interp, pose_name)", 
                "    if pose != 'neutral':", 
                "        rig_psd.addShape(pose_interp, pose_name, psd_numeric_bs)", 
                "    mc.setAttr('{}.{}'.format(pose_control, attr), *(0, 0, 0))", 
                "", 
                "    # Create driven key", 
                "    driver = '{}.output[{}]'.format(pose_interp, pose_index)", 
                "    driven = '{}.input1D[{}]'.format(add, pose_index)", 
                "    mc.setDrivenKeyframe(driven, cd=driver, value=0, dv=0, itt=\"linear\", ott=\"linear\")", 
                "    mc.setDrivenKeyframe(driven, cd=driver, value=driven_key_value, dv=1, itt=\"linear\", ott=\"linear\")", 
                "    node = mc.listConnections(driven)[0]", 
                "    mc.rename(node, '{}_driven_key'.format(pose_name))", 
                "    ", 
                "    # Set psd falloff", 
                "    mc.setAttr('{}.pose[{}].poseFalloff'.format(pose_interp, pose_index), falloff)", 
                "", 
                "# Connect blend attr", 
                "mul_div = mc.createNode('multiplyDivide', n='{parent_control}_blend_mul')", 
                "mc.setDrivenKeyframe('{}.input1X'.format(mul_div), cd='${parent_control}.{}'.format(${auto_blend_attribute}), value=0, dv=0, itt=\"linear\", ott=\"linear\")", 
                "mc.setDrivenKeyframe('{}.input1X'.format(mul_div), cd='${parent_control}.{}'.format(${auto_blend_attribute}), value=${amount}, dv=1, itt=\"linear\", ott=\"linear\")", 
                "", 
                "mc.connectAttr('{}.output1D'.format(add), '{}.input2X'.format(mul_div))", 
                "mc.connectAttr('{}.outputX'.format(mul_div), '{}.weight'.format(pb))", 
                "", 
                "# Display attrs on poseControl also", 
                "mc.addAttr(pose_control, ln=${auto_blend_attribute}, proxy='${parent_control}.{}'.format(${auto_blend_attribute}))", 
                "", 
                "# Restore ik fk state of input ik", 
                "if mc.objExists(param):", 
                "    mc.setAttr('{}.ikfk'.format(param), param_orig_ikfk_state)", 
                "    ", 
                "mc.connectAttr('${parent_control}.{}'.format(${auto_blend_attribute}), '{}.weight'.format(pb_offset))", 
                "mc.setAttr('${parent_control}.{}'.format(${auto_blend_attribute}), 0)", 
                ""
            ]
        }, 
        "/auto_parent/psd/poses": {
            "code": [
                "from collections import OrderedDict", 
                "'''", 
                "Poses dictionary for the auto parent psd system.", 
                "", 
                "keys", 
                "--------------------------------------------------------------------------------", 
                "attr      - the attribute the pose values will be set on. ", 
                "value     - pose values ", 
                "auto      - the driven key value for the how much the auto parent is active", 
                "falloff   - the psd falloff for the pose (0-1)", 
                "", 
                "'''", 
                "pd = OrderedDict()", 
                "", 
                "pd['neutral'] =          {'attr': 'r', 'value': (0,    0,    0), 'auto': 0, 'falloff': .5}", 
                "# main", 
                "pd['up_90'] =            {'attr': 'r', 'value': (0,  -90,    0), 'auto': 2, 'falloff': .5}", 
                "pd['down_90'] =          {'attr': 'r', 'value': (0,   90,    0), 'auto': .1, 'falloff': .3}", 
                "pd['front_90'] =         {'attr': 'r', 'value': (0,    0,  -90), 'auto': 1, 'falloff': .5}", 
                "pd['back_90'] =          {'attr': 'r', 'value': (0,    0,   90), 'auto': 1, 'falloff': .5}", 
                "# extremes", 
                "pd['front_140'] =        {'attr': 'r', 'value': (0,    0, -140), 'auto': 2, 'falloff': .5}", 
                "pd['back_140'] =         {'attr': 'r', 'value': (0,    0,  140), 'auto': 2, 'falloff': .5}", 
                "pd['down_140'] =         {'attr': 'r', 'value': (0,   140,   0), 'auto': 0, 'falloff': .3}", 
                "# combos", 
                "pd['back_90__down_35'] = {'attr': 'r', 'value': (0,   35,   90), 'auto': 0, 'falloff': .5}", 
                "pd['front90__down_35'] = {'attr': 'r', 'value': (0,   35,  -90), 'auto': 0, 'falloff': .5}", 
                "", 
                "STAGE.pose_dict = pd"
            ]
        }, 
        "/auto_parent/psd/remove_extra_neutrals": {
            "code": [
                "pose_interp = rig_psd.getInterp('${parent_control}_auto_poseInterpolator')", 
                "", 
                "stupid_poses = ['neutralSwing', 'neutralTwist']", 
                "", 
                "for pose in stupid_poses:", 
                "    if rig_psd.getPoseIndex(pose_interp, pose):", 
                "        rig_psd.deletePose(pose_interp, pose)", 
                ""
            ]
        }, 
        "/blink": {
            "child_order": [
                "create", 
                "controls", 
                "blink_collision", 
                "scale_compensate", 
                "blink_rig_setup", 
                "eye_drag"
            ], 
            "enabled": true, 
            "comment": "This component is used to setup a blink rig. This mainly consist of the eye socket region and the lids.", 
            "attrs": {
                "SIDE": {
                    "comment": "Side attribute that is uppercase", 
                    "type": "raw", 
                    "value": "L"
                }, 
                "anchor": {
                    "comment": "The node that will be driving this whole system. ", 
                    "type": "str", 
                    "value": "'face_upper'"
                }, 
                "blink_lower_curve": {
                    "comment": "The curve used to create the lower blink deformeration", 
                    "type": "str", 
                    "value": "'blinkLower_${side}_curve'"
                }, 
                "blink_upper_curve": {
                    "comment": "The curve used to create the upper blink deformeration", 
                    "type": "str", 
                    "value": "'blinkUpper_${side}_curve'"
                }, 
                "component_parent": {
                    "comment": "Name of the node you want to parent this component under", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "control_group": {
                    "comment": "the node where we will be placing all of the controls", 
                    "type": "str", 
                    "value": "'${name}_controls'"
                }, 
                "eye_center_joint": {
                    "comment": "The center joint for the eye blink system", 
                    "type": "str", 
                    "value": "'eyeSocket_${side}_bind'"
                }, 
                "eye_geometry": {
                    "comment": "The geometry that is used for the eyeball. We will use this to put deformers on during the build.", 
                    "type": "str", 
                    "value": "'eye_${side}_geo'"
                }, 
                "geometry": {
                    "comment": "The geometry we will put the deformers on during the build.", 
                    "type": "str", 
                    "value": "'body_geo'"
                }, 
                "lash_lower_geometry": {
                    "type": "str", 
                    "value": "'lash_lower_${side}_proxy'"
                }, 
                "lash_upper_geometry": {
                    "type": "str", 
                    "value": "'lash_upper_${side}_proxy'"
                }, 
                "lid_curve": {
                    "comment": "This curve will be used for the secondary tweaker controls. It will create a wire deformer on the geomery.", 
                    "type": "str", 
                    "value": "'lid_${side}_curve'"
                }, 
                "lid_lower_control": {
                    "type": "str", 
                    "value": "'lidLower_${side}'"
                }, 
                "lid_upper_control": {
                    "type": "str", 
                    "value": "'lidUpper_${side}'"
                }, 
                "name": {
                    "comment": "The name of the component", 
                    "type": "raw", 
                    "value": "blink_${side}"
                }, 
                "side": {
                    "comment": "Side attribute that is lowercase", 
                    "type": "raw", 
                    "value": "l"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/blink/blink_collision": {
            "child_order": [
                "lid_squash"
            ], 
            "enabled": true, 
            "code": [
                "sum_plus_minus_average = mc.createNode('plusMinusAverage', name='${name}_sum_pma')", 
                "mc.connectAttr('{}.rx'.format(STAGE.upper_lid_control), '{}.input1D[0]'.format(sum_plus_minus_average), f=True)", 
                "mc.connectAttr('{}.rx'.format(STAGE.lower_lid_collision), '{}.input1D[1]'.format(sum_plus_minus_average), f=True)", 
                "", 
                "diff_plus_minus_average = mc.createNode('plusMinusAverage', name='${name}_diff_pma')", 
                "mc.setAttr('{}.input1D[0]'.format(diff_plus_minus_average), 40)", 
                "mc.connectAttr('{}.output1D'.format(sum_plus_minus_average), '{}.input1D[1]'.format(diff_plus_minus_average), f=True)", 
                "mc.setAttr('{}.operation'.format(diff_plus_minus_average), 2)", 
                "", 
                "scale_mult_double_linear = mc.createNode('multDoubleLinear', name='${name}_scale_mdl')", 
                "mc.connectAttr('{}.output1D'.format(diff_plus_minus_average), '{}.input1'.format(scale_mult_double_linear), f=True)", 
                "mc.setAttr('{}.input2'.format(scale_mult_double_linear), -.010)", 
                "", 
                "scale_plus_minus_average = mc.createNode('plusMinusAverage', name='${name}_scale_pma')", 
                "mc.connectAttr('{}.output'.format(scale_mult_double_linear), '{}.input1D[1]'.format(scale_plus_minus_average), f=True)", 
                "mc.setAttr('{}.input1D[0]'.format(scale_plus_minus_average), 1)", 
                "", 
                "lowerLidsum_plus_minus_average = mc.createNode('plusMinusAverage', name='${name}_lower_sum_pma')", 
                "mc.connectAttr('{}.rx'.format(STAGE.lower_lid_collision), '{}.input1D[0]'.format(lowerLidsum_plus_minus_average), f=True)", 
                "mc.connectAttr('{}.output1D'.format(diff_plus_minus_average), '{}.input1D[1]'.format(lowerLidsum_plus_minus_average), f=True)", 
                "", 
                "collision_condition = mc.createNode('condition', name='${name}_collision_cnd')", 
                "mc.setAttr('{}.operation'.format(collision_condition), 4)", 
                "mc.connectAttr('{}.output1D'.format(diff_plus_minus_average), '{}.firstTerm'.format(collision_condition), f=True)", 
                "mc.connectAttr('{}.rx'.format(STAGE.lower_lid_collision), '{}.colorIfFalseR'.format(collision_condition), f=True)", 
                "mc.connectAttr('{}.output1D'.format(lowerLidsum_plus_minus_average), '{}.colorIfTrueR'.format(collision_condition), f=True)", 
                "", 
                "scale_condition = mc.createNode('condition', name='${name}_scale_cnd')", 
                "mc.setAttr('{}.operation'.format(scale_condition), 0)", 
                "mc.connectAttr('{}.outColorR'.format(collision_condition), '{}.firstTerm'.format(scale_condition), f=True)", 
                "mc.connectAttr('{}.output1D'.format(scale_plus_minus_average), '{}.colorIfTrueR'.format(scale_condition), f=True)", 
                "mc.connectAttr('{}.output1D'.format(lowerLidsum_plus_minus_average), '{}.secondTerm'.format(scale_condition), f=True)", 
                "", 
                "mc.connectAttr('{}.outColorR'.format(collision_condition), '{}.rx'.format(STAGE.lower_lid_driver), f=True)", 
                "", 
                "# put variables on the stage that are needed.", 
                "STAGE.scale_condition = scale_condition"
            ]
        }, 
        "/blink/blink_collision/lid_squash": {
            "instance": "/cluster_control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "raw", 
                    "value": "${eye_center_joint}"
                }, 
                "control_name": {
                    "type": "str", 
                    "value": "'lid_squash_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "display_handle": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'eyeSocket_${side}'"
                }, 
                "tag_as_control": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/blink/blink_collision/lid_squash/connect": {
            "enabled": true, 
            "comment": "This node will make the connections to the scale of the cluster for when the lids collide.", 
            "code": [
                "dial_attr = 'auto_squash'", 
                "offset_attr = 'squash'", 
                "mc.addAttr(${lid_upper_control}, ln=dial_attr, at='double', dv=0, min=0, max=1, k=1)", 
                "mc.addAttr(${lid_upper_control}, ln=offset_attr, at='double', dv=0, k=1)", 
                "", 
                "# Dial multiplier", 
                "mul = mc.createNode('multiplyDivide', n='{}_squash_mul'.format(${control_name}))", 
                "add = mc.createNode('plusMinusAverage', n='{}_squash_add'.format(${control_name}))", 
                "sub = mc.createNode('plusMinusAverage', n='{}_squash_sub'.format(${control_name}))", 
                "mul_offset = mc.createNode('multiplyDivide', n='{}_squash_offset_mul'.format(${control_name}))", 
                "", 
                "mc.setAttr('{}.input2X'.format(mul_offset), .1)", 
                "mc.connectAttr('{}.{}'.format(${lid_upper_control}, offset_attr), '{}.input1X'.format(mul_offset), f=True)", 
                "", 
                "", 
                "mc.connectAttr('blink_${side}_scale_cnd.outColorR', '{}.input1D[0]'.format(sub))", 
                "mc.setAttr('{}.input1D[1]'.format(sub), -1)", 
                "", 
                "mc.connectAttr('{}.output1D'.format(sub), '{}.input2X'.format(mul))", 
                "mc.connectAttr('{}.{}'.format(${lid_upper_control}, dial_attr), '{}.input1X'.format(mul))", 
                "", 
                "# connnect the scale tot the cluster", 
                "mc.connectAttr('{}.outputX'.format(mul), '{}.input1D[0]'.format(add), f=True)", 
                "mc.connectAttr('{}.outputX'.format(mul_offset), '{}.input1D[1]'.format(add), f=True)", 
                "mc.setAttr('{}.input1D[2]'.format(add), 1)", 
                "", 
                "mc.connectAttr('{}.output1D'.format(add), '{}.sx'.format(${control_name}), f=True)", 
                "mc.connectAttr('{}.output1D'.format(add), '{}.sy'.format(${control_name}), f=True)", 
                "mc.connectAttr('{}.output1D'.format(add), '{}.sz'.format(${control_name}), f=True)", 
                "", 
                ""
            ]
        }, 
        "/blink/blink_collision/lid_squash/create": {
            "enabled": true, 
            "attrs": {
                "geometry": {
                    "type": "raw", 
                    "value": "mc.ls('body_geo', ${lash_lower_geometry}, ${lash_upper_geometry})"
                }
            }
        }, 
        "/blink/blink_rig_setup": {
            "child_order": [
                "upper", 
                "lower", 
                "lid_wire", 
                "socket"
            ], 
            "enabled": true, 
            "code": [
                ""
            ]
        }, 
        "/blink/blink_rig_setup/lid_wire": {
            "child_order": [
                "rename_controls"
            ], 
            "enabled": true, 
            "attrs": {
                "geometry": {
                    "value": "mc.ls(${lash_upper_geometry}, ${lash_lower_geometry}, 'body_geo')"
                }
            }, 
            "code": [
                "# create the lid tweaker rig", 
                "bindmesh_geometry, follicle_list, control_hierarchy_list, joint_list, base_curve_joint_list = rig_wire.buildCurveRig(${lid_curve}, ", 
                "                                                                                              \"lid_${side}\", ", 
                "                                                                                              control_type=${type},", 
                "                                                                                              parent=${component_parent}, ", 
                "                                                                                              control_shape='null')", 
                "", 
                "# #deform the lid bindmesh with the lid curve using a wire deformer.", 
                "wire_deformer = mc.wire(${geometry}, gw=False, en=1.00, ce=0.00, li=0.00, ", 
                "        w=${lid_curve}, name=\"{}_wire\".format(${lid_curve}))[0]", 
                "        ", 
                "# #deform the lid bindmesh with the lid curve using a wire deformer.", 
                "mc.wire(\"{}_wire\".format(${blink_upper_curve}), e=True, geometry=bindmesh_geometry)", 
                "", 
                "# #deform the lid bindmesh with the lid curve using a wire deformer.", 
                "mc.wire(\"{}_wire\".format(${blink_lower_curve}), e=True, geometry=bindmesh_geometry)", 
                "        ", 
                "# set the default values for the wire deformer", 
                "mc.setAttr(\"{}.rotation\".format(wire_deformer), 0)", 
                "mc.setAttr(\"{}.dropoffDistance[0]\".format(wire_deformer), 100)", 
                "mc.parent(${lid_curve}, \"lid_${side}_grp\")", 
                "", 
                "# making sure the base_curve_joint is parented properly", 
                "for joint, control_list in zip(base_curve_joint_list, control_hierarchy_list):", 
                "    # hide the base curve joint. Then parent it under the null node", 
                "    mc.setAttr(\"{}.v\".format(joint), 0)", 
                "    mc.parent(joint, control_list[1])", 
                "    mc.setAttr(\"{}.t\".format(joint), 0, 0, 0)", 
                "", 
                "    if '_r_' in control_list[0]:", 
                "        mc.setAttr(control_list[0]+'.ry', -180)", 
                "        mc.setAttr(control_list[0]+'.sz', -1)", 
                "", 
                "# skin the base curve and make sure it's parented properly", 
                "base_curve = \"{}BaseWire\".format(${lid_curve})", 
                "mc.parent(base_curve, \"lid_${side}_grp\")", 
                "base_curve_skin = mc.skinCluster(*base_curve_joint_list+mc.ls(base_curve), ", 
                "                            n=\"{}_skinCluster\".format(base_curve),", 
                "                            tsb=True)[0]", 
                "", 
                "# set the weights to have proper weighting", 
                "weight_object = rig_weights.getWeights(base_curve_skin)", 
                "weight_list = list()", 
                "for i, inf in enumerate(weight_object):", 
                "    array = numpy.zeros_like(weight_object.getWeights(inf))[0]", 
                "    array[i] = 1", 
                "    weight_list.append(array)", 
                "weight_object.setWeights(weight_list)", 
                "rig_weights.setWeights(base_curve_skin, weight_object)", 
                "", 
                "# # Put the the variables on the stage.", 
                "STAGE.lid_curve_bindmesh_geometry = bindmesh_geometry", 
                "STAGE.lid_curve_control_hierarchy_list = control_hierarchy_list", 
                "STAGE.lid_curve_joint_list = joint_list", 
                "STAGE.lid_curve_base_joint_list = base_curve_joint_list"
            ]
        }, 
        "/blink/blink_rig_setup/lid_wire/rename_controls": {
            "code": [
                "# get the list of cv's on the curve", 
                "cv_list = mc.ls('{}.cv[*]'.format(${lid_curve}), fl=True)", 
                "cv_index_list = [i for i in xrange(len(cv_list))]", 
                "# use this index to figure out the names of the corners and the upper and lower controls", 
                "cv_center_upper_index = 1", 
                "cv_inner_corner_index = int(len(cv_list) * .25 + cv_center_upper_index)", 
                "cv_outer_corner_index = int(len(cv_list) * .75 + cv_center_upper_index)", 
                "", 
                "# make sure to append the difference at the end.", 
                "cv_lower_index_list = cv_index_list[cv_inner_corner_index+1:cv_outer_corner_index]", 
                "cv_upper_inner_index_list = cv_index_list[cv_center_upper_index+1:cv_inner_corner_index]", 
                "cv_upper_inner_index_list.reverse()", 
                "cv_upper_index_list =  cv_upper_inner_index_list + [cv_center_upper_index] + cv_index_list[:cv_center_upper_index] + cv_index_list[cv_outer_corner_index+1:]", 
                "", 
                "# lower controls ", 
                "i = 0", 
                "for index in cv_lower_index_list:", 
                "    control_hierarchy = STAGE.lid_curve_control_hierarchy_list[index]", 
                "    new_control_name = 'lid_low_{}_${side}'.format(i)", 
                "    old_control_name = control_hierarchy[-1]", 
                "    for node in control_hierarchy:", 
                "        control_hierarchy[control_hierarchy.index(node)] = mc.rename(node, node.replace(old_control_name, new_control_name))", 
                "    i += 1", 
                "", 
                "# upper controls", 
                "i = 0", 
                "for index in cv_upper_index_list:", 
                "    control_hierarchy = STAGE.lid_curve_control_hierarchy_list[index]", 
                "    new_control_name = 'lid_up_{}_${side}'.format(i)", 
                "    old_control_name = control_hierarchy[-1]", 
                "    for node in control_hierarchy:", 
                "        control_hierarchy[control_hierarchy.index(node)] = mc.rename(node, node.replace(old_control_name, new_control_name))", 
                "    i += 1", 
                "", 
                "# outer corner name", 
                "control_hierarchy = STAGE.lid_curve_control_hierarchy_list[cv_outer_corner_index]", 
                "new_control_name = 'lid_corner_outer_${side}'", 
                "old_control_name = control_hierarchy[-1]", 
                "for node in control_hierarchy:", 
                "    control_hierarchy[control_hierarchy.index(node)] = mc.rename(node, node.replace(old_control_name, new_control_name))", 
                "", 
                "# inner corner name", 
                "control_hierarchy = STAGE.lid_curve_control_hierarchy_list[cv_inner_corner_index]", 
                "new_control_name = 'lid_corner_inner_${side}'", 
                "old_control_name = control_hierarchy[-1]", 
                "for node in control_hierarchy:", 
                "    control_hierarchy[control_hierarchy.index(node)] = mc.rename(node, node.replace(old_control_name, new_control_name))"
            ]
        }, 
        "/blink/blink_rig_setup/lower": {
            "instance": "../upper", 
            "child_order": [
                "curve_rig", 
                "cluster_rig"
            ], 
            "enabled": true, 
            "attrs": {
                "curve": {
                    "type": "raw", 
                    "value": "${blink_lower_curve}"
                }, 
                "geometry": {
                    "value": "mc.ls(${lash_lower_geometry}, 'body_geo')"
                }, 
                "section": {
                    "type": "raw", 
                    "value": "Lower"
                }
            }
        }, 
        "/blink/blink_rig_setup/socket": {
            "enabled": true, 
            "code": [
                "# create the socket lift cluster", 
                "upper_lid_control = 'lidUpper_${side}'", 
                "# skin the base curve and make sure it's parented properly", 
                "base_curve = \"{}BaseWire\".format(${lid_curve})", 
                "socket_lift_cluster = rig_cluster.create(${geometry},", 
                "                                                \"socketLift_${side}_cluster\",", 
                "                                                parent=${anchor},", 
                "                                                parallel=False)", 
                "", 
                "# create the socket lift cluster", 
                "socket_stretch_cluster = rig_cluster.create(mc.ls([${geometry}, ${lash_upper_geometry}] + rig_common.toList(${eye_geometry})),", 
                "                                                   \"socketStretch_${side}_cluster\",", 
                "                                                   parent=${anchor},", 
                "                                                   parallel=False)", 
                "", 
                "# move the cluster into the correct location", 
                "mc.xform(\"{}_nul\".format(socket_lift_cluster), ws=True,", 
                "         matrix=mc.xform(upper_lid_control, q=True, ws=True, matrix=True))", 
                "mc.xform(\"{}_nul\".format(socket_stretch_cluster), ws=True,", 
                "         matrix=mc.xform(upper_lid_control, q=True, ws=True, matrix=True))", 
                "", 
                "# turn off visibility of the handle and create the socket lift attribute on the upperLid", 
                "mc.setAttr(\"{}_ctrl.displayHandle\".format(socket_lift_cluster), 0)", 
                "mc.setAttr(\"{}_ctrl.displayHandle\".format(socket_stretch_cluster), 0)", 
                "mc.addAttr(upper_lid_control, ln=\"socketLift\", at=\"double\", min=-10, max=10, dv=0, keyable=True)", 
                "", 
                "socketClusterList = rig_cluster.transferCluster(${geometry}, STAGE.lid_curve_bindmesh_geometry, socket_stretch_cluster,", 
                "                                                         handle=True)", 
                "# socketClusterList.extend(rig_cluster.transferCluster(${geometry}, base_curve, socket_lift_cluster, handle=True))", 
                "", 
                "# this will localize the blink agains the model group and auto node", 
                "for cluster in socketClusterList:", 
                "    clusterName = cluster.split(\"__\")[-1]", 
                "    rig_cluster.localize(cluster, \"{}_auto\".format(clusterName), \"model\")", 
                "", 
                "# loop through and create the setDriven keyframe for the socketLift", 
                "for driver_value, value in zip((0, 10, -10), (1, 10, -10)):", 
                "    mc.setDrivenKeyframe(\"{0}_def_auto.scaleY\".format(socket_lift_cluster),", 
                "                         currentDriver=\"{}.socketLift\".format(upper_lid_control),", 
                "                         dv=driver_value,", 
                "                         itt=\"linear\",", 
                "                         ott=\"linear\",", 
                "                         value=value)", 
                "", 
                "# handle the automation of the scaling through the rotation of the upperLid driver", 
                "for driver_value, value in zip((0, -20), (1, 10)):", 
                "    mc.setDrivenKeyframe(\"{0}_def_auto.scaleY\".format(socket_stretch_cluster),", 
                "                         currentDriver=\"{}.rotateX\".format(upper_lid_control),", 
                "                         dv=driver_value,", 
                "                         itt=\"linear\",", 
                "                         ott=\"linear\",", 
                "                         value=value)", 
                "", 
                "# connect the scale of the uppper lid control to the socket stretch cluster", 
                "mc.connectAttr(\"{}.scaleY\".format(upper_lid_control), \"{}_ctrl.scaleY\".format(socket_stretch_cluster), f=True)", 
                "# connect the position and rotation of socket_stretch_cluster to socket_lift_cluster", 
                "mc.connectAttr(\"{}_ort.rotate\".format(socket_stretch_cluster), \"{}_ort.rotate\".format(socket_lift_cluster), f=True)", 
                "mc.connectAttr(\"{}_ort.translate\".format(socket_stretch_cluster), \"{}_ort.translate\".format(socket_lift_cluster),", 
                "               f=True)"
            ]
        }, 
        "/blink/blink_rig_setup/upper": {
            "child_order": [
                "curve_rig", 
                "cluster_rig"
            ], 
            "enabled": true, 
            "attrs": {
                "cluster_geometry": {
                    "type": "raw", 
                    "value": "${geometry}"
                }, 
                "curve": {
                    "type": "raw", 
                    "value": "${blink_upper_curve}"
                }, 
                "geometry": {
                    "value": "mc.ls(${lash_upper_geometry}, 'body_geo')"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'${name}'"
                }, 
                "section": {
                    "type": "raw", 
                    "value": "Upper"
                }
            }
        }, 
        "/blink/blink_rig_setup/upper/cluster_rig": {
            "enabled": true, 
            "code": [
                "group = \"lid${section}_${side}_grp\"", 
                "# create the cluster at the and position it at the same position as eyeCenter", 
                "lid_cluster = rig_cluster.create(${cluster_geometry}, ", 
                "                            \"blink${section}_${side}_cluster\",", 
                "                            parent='${name}', ", 
                "                            parallel=False)", 
                "", 
                "# move the lid cluster to match the eye center joint", 
                "mc.xform(\"{}_nul\".format(lid_cluster), ws=True, matrix=mc.xform(${eye_center_joint}, q=True, ws=True, matrix=True))", 
                "", 
                "# create the setDriven's for the cluster to follow the blink", 
                "values = zip((0, 20, 40, -20),(0, 35, 65, -15))", 
                "if '${section}' == \"Lower\":", 
                "    values = zip((0, 20, 40, -20),(0, -35, -65, 15))", 
                "    ", 
                "for driverValue, value in values:", 
                "    current_driver = \"lid${section}_${side}_driver.rotateX\"", 
                "    mc.setDrivenKeyframe(\"{}_def_auto.rotateX\".format(lid_cluster),", 
                "                            currentDriver=current_driver,", 
                "                            dv=driverValue,", 
                "                            itt=\"linear\",", 
                "                            ott= \"linear\", ", 
                "                            value=value)", 
                "", 
                "    # Set driven key post and pre infinity extrapolation", 
                "    dkey = mc.listConnections(current_driver, scn=1, type='animCurveUA')[-1]", 
                "    mc.setAttr(dkey + '.preInfinity', 1)", 
                "    mc.setAttr(dkey + '.postInfinity', 1)", 
                "    mc.keyTangent(dkey, index=(0, 0), inTangentType='spline')", 
                "    mc.keyTangent(dkey, index=(0, 0), outTangentType='spline')", 
                "    mc.keyTangent(dkey, index=(3, 3), inTangentType='spline')", 
                "    mc.keyTangent(dkey, index=(3, 3), outTangentType='spline')", 
                "", 
                "# create the driver joint.", 
                "mc.select(\"{}_ort\".format(lid_cluster))", 
                "driver_joint = mc.joint(name=\"blink${section}_${side}_driver\")", 
                "mc.setAttr(\"{}.drawStyle\".format(driver_joint), 2)", 
                "mc.setAttr(\"{}.rotate\".format(driver_joint), 0, 0, 0)", 
                "mc.setAttr(\"{}.translate\".format(driver_joint), 0, 0, 0)", 
                "# constrain the driver to the ctrl of the cluster nodes", 
                "mc.orientConstraint(\"{0}_ctrl\".format(lid_cluster), driver_joint)", 
                "", 
                "mc.cluster(STAGE.bindmesh_geometry, name='{}__{}'.format(STAGE.bindmesh_geometry,lid_cluster), wn=[\"{}_cls_hdl\".format(lid_cluster),\"{}_cls_hdl\".format(lid_cluster)], bs=1)", 
                "rig_cluster.localize('{}__{}'.format(STAGE.bindmesh_geometry,lid_cluster), \"{}_auto\".format(lid_cluster), STAGE.bindmesh_geometry)", 
                "#mc.cluster(base_curve, name='{}__{}'.format(base_curve,lid_cluster), wn=[\"{}_cls_hdl\".format(lid_cluster),\"{}_cls_hdl\".format(lid_cluster)], bs=1)", 
                "#rig_cluster.localize('{}__{}'.format(base_curve,lid_cluster), \"{}_auto\".format(lid_cluster), base_curve) "
            ]
        }, 
        "/blink/blink_rig_setup/upper/curve_rig": {
            "enabled": true, 
            "code": [
                "# If the name passed in doesn't exist, we will create a transform as the parent group", 
                "# for the rig.", 
                "grp=\"${name}_grp\"", 
                "if not mc.objExists(grp):", 
                "    mc.createNode(\"transform\", n=grp)", 
                "# create the bindmesh ", 
                "#", 
                "# follicle_list = (follicle transform, follicle shape) ", 
                "# STAGE.bindmesh_geometry = geometry name of bindmesh", 
                "#", 
                "STAGE.bindmesh_geometry, follicle_list = rig_bindmesh.createFromCurve('blink${section}_${side}', ${curve})", 
                "# emptry list to append controls to in the loop", 
                "control_hierarchy_list = list()", 
                "joint_list = list()", 
                "", 
                "# loop through and create controls on the follicles so we have controls to deform the wire.", 
                "for follicle in follicle_list:", 
                "    # get the follicle transform so we can use it to parent the control to it.", 
                "    follicle_index = follicle_list.index(follicle)", 
                "    mc.select(follicle, r=True)", 
                "", 
                "    # create the joint that will drive the curve.", 
                "    jnt = mc.joint(n=\"${name}_{}_jnt\".format(follicle_index))", 
                "    mc.setAttr(\"{}.translate\".format(jnt), 0,0,0)", 
                "    mc.setAttr(\"{}.rotate\".format(jnt), 0,0,0)", 
                "    mc.setAttr(\"{}.drawStyle\".format(jnt),2)", 
                "    joint_list.append(jnt)", 
                "", 
                "# This will parent all of the data for the rig to the system group \"name\"", 
                "for data in (STAGE.bindmesh_geometry, follicle_list):", 
                "    mc.parent(data, grp)", 
                "", 
                "# If parent the parent is passed in we will parent the system to the parent.", 
                "if ${parent}:", 
                "    if not mc.objExists(${parent}):", 
                "        mc.warning('Created the system but the current parent \"{}\" does not exist in the \\", 
                "            current Maya session.'.format(${parent}))", 
                "    else:", 
                "        try:", 
                "            mc.parent(grp, ${parent})", 
                "        except:", 
                "            print \"{} is already parented under {}\".format(grp,${parent})", 
                "", 
                "# set the visibility of the bindmesh.", 
                "mc.setAttr(\"{}.v\".format(STAGE.bindmesh_geometry), 0 )", 
                "mc.setAttr(\"{}.v\".format(${curve}), 0 )", 
                "", 
                "#deform the lid bindmesh with the lid curve using a wire deformer.", 
                "wire_deformer = mc.wire(${geometry}, gw=False, en=1.00, ce=0.00, li=0.00, ", 
                "        w=${curve}, name=\"{}_wire\".format(${curve}))[0]", 
                "", 
                "# set the default values for the wire deformer", 
                "mc.setAttr(\"{}.rotation\".format(wire_deformer), 0)", 
                "mc.setAttr(\"{}.dropoffDistance[0]\".format(wire_deformer), 100)", 
                "", 
                "# create skinCluster for the base wire", 
                "base_curve = \"{}BaseWire\".format(${curve})", 
                "", 
                "# create the skinCluster for the ${curve}", 
                "mc.skinCluster(*joint_list + [${curve}], tsb=True, name=\"{}_skinCluster\".format(${curve}))", 
                "mc.skinCluster(*joint_list + [base_curve], tsb=True, name=\"{}_skinCluster\".format(base_curve))", 
                ""
            ]
        }, 
        "/blink/controls": {
            "child_order": [
                "eye_socket", 
                "lower_lid", 
                "upper_lid"
            ], 
            "enabled": true, 
            "attrs": {
                "hide_attrs": {
                    "type": "list", 
                    "value": "['s', 'sx', 'sy', 'sz', 't', 'tx', 'ty', 'tz', 'ry', 'rz', 'v']"
                }
            }
        }, 
        "/blink/controls/eye_socket": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": false, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${eye_center_joint}"
                }, 
                "control_name": {
                    "type": "str", 
                    "value": "'eyeSocket_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${anchor}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/blink/controls/eye_socket/connect": {
            "comment": "This will connect the eye socket joint to the eye sokcket control\n", 
            "code": [
                "#point, orient constraint the socket joint to the socket control. Also connect scale", 
                "mc.parentConstraint(${control_name}, ${eye_center_joint})", 
                "mc.scaleConstraint(${control_name}, ${eye_center_joint})"
            ]
        }, 
        "/blink/controls/lower_lid": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "driver", 
                "selection_handle"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${eye_center_joint}"
                }, 
                "collision_driver_name": {
                    "type": "str", 
                    "value": "'lidLower_${side}_collision_driver'"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${lid_lower_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "driver_name": {
                    "type": "str", 
                    "value": "'lidLower_${side}_driver'"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'def_auto']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'eyeSocket_${side}'"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/blink/controls/lower_lid/driver": {
            "enabled": true, 
            "comment": "Create the driver setup for the lower lid", 
            "code": [
                "# create driver for the the lids.", 
                "lid_nul = '{}_{}'.format(${control_name}, ${hierarchy}[0])", 
                "lid_driver = mc.createNode(\"joint\", name=${driver_name})", 
                "lid_collision = mc.createNode(\"joint\", name=${collision_driver_name})", 
                "mc.hide([lid_driver, lid_collision])", 
                "mc.xform(lid_collision, ws=True, matrix=mc.xform(${control_name}, q=True, ws=True, matrix=True))", 
                "mc.parent(lid_driver, lid_nul)", 
                "mc.parent(lid_collision, lid_nul)", 
                "mc.pointConstraint(${control_name}, lid_collision)", 
                "mc.orientConstraint(${control_name}, lid_collision)", 
                "mc.pointConstraint(lid_collision, lid_driver)", 
                "mc.orientConstraint(lid_collision, lid_driver, skip='x')", 
                "# set the display type to be off", 
                "mc.setAttr(\"{}.drawStyle\".format(lid_driver), 2)", 
                "", 
                "# rotate the lower lid so it's inverted to match the rotation on x for the upper lid.", 
                "mc.setAttr(\"{0}.rotateZ\".format(lid_nul), 180)", 
                "", 
                "# put variables on the STAGE", 
                "STAGE.lower_lid_driver = lid_driver", 
                "STAGE.lower_lid_collision = lid_collision", 
                "STAGE.lower_lid_control = ${control_name}"
            ]
        }, 
        "/blink/controls/lower_lid/selection_handle": {
            "enabled": true, 
            "code": [
                "# connect the rotate X axis of the lid controls to the rotateAxis X", 
                "# create a multDoubleLinear node", 
                "# set the handle positions by default", 
                "mc.setAttr(\"{}.selectHandleY\".format(${control_name}), .2)", 
                "mdl = mc.createNode(\"multDoubleLinear\", n=\"{}_rot_mdl\".format(${control_name}))", 
                "mc.connectAttr(\"{}.rx\".format(${control_name}), \"{}.input1\".format(mdl), f=True)", 
                "mc.setAttr(\"{}.input2\".format(mdl), -1)", 
                "mc.connectAttr(\"{}.output\".format(mdl), \"{}.rotateAxisX\".format(${control_name}), f=True)"
            ]
        }, 
        "/blink/controls/upper_lid": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "driver", 
                "selection_handle"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${eye_center_joint}"
                }, 
                "collision_driver_name": {
                    "type": "str", 
                    "value": "'lidUpper_${side}_collision_driver'"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${lid_upper_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "driver_name": {
                    "type": "str", 
                    "value": "'lidUpper_${side}_driver'"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'def_auto']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'eyeSocket_${side}'"
                }
            }
        }, 
        "/blink/controls/upper_lid/driver": {
            "enabled": true, 
            "comment": "Create the driver setup for the upper lid", 
            "code": [
                "# create drivers for the the lids.", 
                "lid_nul = '{}_{}'.format(${control_name}, ${hierarchy}[0])", 
                "lid_driver = mc.createNode(\"joint\", name=${driver_name})", 
                "mc.parent(lid_driver, lid_nul)", 
                "mc.pointConstraint(${control_name}, lid_driver)", 
                "mc.orientConstraint(${control_name}, lid_driver)", 
                "mc.setAttr(\"{}.drawStyle\".format(lid_driver), 2)", 
                "", 
                "# put variables on the stage", 
                "STAGE.upper_lid_driver = lid_driver", 
                "STAGE.upper_lid_control = ${control_name}"
            ]
        }, 
        "/blink/controls/upper_lid/selection_handle": {
            "instance": "../..//lower_lid/selection_handle", 
            "enabled": true
        }, 
        "/blink/create": {
            "enabled": true, 
            "comment": "This node is kind of a setup for the component. Make sure that certain nodes have been created that are needed. also, any global variables that might need to be put on the STAGE will happen here.", 
            "code": [
                "# get the group, rename it, then reset it to the instance.", 
                "for node in [${control_group}, '${name}']:", 
                "    if not mc.objExists(node):", 
                "        mc.createNode(\"transform\", name=node)", 
                "", 
                "    # parent the system to the component group if it exists", 
                "    if mc.objExists(${component_parent}):", 
                "        mc.parent(node, ${component_parent})", 
                "    ", 
                "# make sure the blink curve group is parented properly", 
                "for node in (${blink_lower_curve},${blink_upper_curve}):", 
                "    parent = mc.listRelatives(node, p=True)[0]", 
                "    if not mc.listRelatives(parent, p=True):", 
                "        mc.parent(parent, '${name}')"
            ]
        }, 
        "/blink/eye_drag": {
            "child_order": [
                "eye_drag_upper", 
                "eye_drag_lower"
            ]
        }, 
        "/blink/eye_drag/eye_drag_lower": {
            "instance": "../eye_drag_upper", 
            "attrs": {
                "blink_curve": {
                    "value": "${blink_lower_curve}"
                }, 
                "cluster_name": {
                    "value": "eyeDrag_lower_${side}_cluster"
                }
            }
        }, 
        "/blink/eye_drag/eye_drag_upper": {
            "enabled": true, 
            "attrs": {
                "blink_curve": {
                    "type": "raw", 
                    "value": "${blink_upper_curve}"
                }, 
                "cluster_name": {
                    "type": "raw", 
                    "value": "eyeDrag_upper_${side}_cluster"
                }
            }, 
            "code": [
                "cluster = rig_cluster.create(${blink_curve}, \"${cluster_name}\",parent='${name}', parallel=False)", 
                "mc.xform(\"${cluster_name}_nul\", ws=True, matrix=mc.xform('eye_${side}',q=True,ws=True, matrix=True))", 
                "", 
                "current_driver = \"eye_${side}_bind.rotateY\"", 
                "mc.setDrivenKeyframe(\"${cluster_name}_def_auto.rotateY\", ", 
                "                        currentDriver=current_driver,", 
                "                        dv=60,", 
                "                        itt=\"linear\",", 
                "                        ott= \"linear\", ", 
                "                        value=30)", 
                "mc.setDrivenKeyframe(\"${cluster_name}_def_auto.rotateY\", ", 
                "                        currentDriver=current_driver,", 
                "                        dv=-60,", 
                "                        itt=\"linear\",", 
                "                        ott= \"linear\", ", 
                "                        value=-30)", 
                "", 
                "# Set driven key post and pre infinity extrapolation", 
                "dkey = mc.listConnections(current_driver, scn=1, type='animCurveUA')[-1]", 
                "mc.setAttr(dkey + '.preInfinity', 1)", 
                "mc.setAttr(dkey + '.postInfinity', 1)", 
                "mc.keyTangent(dkey, index=(0, 0), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(0, 0), outTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), outTangentType='spline')", 
                "", 
                "# Set driven key post and pre infinity extrapolation", 
                "dkey = mc.listConnections(current_driver, scn=1, type ='animCurveUA')[-1]", 
                "mc.setAttr(dkey + '.preInfinity', 1)", 
                "mc.setAttr(dkey + '.postInfinity', 1)", 
                "mc.keyTangent(dkey, index=(0, 0), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(0, 0), outTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), outTangentType='spline')", 
                "", 
                "", 
                "current_driver = \"eye_${side}_bind.rotateX\"", 
                "mc.setDrivenKeyframe(\"${cluster_name}_def_auto.rotateX\", ", 
                "                        currentDriver=current_driver,", 
                "                        dv=60,", 
                "                        itt=\"linear\",", 
                "                        ott= \"linear\", ", 
                "                        value=30)", 
                "mc.setDrivenKeyframe(\"${cluster_name}_def_auto.rotateX\", ", 
                "                        currentDriver=current_driver,", 
                "                        dv=-60,", 
                "                        itt=\"linear\",", 
                "                        ott= \"linear\", ", 
                "                        value=-30)", 
                "", 
                "# Set driven key post and pre infinity extrapolation", 
                "dkey = mc.listConnections(current_driver, scn=1, type='animCurveUA')[-1]", 
                "mc.setAttr(dkey + '.preInfinity', 1)", 
                "mc.setAttr(dkey + '.postInfinity', 1)", 
                "mc.keyTangent(dkey, index=(0, 0), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(0, 0), outTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), outTangentType='spline')", 
                "", 
                "# Set driven key post and pre infinity extrapolation", 
                "dkey = mc.listConnections(current_driver, scn=1, type='animCurveUA')[-1]", 
                "mc.setAttr(dkey + '.preInfinity', 1)", 
                "mc.setAttr(dkey + '.postInfinity', 1)", 
                "mc.keyTangent(dkey, index=(0, 0), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(0, 0), outTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), inTangentType='spline')", 
                "mc.keyTangent(dkey, index=(3, 3), outTangentType='spline')"
            ]
        }, 
        "/blink/scale_compensate": {
            "enabled": true, 
            "comment": "This will get all of the joints that are children of the eye center joint and turn the scale compensate off.", 
            "code": [
                "# Get all of the children that are joints so we can set the scale ", 
                "# compensate to be turned off.", 
                "children = mc.listRelatives(${eye_center_joint}, c=True, type=\"joint\") or list()", 
                "", 
                "for jnt in children:", 
                "    mc.setAttr(\"{}.segmentScaleCompensate\".format(jnt), 0)"
            ]
        }, 
        "/brow": {
            "child_order": [
                "create", 
                "brow_main", 
                "brow_inner", 
                "brow_peak", 
                "corrugator", 
                "curve_rig"
            ], 
            "enabled": true, 
            "comment": "This component is used to setup one brow system. This will come with drivers for PSD\"s and a wire deformer used as a secondary control system on top of the joints and PSD's.", 
            "attrs": {
                "SIDE": {
                    "comment": "Side attribute uppercare", 
                    "type": "raw", 
                    "value": "L"
                }, 
                "anchor": {
                    "comment": "anchor that will drive the brow", 
                    "type": "str", 
                    "value": "'head_tip'"
                }, 
                "brow_curve": {
                    "comment": "curve the will be used for a wire deformer tweak on the brow", 
                    "type": "str", 
                    "value": "'brow_${side}_curve'"
                }, 
                "brow_inner": {
                    "comment": "Name for the brow inner control", 
                    "type": "str", 
                    "value": "'brow_inner_${side}'"
                }, 
                "brow_inner_joint": {
                    "comment": "The brow inner joint", 
                    "type": "raw", 
                    "value": "${brow_inner}+'_bind'"
                }, 
                "brow_main": {
                    "comment": "Name for the brow main control", 
                    "type": "str", 
                    "value": "'brow_main_${side}'"
                }, 
                "brow_main_joint": {
                    "comment": "The brow main joint", 
                    "type": "raw", 
                    "value": "${brow_main}+'_bind'"
                }, 
                "brow_peak": {
                    "comment": "Name for the brow peak control", 
                    "type": "str", 
                    "value": "'brow_peak_${side}'"
                }, 
                "brow_peak_joint": {
                    "comment": "The brow peak joint", 
                    "type": "raw", 
                    "value": "${brow_peak} + '_bind'"
                }, 
                "component_parent": {
                    "comment": "Parent for the component", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "driver_parent": {
                    "comment": "parent for the drivers", 
                    "type": "str", 
                    "value": "'face_upper'"
                }, 
                "geometry": {
                    "comment": "Geometry that will have a wire deformer attached to it during the build", 
                    "type": "str", 
                    "value": "'body_geo'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['r', 'rx', 'ry', 'rz', 's', 'sx', 'sy', 'sz', 'v']"
                }, 
                "name": {
                    "comment": "Name of the component", 
                    "type": "raw", 
                    "value": "brow_${side}"
                }, 
                "side": {
                    "comment": "Side attribute lowercase", 
                    "type": "raw", 
                    "value": "l"
                }, 
                "side_multiplier": {
                    "type": "int", 
                    "value": "1"
                }, 
                "side_rotate_multiplier": {
                    "type": "int", 
                    "value": "0"
                }
            }
        }, 
        "/brow/brow_inner": {
            "instance": "../brow_main", 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "raw", 
                    "value": "${brow_inner_joint}"
                }, 
                "anchor": {
                    "type": "raw", 
                    "value": "${brow_main}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${brow_inner}"
                }, 
                "driver_name": {
                    "type": "raw", 
                    "value": "${brow_inner}"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${brow_main}"
                }
            }
        }, 
        "/brow/brow_main": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "align_orientation", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${brow_main_joint}"
                }, 
                "anchor": {
                    "type": "str", 
                    "value": "'head_tip'"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${brow_main}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "driver_name": {
                    "type": "raw", 
                    "value": "${brow_main}"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'ort']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'${name}_space_nul'"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }, 
            "code": [
                ""
            ]
        }, 
        "/brow/brow_main/align_orientation": {
            "enabled": true, 
            "comment": "This node is used to make sure we have the correct orientation for the brow\n", 
            "attrs": {
                "parent_space_alignment": {
                    "type": "str", 
                    "value": "'head_tip'"
                }
            }, 
            "code": [
                "# Get the names of the nul and orients. This could be re-done at some point.", 
                "control_nul = '{}_nul'.format(${control_name})", 
                "control_orient = '{}_ort'.format(${control_name})", 
                "", 
                "# Ensure there is not -1 value on scaleZ", 
                "mc.setAttr('{}.s'.format(control_nul), 1, 1, 1)", 
                "    ", 
                "# make sure the nodes exists and if it's on the right side we will change to orient", 
                "if mc.objExists(control_nul) and mc.objExists(${align_to_node}):", 
                "    con = mc.orientConstraint(${align_to_node}, control_nul)[0]", 
                "    mc.setAttr(con+'.offsetZ', ${side_rotate_multiplier})", 
                "    # delete the constraint", 
                "    mc.delete(con)", 
                ""
            ]
        }, 
        "/brow/brow_main/connect": {
            "enabled": true, 
            "code": [
                "# Get the names of the nul and orients. This could be re-done at some point.", 
                "control_nul = '{}_nul'.format(${control_name})", 
                "control_orient = '{}_ort'.format(${control_name})", 
                "# create the driver nodes", 
                "brow_driver_nul = mc.createNode(\"transform\", name=\"{}_driver_nul\".format(${driver_name}), parent='${name}')", 
                "brow_driver_ort = mc.createNode(\"transform\", name=\"{}_driver_ort\".format(${driver_name}), parent=brow_driver_nul)", 
                "brow_driver = mc.createNode(\"joint\", name=\"{}_driver\".format(${driver_name}), parent=brow_driver_ort)", 
                "# turn the visibility of the driver off.", 
                "mc.setAttr('{}.v'.format(brow_driver), 0)", 
                "# position the driver", 
                "mc.xform(brow_driver_nul, ws=True, matrix=mc.xform(control_nul, q=True, ws=True, matrix=True))", 
                "for attr in ['t', 'r', 's']:", 
                "    mc.connectAttr(\"{}.{}\".format(control_orient, attr), \"{}.{}\".format(brow_driver_ort, attr), f=True)", 
                "", 
                "# point constrain the drive to the control", 
                "mc.pointConstraint(${control_name}, brow_driver)", 
                "", 
                "# TX and TY isolated drivers", 
                "brow_tx_driver = mc.duplicate(brow_driver, po=1, name=\"{}_TX_driver\".format(${control_name}))[0]", 
                "brow_ty_driver = mc.duplicate(brow_driver, po=1, name=\"{}_TY_driver\".format(${control_name}))[0]", 
                "mc.connectAttr(brow_driver+'.tx', brow_tx_driver+'.tx')", 
                "mc.connectAttr(brow_driver+'.ty', brow_ty_driver+'.ty')", 
                "", 
                "", 
                "# create the set driven key nodes.", 
                "brow_sdk_nul = mc.createNode(\"transform\", name=\"{}_sdk_nul\".format(${control_name}), parent='${name}')", 
                "brow_sdk_def_auto = mc.createNode(\"transform\", name=\"{}_sdk_def_auto\".format(${control_name}), parent=brow_sdk_nul)", 
                "brow_sdk_rot_def_auto = mc.createNode(\"transform\", name=\"{}_sdk_rot_def_auto\".format(${control_name}), parent=brow_sdk_def_auto)", 
                "brow_sdk = mc.createNode(\"transform\", name=\"{}_sdk\".format(${control_name}), parent=brow_sdk_rot_def_auto)", 
                "", 
                "# position the SDK nodes thanks", 
                "mc.xform(brow_sdk_nul, ws=True, matrix=mc.xform(brow_driver_ort, q=True, ws=True, matrix=True))", 
                "#mc.orientConstraint(brow_driver_ort, brow_sdk_nul, mo=False)", 
                "", 
                "# create the keys for the brow main sdk nodes", 
                "for attribute in ['x','y','z']:", 
                "", 
                "    mc.setDrivenKeyframe(\"{}.t{}\".format(brow_sdk_def_auto,attribute), ", 
                "                        cd=\"{}.t{}\".format(brow_driver,attribute), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.t{}\".format(brow_sdk_def_auto,attribute), ", 
                "                        cd=\"{}.t{}\".format(brow_driver,attribute), v=1, dv=1)", 
                "    mc.setDrivenKeyframe(\"{}.t{}\".format(brow_sdk_def_auto,attribute), ", 
                "                        cd=\"{}.t{}\".format(brow_driver,attribute), v=-1, dv=-1)", 
                "", 
                "    mc.setDrivenKeyframe(\"{}.r{}\".format(brow_sdk_rot_def_auto,attribute),", 
                "                        cd=\"{}.t{}\".format(brow_driver,attribute), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.r{}\".format(brow_sdk_rot_def_auto,attribute),", 
                "                        cd=\"{}.t{}\".format(brow_driver,attribute), v=.1, dv=1)", 
                "    mc.setDrivenKeyframe(\"{}.r{}\".format(brow_sdk_rot_def_auto,attribute),", 
                "                        cd=\"{}.t{}\".format(brow_driver,attribute), v=-.1, dv=-1)", 
                "                        ", 
                "# constrain the bind joints to the sdk nodes", 
                "mc.pointConstraint(brow_sdk, ${align_to_node})", 
                "mc.orientConstraint(brow_sdk, ${align_to_node})", 
                "", 
                "# Set driven keys to be post and pre infinity", 
                "driven_keys = mc.listConnections(brow_driver, type='animCurveUA')", 
                "driven_keys += mc.listConnections(brow_driver, type='animCurveUL')", 
                "", 
                "# set all of the sdk's defaults", 
                "for x in driven_keys:", 
                "    mc.setAttr(x + '.preInfinity', 1)", 
                "    mc.setAttr(x + '.postInfinity', 1)", 
                "    mc.keyTangent(x, index=(0, 0), inTangentType='spline')", 
                "    mc.keyTangent(x, index=(0, 0), outTangentType='spline')", 
                "    mc.keyTangent(x, index=(2, 2), inTangentType='spline')", 
                "    mc.keyTangent(x, index=(2, 2), outTangentType='spline')"
            ]
        }, 
        "/brow/brow_peak": {
            "instance": "../brow_main", 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "raw", 
                    "value": "${brow_peak_joint}"
                }, 
                "anchor": {
                    "type": "raw", 
                    "value": "${brow_main}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${brow_peak}"
                }, 
                "driver_name": {
                    "type": "raw", 
                    "value": "${brow_peak}"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${brow_main}"
                }
            }
        }, 
        "/brow/corrugator": {
            "instance": "/cluster_control", 
            "enabled": true, 
            "comment": "This will build the corrugator and make sure it's tagged as a control and parented under the brow inner control", 
            "attrs": {
                "control_name": {
                    "type": "str", 
                    "value": "'brow_corrugator_${side}'"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${brow_inner}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/brow/create": {
            "enabled": true, 
            "code": [
                "# creating this variable so we only have to resolve the data once.", 
                "name = '${name}'", 
                "if not mc.objExists(name):", 
                "    mc.createNode(\"transform\", name=name)", 
                "", 
                "# Driver parent ", 
                "if mc.objExists(${driver_parent}):", 
                "    mc.parent(name, ${driver_parent})", 
                "", 
                "# Create a space nul that handles mirroring the control structure", 
                "#", 
                "space_nul = '${name}_space_nul'", 
                "if not mc.objExists(space_nul):", 
                "    mc.createNode(\"transform\", name=space_nul)    ", 
                "    ", 
                "# Sets mirrored values for the right side", 
                "mc.setAttr('{}.r'.format(space_nul), 0, ${side_rotate_multiplier}, 0)", 
                "mc.setAttr('{}.s'.format(space_nul), 1, 1, ${side_multiplier})", 
                "", 
                "# Parent the space nul to the anchor", 
                "if mc.objExists(${anchor}):", 
                "    mc.parent(space_nul, ${anchor})"
            ]
        }, 
        "/brow/curve_rig": {
            "child_order": [
                "create", 
                "wire_deformer"
            ], 
            "enabled": true
        }, 
        "/brow/curve_rig/create": {
            "enabled": true, 
            "attrs": {
                "control_color": {
                    "type": "raw", 
                    "value": "rig_common.RED"
                }, 
                "control_shape": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }, 
            "code": [
                "# create the curve rig for the brows.", 
                "control_name_list = ['brow_bend_{}_${side}'.format(index) for index in range(len(mc.ls('{}.cv[*]'.format(${brow_curve}), fl=True)))]", 
                "", 
                "bindmesh_geometry, follicle_list, control_hierarchy_list, joint_ist, base_curve_joint_list = rig_wire.buildCurveRig(${brow_curve}, ", 
                "                                                                                                name='brow_bend_${side}', ", 
                "                                                                                                ctrl_names=control_name_list, ", 
                "                                                                                                parent=${component_parent}, ", 
                "                                                                                                control_type=${control_type},", 
                "                                                                                                control_color=${control_color},", 
                "                                                                                                control_shape=${control_shape})", 
                "                                                                                                ", 
                "STAGE.base_curve_joint_list = base_curve_joint_list", 
                "", 
                "# flip the nul if we're on the right side of the body", 
                "for control_list in control_hierarchy_list:", 
                "    if '_r_' in control_list[0]:", 
                "        mc.setAttr(control_list[0]+'.ry', -180)", 
                "        mc.setAttr(control_list[0]+'.sz', -1)"
            ]
        }, 
        "/brow/curve_rig/wire_deformer": {
            "enabled": true, 
            "code": [
                "# create the wire deformer.", 
                "# create the skinCluster for the curve", 
                "wire_deformer = mc.wire(${geometry}, gw=False, en=1.00, ce=0.00, li=0.00,", 
                "        w=${brow_curve}, name=\"{}_wire\".format(${brow_curve}))[0]", 
                "# set the default values for the wire deformer", 
                "mc.setAttr(\"{}.rotation\".format(wire_deformer), 0)", 
                "mc.setAttr(\"{}.dropoffDistance[0]\".format(wire_deformer), 100)", 
                "", 
                "# create skinCluster for the base wire", 
                "base_curve = \"{}BaseWire\".format(${brow_curve})", 
                "baseCurveSkin = mc.skinCluster(*STAGE.base_curve_joint_list+mc.ls(base_curve),", 
                "                            n=\"{}_skinCluster\".format(base_curve),", 
                "                            tsb=True)[0]", 
                "", 
                "# parent the curves into the hiearchy.", 
                "mc.parent([${brow_curve}, base_curve], 'brow_bend_${side}_grp')"
            ]
        }, 
        "/foot": {
            "child_order": [
                "create", 
                "visibility"
            ], 
            "enabled": true, 
            "attrs": {
                "SIDE": {
                    "type": "raw", 
                    "value": "L"
                }, 
                "anchor_ball_fk": {
                    "type": "str", 
                    "value": "'ankle_${side}_bind_blend'"
                }, 
                "anchor_fk": {
                    "type": "str", 
                    "value": "'ankle_fk_gimbal_${side}'"
                }, 
                "anchor_ik": {
                    "type": "str", 
                    "value": "'limb_ik_mpivot_${side}_grp'"
                }, 
                "ankle_handle": {
                    "type": "str", 
                    "value": "'ankle_${side}_bind_ik_hdl'"
                }, 
                "ankle_pivot": {
                    "type": "str", 
                    "value": "'ankle_${side}_pivot'"
                }, 
                "ankle_stretch": {
                    "type": "str", 
                    "value": "'ankle_${side}_bind_ik_tgt'"
                }, 
                "ankle_stretch_target": {
                    "type": "str", 
                    "value": "'ankle_fk_${side}_offset'"
                }, 
                "bank_control": {
                    "type": "str", 
                    "value": "'bank_${side}'"
                }, 
                "component_parent": {
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "ikfk_group": {
                    "type": "str", 
                    "value": "'leg_${side}_ikfk_grp'"
                }, 
                "joint_list": {
                    "type": "list", 
                    "value": "['ankle_${side}_bind', 'ball_${side}_bind', 'toe_${side}_bind']"
                }, 
                "name": {
                    "type": "raw", 
                    "value": "foot_${side}"
                }, 
                "param_node": {
                    "type": "raw", 
                    "value": "leg_${side}"
                }, 
                "side": {
                    "type": "raw", 
                    "value": "l"
                }, 
                "toe_joint_list": {
                    "type": "raw", 
                    "value": "mc.ls('toe*_001_${side}_bind')"
                }, 
                "toe_parent": {
                    "type": "raw", 
                    "value": "\"{}\".format(\"\".join(STAGE.ikfk_system.getFkJointList()[1].split(\"_bind\")))"
                }
            }
        }, 
        "/foot/create": {
            "child_order": [
                "connect", 
                "fk", 
                "ik", 
                "param", 
                "scale"
            ], 
            "enabled": true, 
            "code": [
                "if not mc.objExists(${ankle_pivot}):", 
                "    raise RuntimeError(\"{} doesn't exist in the current Maya session.\".format(${ankle_pivot}))", 
                "", 
                "if not mc.objExists(${ankle_handle}):", 
                "    raise RuntimeError(\"{} doesn't exist in the current Maya session.\".format(${ankle_handle}))", 
                "", 
                "STAGE.ikfk_system = rig_ikfk.IkFkFoot(${joint_list}, ${ankle_pivot})", 
                "", 
                "if not mc.objExists(${ikfk_group}):", 
                "    mc.createNode('transform', name=${ikfk_group})", 
                "    mc.parent(${ikfk_group}, ${component_parent})", 
                "    ", 
                "# set the group and create the system", 
                "STAGE.ikfk_system.setGroup(${ikfk_group})", 
                "STAGE.ikfk_system.create()", 
                "", 
                "", 
                "", 
                ""
            ]
        }, 
        "/foot/create/connect": {
            "enabled": true, 
            "code": [
                "# get all of the pivots", 
                "pivot_list = STAGE.ikfk_system.pivotList", 
                "", 
                "# parent the ankle stretch target", 
                "if mc.objExists(${ankle_stretch_target}):", 
                "    mc.parent(${ankle_stretch_target}, pivot_list[-2])", 
                "", 
                "# parent the ankle handle to the pivot hierarchy", 
                "if mc.objExists(${anchor_ik}):", 
                "    mc.parent(${ankle_pivot}, ${anchor_ik})", 
                "    ikJointList = STAGE.ikfk_system.getIkJointList()", 
                "", 
                "# get blend joint list", 
                "blend_joint_list = STAGE.ikfk_system.getBlendJointList()", 
                "", 
                "# loop through and connect original joint list to the blend joints", 
                "for blend_joint, joint in zip(blend_joint_list[1:], ${joint_list}[1:]):", 
                "    mc.pointConstraint(blend_joint, joint)", 
                "    mc.orientConstraint(blend_joint, joint)"
            ]
        }, 
        "/foot/create/fk": {
            "child_order": [
                "controls"
            ], 
            "enabled": true, 
            "code": [
                "#-------------------------------------------------------------------------------------------", 
                "        #FK SETUP", 
                "#-------------------------------------------------------------------------------------------", 
                "# get the fk joint list from the ikfk system", 
                "fk_joint_list = STAGE.ikfk_system.getFkJointList()", 
                "try:", 
                "    mc.parentConstraint(${anchor_fk}, fk_joint_list[0])", 
                "except:", 
                "    print \"{} is already connected.\".format(fk_joint_list[0])"
            ]
        }, 
        "/foot/create/fk/controls": {
            "child_order": [
                "ball", 
                "toes"
            ], 
            "enabled": true
        }, 
        "/foot/create/fk/controls/ball": {
            "enabled": true, 
            "code": [
                "# create the ball fk control", 
                "ctrl_hierarchy = rig_control.create(\"{}\".format(\"\".join(STAGE.ikfk_system.getFkJointList()[1].split(\"_bind\"))), ", 
                "                                                    controlType = \"cube\", ", 
                "                                                    hierarchy=['nul','cst'],", 
                "                                                    transformType=\"joint\")", 
                "", 
                "rig_attribute.lockAndHide(ctrl_hierarchy[-1],", 
                "                                    ['v', 'tx','ty','tz','sx','sy','sz'])", 
                "", 
                "# position the ball control", 
                "fk_joint_list = STAGE.ikfk_system.getFkJointList()", 
                "ball_joint_matrix = mc.xform(fk_joint_list[1], q=True, ws=True, matrix=True)", 
                "mc.parentConstraint(${anchor_ball_fk}, ctrl_hierarchy[0], mo=False)", 
                "mc.xform(ctrl_hierarchy[1], ws=True, matrix=ball_joint_matrix)", 
                "mc.orientConstraint(ctrl_hierarchy[-1], fk_joint_list[1])", 
                "mc.parent(ctrl_hierarchy[0], '${name}')", 
                "STAGE.ball_fk_ctrl_hierarchy = ctrl_hierarchy", 
                "", 
                "# Position the pivot control at the ball -mjs", 
                "print(${anchor_ik}, 'anchor_ik')", 
                "ik_mpivot_nul = ${anchor_ik}.replace('_grp', '_nul')", 
                "trans = mc.xform(fk_joint_list[1], q=True, ws=True, t=True)", 
                "mc.xform(ik_mpivot_nul, ws=True, t=trans)", 
                "#mc.setAttr(self._ikAnchor+'_add.input3D[1].input3Dx', trans[0])", 
                "#mc.setAttr(self._ikAnchor+'_add.input3D[1].input3Dy', trans[1])", 
                "#mc.setAttr(self._ikAnchor+'_add.input3D[1].input3Dz', trans[2])", 
                ""
            ]
        }, 
        "/foot/create/fk/controls/toes": {
            "enabled": true, 
            "code": [
                "# --------------------", 
                "# Toes", 
                "# --------------------", 
                "toe_joint_list = ${toe_joint_list}", 
                "", 
                "# Parent", 
                "toes_parent = ${toe_parent}", 
                "# Each joint parent, changed during the loop", 
                "parent = toes_parent", 
                "", 
                "# loop through all of the parent joints in the toes.", 
                "for jnt in toe_joint_list:", 
                "    # get all of the children of the main toe joints we're using. We have to reverse the", 
                "    # list to get the order we want.", 
                "    children = mc.listRelatives(jnt, ad=True, type=\"joint\")", 
                "    children.reverse()", 
                "", 
                "    # create the first toe control", 
                "    toe_ctrl = jnt.replace('_bind','')", 
                "    toe_ctrl_hierarchy = rig_control.create(name=toe_ctrl,", 
                "                                      controlType=\"square\",", 
                "                                      hierarchy=['nul','cst'],", 
                "                                      parent=parent,", 
                "                                      color=rig_common.CYAN", 
                "                                      )", 
                "", 
                "    # move the control and then constrain the joint to the control.", 
                "    jnt_position = mc.xform(jnt, q=True, ws=True, matrix=True)", 
                "    mc.xform(toe_ctrl_hierarchy[0], ws=True, matrix=jnt_position)", 
                "    mc.pointConstraint(toe_ctrl_hierarchy[-1], jnt)", 
                "    mc.orientConstraint(toe_ctrl_hierarchy[-1], jnt)", 
                "", 
                "    # reset the parent hierarchy to be the control.", 
                "    parent = toe_ctrl_hierarchy[-1]", 
                "", 
                "    # loop throught the children to create controls for them", 
                "    for child_joint in children:", 
                "        # create the control for the child joints.", 
                "        child_ctrl_hierarchy = rig_control.create(name=\"{}\".format(\"\".join(child_joint.split(\"_bind\"))),", 
                "                                           controlType=\"square\",", 
                "                                           hierarchy=['nul','ort'],", 
                "                                           parent=parent,", 
                "                                           color=rig_common.CYAN", 
                "                                           )", 
                "        child_joint_position = mc.xform(child_joint, q=True, ws=True, matrix=True)", 
                "", 
                "        # move the control and then create the constraints.", 
                "        mc.xform(child_ctrl_hierarchy[0], ws=True, matrix=child_joint_position)", 
                "        mc.pointConstraint(child_ctrl_hierarchy[-1], child_joint)", 
                "        mc.orientConstraint(child_ctrl_hierarchy[-1], child_joint)", 
                "", 
                "        # set the parent to be the control we just created.", 
                "        parent = child_ctrl_hierarchy[-1]", 
                "                ", 
                "        if child_joint == children[-1]:", 
                "            parent = toes_parent"
            ]
        }, 
        "/foot/create/ik": {
            "child_order": [
                "controls"
            ], 
            "enabled": true
        }, 
        "/foot/create/ik/controls": {
            "child_order": [
                "bank"
            ], 
            "enabled": true, 
            "attrs": {
                "pivot_pos": {
                    "type": "raw", 
                    "value": "mc.xform(${ankle_pivot}, q=True, ws=True, t=True)[0]"
                }
            }
        }, 
        "/foot/create/ik/controls/bank": {
            "enabled": true, 
            "attrs": {
                "hide_attrs": {
                    "type": "list", 
                    "value": "['ty','v','rx','ry','rz','sx','sy','sz']"
                }
            }, 
            "code": [
                "#-------------------------------------------------------------------------------------------", 
                "#IK SETUP", 
                "#-------------------------------------------------------------------------------------------", 
                "pivot_pos = ${pivot_pos}", 
                "# create controls for our pivot, the last index is the control", 
                "pivot_side = mc.xform(${joint_list}[0], q=True, ws=True, t=True)[0]", 
                "", 
                "bank_ctrl_hierarchy = rig_control.create(${bank_control}, ", 
                "                                        controlType = \"cube\", ", 
                "                                        hierarchy=['nul', 'cst'],", 
                "                                        parent=${ankle_pivot},", 
                "                                        color= rig_common.RED)", 
                "", 
                "ik_control_list = [bank_ctrl_hierarchy[-1]]", 
                "# get the ball pivot position", 
                "ball_jnt_trs = mc.xform(${joint_list}[1], q=True, ws=True, t=True)", 
                "mc.xform(bank_ctrl_hierarchy[0], ws=True, t=ball_jnt_trs)", 
                "", 
                "#lock all attributes except for translateX", 
                "rig_attribute.lockAndHide(bank_ctrl_hierarchy[-1], ${hide_attrs})", 
                "", 
                "# create the remap and multDoubleLinear node.", 
                "bank_remap_node = mc.createNode(\"remapValue\", name=\"{}_remap\".format(bank_ctrl_hierarchy[-1]))", 
                "bank_mdl = mc.createNode(\"multDoubleLinear\", n=\"{}_invert_mdl\".format(bank_ctrl_hierarchy[-1]))", 
                "", 
                "#connect the ctrl.tx to the remap inputValue", 
                "mc.connectAttr(\"{}.tx\".format(bank_ctrl_hierarchy[-1]), \"{}.inputValue\".format(bank_remap_node))", 
                "ball_pivot_distance = mc.getAttr(\"{}.tx\".format(STAGE.ikfk_system.pivotList[1]))", 
                "", 
                "# set attributes for input/output min/max on the remap node.", 
                "mc.setAttr(\"{}.inputMin\".format(bank_remap_node), (ball_pivot_distance * 2)*-1)", 
                "mc.setAttr(\"{}.inputMax\".format(bank_remap_node), (ball_pivot_distance * 2))", 
                "mc.setAttr(\"{}.outputMin\".format(bank_remap_node), -180)", 
                "mc.setAttr(\"{}.outputMax\".format(bank_remap_node), 180)", 
                "mc.connectAttr(\"{}.outValue\".format(bank_remap_node), \"{}.input1\".format(bank_mdl))", 
                "mc.setAttr(\"{}.input2\".format(bank_mdl), -1)", 
                "", 
                "parent = None", 
                "for pivot in STAGE.ikfk_system.pivotList:", 
                "    # if the pivot is a joint, we want to turn off it's joint display", 
                "    if mc.nodeType(pivot) == \"joint\":", 
                "        mc.setAttr(\"{}.drawStyle\".format(pivot), 2)", 
                "", 
                "    # if it's certain pivots in the order we want to not make controls.", 
                "    if pivot in [STAGE.ikfk_system.pivotList[0], STAGE.ikfk_system.pivotList[1], STAGE.ikfk_system.pivotList[3]]:", 
                "        if pivot == STAGE.ikfk_system.pivotList[0]:", 
                "            # create the control hierarchy", 
                "            if  pivot_pos > .01:", 
                "                mc.transformLimits(pivot, rz=(0,0), erz=(1,0))", 
                "                mc.connectAttr(\"{}.output\".format(bank_mdl), \"{}.rz\".format(pivot))", 
                "            else:", 
                "                mc.transformLimits(pivot, rz=(0,0), erz=(1,0))", 
                "                mc.connectAttr(\"{}.outValue\".format(bank_remap_node), \"{}.rz\".format(pivot))", 
                "                mc.setAttr(\"{}.rx\".format(bank_ctrl_hierarchy[0]), 0)", 
                "                mc.setAttr(\"{}.ry\".format(bank_ctrl_hierarchy[0]), 180)", 
                "", 
                "        elif pivot == STAGE.ikfk_system.pivotList[1]:", 
                "            # create the control hierarchy", 
                "            if  pivot_pos > .01:", 
                "                mc.transformLimits(pivot, rz=(0,0), erz=(0,1))", 
                "                mc.connectAttr(\"{}.output\".format(bank_mdl), \"{}.rz\".format(pivot))", 
                "            else:                        ", 
                "                mc.transformLimits(pivot, rz=(0,0), erz=(0,1))", 
                "                mc.connectAttr(\"{}.outValue\".format(bank_remap_node), \"{}.rz\".format(pivot))", 
                "        ", 
                "        parent = pivot", 
                "        continue", 
                "", 
                "    pivot_ctrl_hierarchy = rig_control.create(\"{}\".format(\"\".join(pivot.split(\"_pivot\"))), ", 
                "                                                    controlType = \"cube\", ", 
                "                                                    hierarchy=['nul'])", 
                "", 
                "    # create the control hierarchy", 
                "    if pivot == STAGE.ikfk_system.pivotList[-1]:", 
                "        mc.deleteAttr(\"{}.__control__\".format(pivot_ctrl_hierarchy[-1]))", 
                "        mc.delete(mc.listRelatives(pivot_ctrl_hierarchy[-1],c=True,shapes=True))", 
                "    rig_attribute.lockAndHide(pivot_ctrl_hierarchy[-1],", 
                "                                    ['tx', 'ty','tz','v','sx','sy','sz'])", 
                "", 
                "    pivot_matrix = mc.xform(pivot, q=True, ws=True, matrix=True)", 
                "    mc.xform(pivot_ctrl_hierarchy[0], ws=True, matrix=pivot_matrix)", 
                "    mc.parent(pivot, pivot_ctrl_hierarchy[-1])", 
                "", 
                "    ik_control_list.append(pivot_ctrl_hierarchy[-1])", 
                "", 
                "    if parent:", 
                "        mc.parent(pivot_ctrl_hierarchy[0], parent)", 
                "", 
                "    if pivot == STAGE.ikfk_system.pivotList[-2]:", 
                "        continue", 
                "", 
                "    parent = pivot", 
                "    ", 
                "    ", 
                "# turn of the joint display on the anklePivot", 
                "if mc.nodeType(${ankle_pivot}) == \"joint\":", 
                "        mc.setAttr(\"{}.drawStyle\".format(${ankle_pivot}), 2)", 
                "handle_list = STAGE.ikfk_system.getHandles()", 
                "# turn off the visibility of handles", 
                "for handle in handle_list:", 
                "    mc.setAttr(\"{}.v\".format(handle), 0)", 
                "", 
                "# create setDriven keys for the ball roll", 
                "bank_ctrl = bank_ctrl_hierarchy[-1]", 
                "ball_nul = mc.listRelatives(ik_control_list[-2], p=True)[0]", 
                "heel_nul = mc.listRelatives(ik_control_list[-4], p=True)[0]", 
                "toe_nul = mc.listRelatives(ik_control_list[-3], p=True)[0]", 
                "mc.setDrivenKeyframe(\"{}.rx\".format(ball_nul), cd=\"{}.tz\".format(bank_ctrl), v=0, dv=0)", 
                "mc.setDrivenKeyframe(\"{}.rx\".format(ball_nul), cd=\"{}.tz\".format(bank_ctrl), v=60, dv=5)", 
                "mc.setDrivenKeyframe(\"{}.rx\".format(ball_nul), cd=\"{}.tz\".format(bank_ctrl), v=0, dv=10)", 
                "mc.setDrivenKeyframe(\"{}.rx\".format(heel_nul), cd=\"{}.tz\".format(bank_ctrl), v=0, dv=0)", 
                "mc.setDrivenKeyframe(\"{}.rx\".format(heel_nul), cd=\"{}.tz\".format(bank_ctrl), v=-90, dv=-10)", 
                "mc.setDrivenKeyframe(\"{}.rx\".format(toe_nul), cd=\"{}.tz\".format(bank_ctrl), v=0, dv=5)", 
                "mc.setDrivenKeyframe(\"{}.rx\".format(toe_nul), cd=\"{}.tz\".format(bank_ctrl), v=90, dv=10)", 
                "", 
                "", 
                "# if the param node that is past in exists then we will add attributes to it.", 
                "# if not, we will make one of our own and put them on the controls", 
                "ikfk_attr =\"${param_node}.ikfk\".format()", 
                "if not mc.objExists('${param_node}'):", 
                "    param_node = mc.createNode(\"locator\", name='${param_node}')", 
                "    param_node_trs = mc.listRelatives(param_node, p=True)[0]", 
                "    mc.select(cl=True)", 
                "    # lock and hide attributes on the Param node that we don't need.", 
                "    rig_attribute.lockAndHide(param_node, ['lpx','lpy','lpz','lsx','lsy','lsz'])", 
                "", 
                "    mc.setAttr(\"{0}.v\".format(param_node), 0)", 
                "    mc.addAttr(param_node, ln=\"ikfk\", at=\"double\", min=0, max=1, dv=0, keyable=True)", 
                "", 
                "# create ikfk reverse node to connect the ikfk attribute", 
                "reverse_node = mc.createNode(\"reverse\", name=\"${name}_rvr\")", 
                "mc.connectAttr(ikfk_attr, \"{0}.inputX\".format(reverse_node), f=True)", 
                "", 
                "fk_ctrl_dup = mc.duplicate(STAGE.ball_fk_ctrl_hierarchy[1], po=True, name='{}_fk'.format(STAGE.ball_fk_ctrl_hierarchy[1]))[0]", 
                "mc.parent(fk_ctrl_dup, ${anchor_fk})", 
                "ik_ctrl_dup = mc.duplicate(STAGE.ball_fk_ctrl_hierarchy[1], po=True, name='{}_ik'.format(STAGE.ball_fk_ctrl_hierarchy[1]))[0]", 
                "mc.parent(ik_ctrl_dup, STAGE.ikfk_system.pivotList[-3])", 
                "cst=mc.orientConstraint(ik_ctrl_dup, fk_ctrl_dup, STAGE.ball_fk_ctrl_hierarchy[1], mo=False)[0]", 
                "weight_alias = mc.orientConstraint(cst,q=True,wal=True)", 
                "mc.connectAttr(ikfk_attr, \"{}.{}\".format(cst,weight_alias[1]), f=True)", 
                "mc.connectAttr(\"{}.outputX\".format(reverse_node), \"{}.{}\".format(cst,weight_alias[0]), f=True)", 
                "mc.parent(handle_list[-1],w=True)", 
                "mc.xform(STAGE.ikfk_system.pivotList[-1], ws=True, matrix=mc.xform(STAGE.ball_fk_ctrl_hierarchy[-1], q=True, ws=True, matrix=True))", 
                "mc.parent(handle_list[-1], STAGE.ikfk_system.pivotList[-1])", 
                "mc.orientConstraint(STAGE.ball_fk_ctrl_hierarchy[-1], STAGE.ikfk_system.pivotList[-1], mo=True)", 
                "", 
                "# create the offset joint for the matching to work", 
                "ball_offset_joint = mc.joint(name=\"{}_offset\".format(ik_control_list[-1]))", 
                "mc.setAttr(\"{}.v\".format(ball_offset_joint), 0)", 
                "mc.parent(ball_offset_joint, STAGE.ball_fk_ctrl_hierarchy[-1])", 
                "mc.xform(ball_offset_joint, ws=True, matrix=mc.xform(ik_control_list[-1], q=True, ws=True, matrix=True))", 
                "", 
                "STAGE.ik_control_list = ik_control_list", 
                "STAGE.ball_offset_joint = ball_offset_joint"
            ]
        }, 
        "/foot/create/param": {
            "child_order": [
                "match_attributes"
            ], 
            "enabled": true
        }, 
        "/foot/create/param/match_attributes": {
            "enabled": true, 
            "code": [
                "#------------------------------------------------------------------------------------------", 
                "#Setup attributes on the param node for the ikfk switch.", 
                "#------------------------------------------------------------------------------------------", 
                "# fk match attributes needed to the switch", 
                "mc.addAttr('${param_node}', ln=\"footFkMatchTransform\", dt=\"string\")", 
                "mc.setAttr(\"${param_node}.footFkMatchTransform\", ", 
                "        '\"{0}\"'.format(STAGE.ball_offset_joint), ", 
                "        type=\"string\")", 
                "", 
                "mc.addAttr('${param_node}', ln=\"footFkControl\", dt=\"string\")", 
                "mc.setAttr(\"${param_node}.footFkControl\", ", 
                "        '\"{0}\"'.format(STAGE.ball_fk_ctrl_hierarchy[-1]), ", 
                "        type=\"string\")", 
                "", 
                "# ik match attributes needed for the switch", 
                "mc.addAttr('${param_node}', ln=\"footIkMatchTransform\", dt=\"string\")", 
                "mc.setAttr(\"${param_node}.footIkMatchTransform\", ", 
                "        '\"{0}\"'.format(STAGE.ikfk_system.getIkJointList()[1]), ", 
                "        type=\"string\")", 
                "mc.addAttr('${param_node}', ln=\"footIkControls\", dt=\"string\")", 
                "mc.setAttr(\"${param_node}.footIkControls\", ", 
                "        '[\"{0}\",\"{1}\",\"{2}\",\"{3}\",\"{4}\"]'.format(*STAGE.ik_control_list), ", 
                "        type=\"string\")"
            ]
        }, 
        "/foot/create/scale": {
            "enabled": true, 
            "code": [
                "# --------------------", 
                "# Foot Scale", 
                "# --------------------", 
                "# Turn off scale compensate on children of bind joint", 
                "child_list = mc.listRelatives(${joint_list}[0], c=1, type='joint')", 
                "if child_list:", 
                "    for child in child_list:", 
                "        mc.setAttr('{}.segmentScaleCompensate'.format(child), 0)", 
                ""
            ]
        }, 
        "/foot/visibility": {
            "enabled": true, 
            "code": [
                "for joint in (STAGE.ikfk_system.getFkJointList()[0], STAGE.ikfk_system.getBlendJointList()[0], STAGE.ikfk_system.getIkJointList()[0]):", 
                "    mc.setAttr(\"{}.v\".format(joint), 0)"
            ]
        }, 
        "/leg": {
            "child_order": [
                "pelvis", 
                "limb", 
                "foot"
            ], 
            "enabled": true, 
            "attrs": {
                "SIDE": {
                    "comment": "Side attribute uppercase", 
                    "type": "raw", 
                    "value": "L"
                }, 
                "component_parent": {
                    "comment": "Name of the node to parent this componennt to.", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "mirror_swing": {
                    "comment": "Whether we should mirror the translate behavior of the swing when we're on the right side.", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "name": {
                    "comment": "Name of the group for the component", 
                    "type": "raw", 
                    "value": "leg_${side}"
                }, 
                "param_node": {
                    "comment": "Name of the parameter node where all of the attributes will live for this component.", 
                    "type": "raw", 
                    "value": "leg_${SIDE}"
                }, 
                "pelvis_control": {
                    "comment": "The name of the control being used for the clavicle", 
                    "type": "str", 
                    "value": "'pelvis_${side}'"
                }, 
                "pelvis_joint": {
                    "comment": "The name of the joint being used for the clavicle", 
                    "type": "str", 
                    "value": "'pelvis_${side}_bind'"
                }, 
                "side": {
                    "comment": "Side attribute lowercase", 
                    "type": "raw", 
                    "value": "l"
                }, 
                "side_multiplier": {
                    "type": "int", 
                    "value": "1"
                }, 
                "swing_control": {
                    "comment": "This is the name of the control that will be used as the swing control for the arm.", 
                    "type": "str", 
                    "value": "'thighSwing_${side}'"
                }, 
                "swing_nul_offset": {
                    "type": "tuple", 
                    "value": "(90 * ${side_multiplier}, 0, -90 * ${side_multiplier})"
                }
            }
        }, 
        "/leg/foot": {
            "instance": "/foot", 
            "child_order": [
                "create", 
                "visibility"
            ], 
            "enabled": true, 
            "attrs": {
                "anchor_ik": {
                    "type": "str", 
                    "value": "'leg_ik_mpivot_${side}_grp'"
                }
            }
        }, 
        "/leg/limb": {
            "instance": "/arm/limb", 
            "child_order": [
                "swing", 
                "set_zero_pose", 
                "create", 
                "auto_clav", 
                "set_control_defaults", 
                "fk_spaces", 
                "ik_spaces", 
                "auto_clav_world_space", 
                "spaces_pv", 
                "auto_clave_world_space"
            ], 
            "enabled": true, 
            "attrs": {
                "clavicle_anchor": {
                    "type": "str", 
                    "value": "'hip_swivel'"
                }, 
                "clavicle_control": {
                    "type": "raw", 
                    "value": "${pelvis_control}"
                }, 
                "clavicle_joint": {
                    "type": "raw", 
                    "value": "${pelvis_joint}"
                }, 
                "fk_control_list": {
                    "type": "list", 
                    "value": "[\"thigh_fk_${side}\", \"knee_fk_${side}\", \"ankle_fk_${side}\", \"ankle_fk_gimbal_${side}\"]"
                }, 
                "ik_control_list": {
                    "type": "list", 
                    "value": "[\"leg_pv_${side}\", \"leg_ik_${side}\", \"leg_ik_gimbal_${side}\", \"leg_ik_mpivot_${side}\"]"
                }, 
                "ik_rotate_order": {
                    "type": "int", 
                    "value": "3"
                }, 
                "joint_list": {
                    "type": "list", 
                    "value": "[\"thigh_${side}_bind\", \"knee_${side}_bind\", \"ankle_${side}_bind\"]"
                }, 
                "name": {
                    "type": "raw", 
                    "value": "leg_${side}"
                }, 
                "param_node": {
                    "type": "raw", 
                    "value": "leg_${SIDE}"
                }, 
                "pv_aim_node": {
                    "type": "raw", 
                    "value": "${fk_control_list}[0]"
                }, 
                "twist_joint_list": {
                    "type": "list", 
                    "value": "[\"thighNoTwist_${side}_bind\", \"kneeTwist_${side}_bind\", \"ankleTwist_${side}_bind\"]"
                }
            }
        }, 
        "/leg/limb/auto_clav": {
            "child_order": [
                "duplicate_chain", 
                "connect", 
                "param_node", 
                "psd"
            ], 
            "enabled": false
        }, 
        "/leg/limb/auto_clav/connect": {}, 
        "/leg/limb/auto_clav/duplicate_chain": {}, 
        "/leg/limb/auto_clav/param_node": {}, 
        "/leg/limb/auto_clav/psd": {
            "enabled": false
        }, 
        "/leg/limb/auto_clav_world_space": {
            "enabled": false
        }, 
        "/leg/limb/auto_clave_world_space": {
            "enabled": false
        }, 
        "/leg/limb/create": {
            "child_order": [
                "fk", 
                "ik", 
                "param", 
                "connect", 
                "clavicle_connect", 
                "bendy_limb"
            ], 
            "enabled": true
        }, 
        "/leg/limb/create/ik": {
            "child_order": [
                "controls", 
                "offset"
            ], 
            "enabled": true
        }, 
        "/leg/limb/create/ik/offset": {
            "child_order": [
                "zero_control"
            ], 
            "enabled": true
        }, 
        "/leg/limb/create/ik/offset/zero_control": {
            "enabled": true, 
            "code": [
                "# get data from the ikfk system", 
                "fk_control_list = ${fk_control_list}", 
                "fk_gimbal_control = fk_control_list[-1]", 
                "fk_ankle_control = fk_control_list[2]", 
                "ik_control_list = ${ik_control_list}", 
                "ik_gimbal_control = ik_control_list[2]", 
                "ik_ankle_control = ik_control_list[1]", 
                "", 
                "", 
                "offset_joint = mc.listRelatives(ik_gimbal_control, ad=True, type=\"joint\")[-1]", 
                "fk_offset_joint = mc.listRelatives(fk_gimbal_control, c=True, type=\"joint\")[0]", 
                "mc.setAttr(\"{}.r\".format(ik_ankle_control), 0,0,0)", 
                "fk_ankle_matrix=mc.xform(fk_ankle_control,q=True, ws=True, matrix=True)", 
                "# Put fkankle matrix data into the orient of the offset joint", 
                "mc.xform(offset_joint, ws=True, matrix=fk_ankle_matrix)", 
                "rig_joint.rotateToOrient(offset_joint)", 
                "ik_ankle_matrix=mc.xform(ik_ankle_control,q=True, ws=True, matrix=True)", 
                "mc.xform(fk_offset_joint, ws=True, matrix=ik_ankle_matrix)"
            ]
        }, 
        "/leg/limb/fk_spaces": {
            "enabled": false
        }, 
        "/leg/limb/ik_spaces": {
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "value": "'leg_ik_${side}'"
                }, 
                "constraint_node": {
                    "value": "'leg_ik_${side}_ort'"
                }, 
                "name_list": {
                    "value": "['hip_swivel', 'hips']"
                }, 
                "target_list": {
                    "value": "['hip_swivel', 'hips_bind']"
                }
            }
        }, 
        "/leg/limb/set_control_defaults": {
            "enabled": false
        }, 
        "/leg/limb/set_zero_pose": {
            "enabled": false
        }, 
        "/leg/limb/spaces_pv": {
            "instance": "/space_switch", 
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "str", 
                    "value": "'leg_pv_${side}'"
                }, 
                "constraint_node": {
                    "type": "str", 
                    "value": "'leg_pv_${side}_nul'"
                }, 
                "constraint_type": {
                    "type": "str", 
                    "value": "'parent'"
                }, 
                "default_target_index": {
                    "type": "int", 
                    "value": "2"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "['pelvis', 'foot']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${component_parent}"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "['pelvis_${side}', 'ankle_fk_${side}_offset_pv']"
                }
            }
        }, 
        "/leg/limb/swing": {
            "child_order": [
                "control"
            ], 
            "enabled": true
        }, 
        "/leg/limb/swing/control": {
            "child_order": [
                "create", 
                "mirror_swing", 
                "pv_aim_node"
            ], 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "str", 
                    "value": "'thigh_${side}_bind'"
                }
            }
        }, 
        "/leg/limb/swing/control/mirror_swing": {
            "enabled": true
        }, 
        "/leg/limb/swing/control/pv_aim_node": {
            "enabled": false
        }, 
        "/leg/pelvis": {
            "child_order": [
                "control"
            ], 
            "enabled": true
        }, 
        "/leg/pelvis/control": {
            "instance": "/control", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "raw", 
                    "value": "${pelvis_joint}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${pelvis_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'square'"
                }, 
                "hide_attrs": {
                    "value": "['v', 'sx', 'sy', 'sz']"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": [
                        "nul", 
                        "ort"
                    ]
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'hip_swivel'"
                }
            }
        }, 
        "/limb": {
            "child_order": [
                "set_zero_pose", 
                "create", 
                "set_control_defaults", 
                "fk_spaces", 
                "ik_spaces"
            ], 
            "enabled": true, 
            "comment": "This is the base component for all limbs. ", 
            "attrs": {
                "SIDE": {
                    "comment": "Uppercase version of the side name", 
                    "type": "raw", 
                    "value": "L"
                }, 
                "anchor": {
                    "comment": "Name of the object you wish to have the limb follow", 
                    "type": "str", 
                    "value": "'clavicle_${side}'"
                }, 
                "component_parent": {
                    "comment": "Name of the node to parent this componennt to.", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "create_proxy_attributes": {
                    "comment": "Whther or not to use proxy attributes", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "fk_control_list": {
                    "comment": "Array of names to be used for the fk controls", 
                    "type": "list", 
                    "value": "[\"upper_${name}\", \"lower_${name}\", \"end_${name}\", \"end_gimbal_${name}\"]"
                }, 
                "fk_rotate_offset": {
                    "comment": "This is used to set the offset ", 
                    "type": "raw", 
                    "value": "(-90*${side_multiplier}, 0, 0) "
                }, 
                "geometry": {
                    "comment": "Geoemtry used for the wire deformers created", 
                    "type": "str", 
                    "value": "'body_geo'"
                }, 
                "ik_control_list": {
                    "comment": "Array of names to be used for the ik controls", 
                    "type": "list", 
                    "value": "[\"limb_pv_${side}\", \"limb_ik_${side}\", \"limb_ik_gimbal_${side}\", \"limb_ik_mpivot_${side}\"]"
                }, 
                "ik_rotate_offset": {
                    "comment": "This is used to set the offset difference from FK orientation", 
                    "type": "raw", 
                    "value": "(90*${side_multiplier}, 0, 0) "
                }, 
                "ik_rotate_order": {
                    "comment": "Used to set the rotate order for the ik control", 
                    "type": "int", 
                    "value": "0"
                }, 
                "joint_list": {
                    "comment": "list of joints to put the limb rig on", 
                    "type": "list", 
                    "value": "[\"upper_${side}_bind\", \"lower_${side}_bind\", \"end_${side}_bind\"]"
                }, 
                "name": {
                    "comment": "name for the group and prefix for names in the build", 
                    "type": "raw", 
                    "value": "limb_${side}"
                }, 
                "param_node": {
                    "comment": "this is the node where a lot of the attirbutes will live for stretching and switching", 
                    "type": "raw", 
                    "value": "limb_${SIDE}"
                }, 
                "pv_aim_node": {
                    "comment": "Node which is used for the pv to be able to follow the end joint. i.e. (wrist or ankle)", 
                    "type": "raw", 
                    "value": "${fk_control_list}[0]"
                }, 
                "pv_offset": {
                    "type": "int", 
                    "value": "40"
                }, 
                "side": {
                    "comment": "Lowercase version of the side name", 
                    "type": "raw", 
                    "value": "l"
                }, 
                "side_multiplier": {
                    "comment": "This is used to set the inverse depending which side you're on.", 
                    "type": "int", 
                    "value": "1"
                }, 
                "twist_joint_list": {
                    "comment": "List of twist joints associated with the main joint list. Used for the bendy bindmesh weighting.", 
                    "type": "list", 
                    "value": "[\"upper_${side}_noTwist_bind\", \"lower_${side}_twist_bind\", \"end_${side}_twist_bind\"]"
                }, 
                "world_orient_offset": {
                    "comment": "This is used to offset the joints in rotation based on world space.", 
                    "type": "tuple", 
                    "value": "(-90 * ${side_multiplier}, 0, 0)"
                }, 
                "zero_control_list": {
                    "comment": "The list of controls that will be zero'd out at some point in the build to make sure the zero pose is T-pose", 
                    "type": "raw", 
                    "value": "${fk_control_list}"
                }
            }, 
            "code": [
                "if not mc.objExists('${name}'):", 
                "    mc.createNode('transform', name='${name}')", 
                "    if mc.objExists(${component_parent}):", 
                "        mc.parent('${name}', ${component_parent})"
            ]
        }, 
        "/limb/create": {
            "child_order": [
                "fk", 
                "ik", 
                "param", 
                "connect", 
                "bendy_limb"
            ], 
            "enabled": true, 
            "code": [
                "# creating this variable so we only have to resolve the data once.", 
                "name = '${name}'", 
                "if not mc.objExists(name):", 
                "    mc.createNode(\"transform\", name=name)", 
                "", 
                "ikfk_system = rig_ikfk.IKFKLimb(${joint_list})", 
                "ikfk_system.create()", 
                "", 
                "# get the group, rename it, then reset it to the instance.", 
                "group = ikfk_system.getGroup()", 
                "group = mc.rename(group, \"${name}_{}\".format(group))", 
                "ikfk_system.setGroup(group)", 
                "", 
                "# store the system onto property so we can use it later in the build", 
                "STAGE.ikfk_system = ikfk_system", 
                "", 
                "# parent the system to the component group if it exists", 
                "if mc.objExists(${component_parent}):", 
                "    mc.parent(group, ${component_parent})", 
                "    ", 
                "if mc.objExists(${anchor}):", 
                "    STAGE.anchor_group = mc.createNode('transform', n=self.name+'_anchor_grp', p=self.name) ", 
                "    mc.xform(STAGE.anchor_group, ws=True, matrix=mc.xform(self.joint_list[0], q=True, ws=True, matrix=True))", 
                "    mc.parentConstraint(${anchor}, STAGE.anchor_group, mo=1)", 
                "    mc.hide(STAGE.anchor_group)", 
                "else:", 
                "    mc.warning('Anchor object [ {} ] does not exist.'.format(${anchor})) "
            ]
        }, 
        "/limb/create/bendy_limb": {
            "enabled": true, 
            "comment": "This node will create the bendy part of the limb. It uses a wire deformer.", 
            "code": [
                "#create the curve that will be used for the bendy limb", 
                "point_list = list()", 
                "for jnt in self.joint_list:", 
                "    point_list.append(mc.xform(jnt, q=True, ws=True, t=True))", 
                "    ", 
                "point_list.insert(1, (om.MVector(*point_list[0])-om.MVector(*point_list[1]))/2 + om.MVector(*point_list[1]))", 
                "point_list.insert(3, (om.MVector(*point_list[2])-om.MVector(*point_list[3]))/2 + om.MVector(*point_list[3]))", 
                "curve = rig_curve.createCurveFromPoints(point_list, degree=2, name='${name}_curve')", 
                "control_name_list = ['${name}'.replace('_${side}','_bend_{}_${side}'.format(index)) for index in range(len(point_list))]", 
                "bindmesh_geometry, follicle_list, control_hieracrchy_list, joint_list, base_curve_joint_list = rig_wire.buildCurveRig(curve, ", 
                "                                                                                                        name='${name}_bend', ", 
                "                                                                                                        ctrl_names=control_name_list, ", 
                "                                                                                                        parent=${component_parent}, ", 
                "                                                                                                        control_type='body')", 
                "                                                                                                        ", 
                "# This is dumb but the most consitent way for me to get the right behavior", 
                "# parenting the last joint to the first on to grab the axis I want to use for aiming", 
                "mc.parent(joint_list[-1], joint_list[0])", 
                "# get the axis we want to use to aim. ", 
                "aim_distance = mc.getAttr(\"{}.t\".format(joint_list[-1]))[0]", 
                "aim_attr, aim_vector = rig_transform.getDistanceVector(aim_distance)", 
                "# parent the joint back to the control", 
                "mc.parent(joint_list[-1], control_hieracrchy_list[-1][-1])", 
                "mc.pointConstraint(control_hieracrchy_list[0][-1],control_hieracrchy_list[2][-1], control_hieracrchy_list[1][2], mo=True)", 
                "cst = mc.aimConstraint(joint_list[2], control_hieracrchy_list[1][2], mo=True, w=1, upVector=(0,0,0), aimVector=aim_vector, wut=\"none\")[0]", 
                "mc.connectAttr('{}.r'.format(control_hieracrchy_list[1][1]), '{}.offset'.format(cst), f=True)", 
                "cst = mc.aimConstraint(joint_list[1], joint_list[0], upVector=(0,0,0), mo=True, w=1, aimVector=aim_vector, wut=\"none\")[0]", 
                "mc.connectAttr('{}.r'.format(control_hieracrchy_list[0][1]), '{}.offset'.format(cst), f=True)", 
                "", 
                "# This is dumb but the most consitent way for me to get the right behavior", 
                "# parenting the last joint to the first on to grab the axis I want to use for aiming", 
                "mc.parent(joint_list[0], joint_list[-1])", 
                "aim_distance = mc.getAttr(\"{}.t\".format(joint_list[0]))[0]", 
                "aim_attr, aim_vector = rig_transform.getDistanceVector(aim_distance)", 
                "# parent the joint back to the control", 
                "mc.parent(joint_list[0], control_hieracrchy_list[0][-1])", 
                "mc.pointConstraint(control_hieracrchy_list[2][-1],control_hieracrchy_list[4][-1], control_hieracrchy_list[3][2], mo=True)", 
                "cst = mc.aimConstraint(joint_list[2], control_hieracrchy_list[3][2], mo=True, w=1, upVector=(0,0,0), aimVector=aim_vector, wut=\"none\")[0]", 
                "mc.connectAttr('{}.r'.format(control_hieracrchy_list[3][1]), '{}.offset'.format(cst), f=True)", 
                "cst = mc.aimConstraint(joint_list[-2], joint_list[-1], upVector=(0,0,0), mo=True, w=1, aimVector=aim_vector, wut=\"none\")[0]", 
                "mc.connectAttr('{}.r'.format(control_hieracrchy_list[-1][1]), '{}.offset'.format(cst), f=True)            ", 
                "if mc.objExists(${geometry}):", 
                "    #deform the lid bindmesh with the lid curve using a wire deformer.", 
                "    wire_deformer = mc.wire(${geometry}, gw=False, en=1.00, ce=0.00, li=0.00, ", 
                "            w=curve, name=\"{}_wire\".format(curve))[0]", 
                "            ", 
                "    base_curve = \"{}BaseWire\".format(curve)", 
                "    mc.parent([curve,base_curve], '${name}_bend_grp')", 
                "    base_curve_skin = mc.skinCluster(*[base_curve_joint_list]+mc.ls(base_curve), ", 
                "                                n=\"{}_skinCluster\".format(base_curve),", 
                "                                tsb=True)[0]", 
                "", 
                "    # set the default values for the wire deformer", 
                "    #mc.setAttr(\"{}.rotation\".format(wireDeformer), 0)", 
                "    mc.setAttr(\"{}.dropoffDistance[0]\".format(wire_deformer), 100)", 
                "", 
                "# Bindmesh skinCluster joints", 
                "upper_no_twist, mid_twist, end_twist = ${twist_joint_list}", 
                "upper, mid, end = ${joint_list}", 
                "bind_mesh_joints = [upper, mid, end, upper_no_twist, mid_twist, end_twist]", 
                "bind_mesh_skin = mc.skinCluster(*bind_mesh_joints+mc.ls(bindmesh_geometry), ", 
                "                                    n=\"{}_skinCluster\".format(bindmesh_geometry),", 
                "                                    tsb=True)[0]", 
                "        ", 
                "mc.skinPercent(bind_mesh_skin , '{}.vtx[0:3]'.format(bindmesh_geometry), ", 
                "                transformValue=[(upper_no_twist, 1.0), ", 
                "                                (mid_twist, 0.0), ", 
                "                                (upper, 0.0), ", 
                "                                (mid, 0.0), ", 
                "                                (end,0.0), ", 
                "                                (end_twist, 0.0)])", 
                "mc.skinPercent(bind_mesh_skin , '{}.vtx[4:7]'.format(bindmesh_geometry), ", 
                "                transformValue=[(upper_no_twist, 0.5), ", 
                "                                (mid_twist, 0.5), ", 
                "                                (upper, 0.0), ", 
                "                                (mid, 0.0), ", 
                "                                (end,0.0), ", 
                "                                (end_twist, 0.0)])", 
                "mc.skinPercent(bind_mesh_skin , '{}.vtx[8:11]'.format(bindmesh_geometry), ", 
                "                transformValue=[(upper_no_twist, 0.0), ", 
                "                                (mid_twist, 0.5), ", 
                "                                (upper, 0.0), ", 
                "                                (mid, 0.5), ", 
                "                                (end,0.0), ", 
                "                                (end_twist, 0.0)])", 
                "mc.skinPercent(bind_mesh_skin , '{}.vtx[12:15]'.format(bindmesh_geometry), ", 
                "                transformValue=[(upper_no_twist, 0.0), ", 
                "                                (mid_twist, 0.0), ", 
                "                                (upper, 0.0), ", 
                "                                (mid, 0.5), ", 
                "                                (end,0.0), ", 
                "                                (end_twist, 0.5)])", 
                "mc.skinPercent(bind_mesh_skin , '{}.vtx[16:19]'.format(bindmesh_geometry), ", 
                "                transformValue=[(upper_no_twist, 0.0), ", 
                "                                (mid_twist, 0.0), ", 
                "                                (upper, 0.0), ", 
                "                                (mid, 0.0), ", 
                "                                (end,0.0), ", 
                "                                (end_twist, 1.0)])", 
                "", 
                "mc.pointConstraint(self.joint_list[0],self.joint_list[1], base_curve_joint_list[1], mo=True)", 
                "mc.orientConstraint(self.joint_list[0], base_curve_joint_list[1], mo=True)", 
                "", 
                "mc.pointConstraint(self.joint_list[1],self.joint_list[2], base_curve_joint_list[3], mo=True)", 
                "mc.orientConstraint(self.joint_list[1], base_curve_joint_list[3], mo=True)", 
                "", 
                "mc.pointConstraint(self.joint_list[0],self.joint_list[1], ", 
                "                    control_hieracrchy_list[1][0], mo=True)", 
                "mc.orientConstraint(self.joint_list[0], control_hieracrchy_list[1][0], mo=True)", 
                "", 
                "mc.pointConstraint(self.joint_list[1],self.joint_list[2], ", 
                "                    control_hieracrchy_list[3][0], mo=True)", 
                "mc.orientConstraint(self.joint_list[1], control_hieracrchy_list[3][0], mo=True)", 
                ""
            ]
        }, 
        "/limb/create/connect": {
            "enabled": true, 
            "code": [
                "# get the blend joint list", 
                "blend_joint_list = STAGE.ikfk_system.getBlendJointList()", 
                "", 
                "# connect the blend joints to the bind joints", 
                "for joint, blend_joint in zip(${joint_list}, blend_joint_list):", 
                "    mc.pointConstraint(blend_joint, joint)", 
                "    mc.orientConstraint(blend_joint, joint)", 
                "    #mc.connectAttr(\"{}.s\".format(blend_joint), \"{}.s\".format(joint), f=True)", 
                "    ", 
                "# Connect the upper distance node to the no_twist joint", 
                "joint_list = ${joint_list}", 
                "fk_control_list = ${fk_control_list}", 
                "name_split = joint_list[0].split('_${side}_')", 
                "no_twist = '{}NoTwist_${side}_{}'.format(name_split[0], name_split[1])", 
                "target = joint_list[1]", 
                "aim_distance = mc.getAttr(\"{}.t\".format(joint_list[1]))[0]", 
                "aim_attr, aim_vector = rig_transform.getDistanceVector(aim_distance)", 
                "if mc.objExists(no_twist):          ", 
                "    distance_upper_jnt = \"{}_upper_dist_jnt\".format('${name}')", 
                "    ", 
                "    if mc.objExists(distance_upper_jnt):", 
                "        mc.pointConstraint(no_twist, distance_upper_jnt, mo=0)", 
                "        mc.setAttr(\"{}.v\".format(distance_upper_jnt), 0 )", 
                "else:", 
                "    print('noTwist not found', no_twist)", 
                "", 
                "aim_vector = [value * -1 for value in aim_vector]", 
                "", 
                "# LAST JOINT twist setup", 
                "joint = joint_list[-1]", 
                "name_split = joint.split('_${side}_')", 
                "twist_joint = '{}Twist_${side}_{}'.format(name_split[0], name_split[1])", 
                "if mc.objExists(twist_joint):", 
                "    # make sure we create a node for the pv foot space. We need to make a twist joint ", 
                "    # that follows the ik control", 
                "    offset_joint = \"{}_offset\".format(fk_control_list[-2])", 
                "    ", 
                "    if mc.objExists(offset_joint):", 
                "        # create the pvSpaceNode and make sure it's in the correct space", 
                "        pv_space_node = mc.createNode(\"joint\", name=\"{}_pv\".format(offset_joint))", 
                "        mc.parent(pv_space_node, offset_joint)", 
                "        mc.setAttr(\"{}.t\".format(pv_space_node),0,0,0)", 
                "        mc.setAttr(\"{}.r\".format(pv_space_node),0,0,0)", 
                "        # turn off the visibility of the joint", 
                "        mc.setAttr(\"{}.v\".format(pv_space_node), 0)", 
                "        mc.aimConstraint(${pv_aim_node}, pv_space_node, mo=0, weight=1, ", 
                "                            aimVector=aim_vector, upVector=(0, 0, 0), worldUpType='none')", 
                "else:", 
                "    print('No twist joint found', twist_joint)"
            ]
        }, 
        "/limb/create/fk": {
            "child_order": [
                "controls"
            ], 
            "enabled": true, 
            "code": [
                ""
            ]
        }, 
        "/limb/create/fk/controls": {
            "enabled": true, 
            "code": [
                "#-------------------------------------------------------------------------------------------", 
                "#FK Setup for the limb", 
                "#-------------------------------------------------------------------------------------------", 
                "# get the fk joint list", 
                "fk_joint_list = STAGE.ikfk_system.getFkJointList()", 
                "ikfk_group = STAGE.ikfk_system.getGroup()", 
                "fk_control_list = ${fk_control_list}", 
                "joint_list = ${joint_list}", 
                "parent = ikfk_group", 
                "", 
                "for joint, fk_control in zip(fk_joint_list, fk_control_list[:-1]):", 
                "    # make sure that the control is in the same position as the joint", 
                "    fk_joint_matrix = mc.xform(joint, q=True, ws=True, matrix=True)", 
                "    # create the fk control hierarchy", 
                "    if fk_control == fk_control_list[-2]:", 
                "        rig_control.create(name=fk_control,", 
                "                                        controlType=\"cube\",", 
                "                                        hierarchy=[],", 
                "                                        transformType=\"joint\",", 
                "                                        hideAttrs=[\"radius\", \"tx\", \"ty\", \"tz\",\"v\", \"sx\", \"sy\", \"sz\"],", 
                "                                        parent=parent)", 
                "", 
                "        # create the gimbal control for the end control", 
                "        fk_gimbal_control = rig_control.create(name=fk_control_list[-1],", 
                "                                                    controlType=\"sphere\",", 
                "                                                    hierarchy=[],", 
                "                                                    transformType=\"joint\",", 
                "                                                    hideAttrs=[\"radius\", \"tx\", \"ty\", \"tz\", \"v\", \"sx\", \"sy\", \"sz\"],", 
                "                                                    parent=fk_control)[0]", 
                "", 
                "        # move the gimbal ctrl to the correct location", 
                "        mc.xform(fk_gimbal_control,ws=True, matrix=mc.xform(fk_control ,q=True, ws=True, matrix=True))", 
                "        mc.xform(fk_control, ws=True, matrix=fk_joint_matrix)", 
                "        constraint_control = fk_gimbal_control", 
                "    else:", 
                "        rig_control.create(name=fk_control, ", 
                "                            controlType=\"cube\",", 
                "                            hierarchy=[],", 
                "                            transformType=\"joint\",", 
                "                            hideAttrs=[\"radius\", \"sx\", \"sy\", \"sz\", \"tx\", \"ty\", \"tz\", \"v\"],", 
                "                            parent=parent)", 
                "        mc.xform(fk_control, ws=True, matrix=fk_joint_matrix)", 
                "        constraint_control = fk_control", 
                "", 
                "    # setup the constraints from the control to the joint", 
                "    mc.pointConstraint(constraint_control, joint)", 
                "    mc.orientConstraint(constraint_control, joint)", 
                "    parent = fk_control", 
                "    ", 
                "    # Connect ik/fk state vis switch to the shapes of the controls", 
                "    control_shapes = mc.listRelatives(fk_control, s=1, ni=1)", 
                "    for shape in control_shapes:", 
                "        mc.connectAttr(\"{}.ikfk\".format(ikfk_group), \"{}.v\".format(shape), f=True)", 
                "", 
                "rig_joint.rotateToOrient(fk_control_list)", 
                "", 
                "mc.setAttr(\"{}.preferredAngle\".format(fk_control_list[1]), ", 
                "            *mc.getAttr(\"{}.preferredAngle\".format(joint_list[1]))[0])"
            ]
        }, 
        "/limb/create/ik": {
            "child_order": [
                "controls", 
                "offset"
            ], 
            "enabled": true, 
            "code": [
                ""
            ]
        }, 
        "/limb/create/ik/controls": {
            "child_order": [
                "visibility"
            ], 
            "enabled": true, 
            "code": [
                "ik_joint_list = STAGE.ikfk_system.getIkJointList()", 
                "handle = STAGE.ikfk_system.getHandle()", 
                "ikfk_group = STAGE.ikfk_system.getGroup()", 
                "# get the fk joint list", 
                "", 
                "ik_control_list = ${ik_control_list}", 
                "fk_control_list = ${fk_control_list}", 
                "# create the polevector control", 
                "pole_vector_pos = rig_ikfk.IKFKLimb.getPoleVectorFromHandle(handle, ik_joint_list)", 
                "middle_fk_point = mc.xform(fk_control_list[1], q=True, ws=True, t=True)", 
                "pv_control_hierarchy = rig_control.create(name=ik_control_list[0], ", 
                "                                        controlType=\"diamond\",", 
                "                                        hierarchy=['nul','ort'],", 
                "                                        position=pole_vector_pos,", 
                "                                        hideAttrs=[\"v\", \"rx\", \"ry\", \"rz\", \"sx\", \"sy\", \"sz\"],", 
                "                                        color=rig_common.GREEN,", 
                "                                        parent=ikfk_group)", 
                "                                        ", 
                "mc.xform(pv_control_hierarchy[0], ws=True, t=(middle_fk_point[0], middle_fk_point[1],  pole_vector_pos[2]))", 
                "# get the handle and pv control", 
                "pv_control = pv_control_hierarchy[-1]", 
                "pv_constraint = mc.poleVectorConstraint(pv_control, handle)[0]", 
                "", 
                "pv_match_node = mc.duplicate(pv_control, po=True, rr=True, name=\"{}_match\".format(pv_control))[0]", 
                "rig_control.untagAsControl(pv_match_node)", 
                "", 
                "mc.parent(pv_match_node, fk_control_list[0])", 
                "", 
                "", 
                "end_joint_pos = mc.xform(ik_joint_list[-1], q=True, ws=True, t=True)", 
                "ik_control_hierarchy = rig_control.create(name=ik_control_list[1], ", 
                "                                        controlType=\"cube\",", 
                "                                        hierarchy=['nul','ort'],", 
                "                                        position=end_joint_pos,", 
                "                                        color=rig_common.GREEN,", 
                "                                        hideAttrs=[\"v\", \"sx\", \"sy\", \"sz\"],", 
                "                                        parent=ikfk_group)     ", 
                "", 
                "ik_control = ik_control_hierarchy[-1]", 
                "", 
                "# add the gimbal control", 
                "ik_gimbal_control = rig_control.create(name=ik_control_list[2], ", 
                "                                        controlType=\"sphere\",", 
                "                                        hierarchy=[],", 
                "                                        position=end_joint_pos,", 
                "                                        color=rig_common.MIDBLUE,", 
                "                                        hideAttrs=[\"v\", \"sx\", \"sy\", \"sz\"],", 
                "                                        parent=ik_control)[-1]", 
                "", 
                "# # set the rotate order for the ik controls                                        ", 
                "for control in [ik_control, ik_gimbal_control]:", 
                "    mc.setAttr('{}.rotateOrder'.format(control), ${ik_rotate_order})", 
                "", 
                "mc.xform(ik_gimbal_control, ws=True, matrix=mc.xform(ik_control, q=True, ws=True, matrix=True))", 
                "", 
                "# Movable-pivot control -mjs-mpivot", 
                "ik_mpivot_nul, ik_mpivot_control = rig_control.create(name=ik_control_list[3],", 
                "                                        controlType=\"sphere\",", 
                "                                        hierarchy=['nul'],", 
                "                                        position=end_joint_pos,", 
                "                                        hideAttrs=[\"sx\", \"sy\", \"sz\", \"v\"],", 
                "                                        color=rig_common.MIDBLUE,", 
                "                                        parent=ik_gimbal_control)", 
                "", 
                "# Create group to connect pivot control to", 
                "ik_pivot_grp = mc.createNode('transform', p=ik_gimbal_control, n='{}_grp'.format(ik_mpivot_control))", 
                "mc.connectAttr(ik_mpivot_control+'.rotate', ik_pivot_grp+'.rotate')", 
                "# Use add node to offset the translate so we can move the pivot nul somewhere else", 
                "# and keep the control zeroed out", 
                "add = mc.createNode('plusMinusAverage', n='{}_add'.format(ik_mpivot_nul))", 
                "mc.connectAttr(ik_mpivot_control+'.translate', add+'.input3D[0]')", 
                "mc.connectAttr(ik_mpivot_nul+'.translate', add+'.input3D[1]')", 
                "mc.connectAttr(add+'.output3D', ik_pivot_grp+'.rotatePivot')", 
                "", 
                ""
            ]
        }, 
        "/limb/create/ik/controls/visibility": {
            "enabled": true, 
            "code": [
                "# create ikfk reverse node to connect the ikfk attribute", 
                "ikfk_group = STAGE.ikfk_system.getGroup()", 
                "reverse_node = mc.createNode(\"reverse\", name=\"${name}_rvr\")", 
                "mc.connectAttr(\"{}.ikfk\".format(ikfk_group), \"{}.inputX\".format(reverse_node), f=True)", 
                "", 
                "# setup the visibility and switch", 
                "for ctrl in ${ik_control_list}:", 
                "    # Connect ik/fk state vis switch to the shapes of the controls", 
                "    control_shapes = mc.listRelatives(ctrl, s=1, ni=1)", 
                "    for shape in control_shapes:        ", 
                "        if not mc.isConnected(\"{}.outputX\".format(reverse_node), \"{}.v\".format(shape)):", 
                "            mc.connectAttr(\"{}.outputX\".format(reverse_node), \"{}.v\".format(shape), f=True)"
            ]
        }, 
        "/limb/create/ik/offset": {
            "enabled": true, 
            "code": [
                "# get data from the ikfk system", 
                "fk_joint_list = STAGE.ikfk_system.getFkJointList()", 
                "ik_joint_list = STAGE.ikfk_system.getIkJointList()", 
                "fk_control_list = ${fk_control_list}", 
                "ik_control_list = ${ik_control_list}", 
                "ik_gimbal_control = ik_control_list[2]", 
                "ik_pivot_control = ik_control_list[3]", 
                "ikfk_group = STAGE.ikfk_system.getGroup()", 
                "handle = STAGE.ikfk_system.getHandle()", 
                "", 
                "parent = ikfk_group", 
                "", 
                "# duplicate the end ik joint and make it offset joint for the ", 
                "# ik control to drive the end joint", 
                "# get the fk joint list", 
                "mc.select(clear=True)", 
                "dup_end_joint = mc.joint(name=\"{}_offset\".format(fk_control_list[-2]))", 
                "mc.setAttr('{}.ro'.format(dup_end_joint), mc.getAttr(\"{}.ro\".format(fk_joint_list[-1])))", 
                "# get the aim vector we will be using to set the ik control default rotation", 
                "", 
                "distance = mc.getAttr(\"{}.t\".format(fk_control_list[-2]))[0]", 
                "aim_attr, aim_vector = rig_transform.getDistanceVector(distance)", 
                "# move the dupJnt and setup the tmp joints", 
                "mc.xform(dup_end_joint, ws=True, matrix=mc.xform(fk_control_list[-2], q=True, ws=True, matrix=True))", 
                "mc.setAttr('{}.drawStyle'.format(dup_end_joint), 2)", 
                "mc.setAttr('{}.v'.format(handle), 0)", 
                "# Parent the offset to the movable pivot control -mjs-mpivot", 
                "mc.parent(dup_end_joint, ik_pivot_control+'_grp')", 
                "mc.setAttr('{}.t'.format(dup_end_joint),0,0,0)", 
                "rig_joint.orientToRotate(dup_end_joint)", 
                "mc.setAttr('{}.r'.format(dup_end_joint), *${fk_rotate_offset})", 
                "cst = mc.orientConstraint(dup_end_joint, ik_joint_list[-1])[0]", 
                "#wal = mc.orientConstraint(cst, q=True, wal=True)", 
                "mc.parent(handle, dup_end_joint)", 
                "", 
                "# create the offset joint that will be used for ikfk switching. This is the offset of the", 
                "# ik control from the fk control", 
                "mc.select(clear=True)", 
                "fk_offset_joint = mc.joint(name='{}_offset'.format(ik_control_list[1]))", 
                "mc.xform(fk_offset_joint, ws=True, matrix=mc.xform(ik_control_list[1], q=True, ws=True, matrix=True))", 
                "# turn off the visibility of the offset joint", 
                "mc.setAttr('{}.drawStyle'.format(fk_offset_joint), 2)", 
                "", 
                "# parent the offset joint to the fk wrist control.", 
                "mc.parent(fk_offset_joint, fk_control_list[-1])", 
                "# make sure it's offset exactly the amount set in the ik_rotate_offset attribute", 
                "rig_joint.orientToRotate(fk_offset_joint)", 
                "", 
                "mc.setAttr('{}.r'.format(fk_offset_joint), *${ik_rotate_offset})", 
                "", 
                "# make sure the rig is in fk before adding the stretch so it doesn't move the rig", 
                "mc.setAttr(\"{}.ikfk\".format(ikfk_group), 1)", 
                ""
            ]
        }, 
        "/limb/create/param": {
            "child_order": [
                "stretch", 
                "match_attributes", 
                "proxy_attributes"
            ], 
            "enabled": true, 
            "code": [
                "# get the data needed from the ikfk system", 
                "ikfk_group = STAGE.ikfk_system.getGroup()", 
                "joint_list = ${joint_list}", 
                "", 
                "# create the param node and ikfk attribute for it", 
                "param_node = rig_control.create(name=\"${param_node}\", ", 
                "                    controlType=\"cube\",", 
                "                    hierarchy=[],", 
                "                    transformType=\"joint\",", 
                "                    parent=ikfk_group)[0]", 
                "", 
                "# parent constrain the param node to the last joint in the joint list                    ", 
                "mc.parentConstraint(joint_list[-1], param_node, mo=False)", 
                "", 
                "# lock and hide attributes on the param control.", 
                "rig_attribute.lockAndHide(param_node, (\"tx\",\"ty\",\"tz\",\"rx\",\"ry\",\"rz\",\"sx\",\"sy\",\"sz\",\"v\"))                 ", 
                "", 
                "# lock and hide attributes on the Param node that we don't need.", 
                "mc.addAttr(param_node, ln=\"ikfk\", at=\"double\", min=0, max=1, dv=1, keyable=True)", 
                "", 
                "#connect the param ikfk attr to the ikfk system group ikfk attribute", 
                "mc.connectAttr(\"{}.ikfk\".format(param_node), \"{}.ikfk\".format(ikfk_group), f=True)", 
                "ikfk_attr = \"{}.ikfk\".format(param_node)", 
                "mc.connectAttr(ikfk_attr, \"{}.ikfk\".format(ikfk_group), f=True)", 
                "", 
                "# create ikfk reverse node to connect the ikfk attribute", 
                "reverse_node = mc.createNode(\"reverse\", name=\"{}_rvr\".format(self.name))", 
                "mc.connectAttr(ikfk_attr, \"{}.inputX\".format(reverse_node), f=True)", 
                "", 
                "# set the pvMatch node attribute on the paramNode", 
                "pv_control = ${ik_control_list}[0]", 
                "mc.addAttr(param_node, ln=\"pvMatch\", dt=\"string\")", 
                "mc.setAttr(\"{}.pvMatch\".format(param_node), \"{}_match\".format(pv_control), type=\"string\")"
            ]
        }, 
        "/limb/create/param/match_attributes": {
            "enabled": true, 
            "code": [
                "#------------------------------------------------------------------------------------------", 
                "#Setup attributes on the param node for the ikfk switch.", 
                "#------------------------------------------------------------------------------------------", 
                "param_node = \"${param_node}\"", 
                "ik_joint_list = STAGE.ikfk_system.getIkJointList()", 
                "fk_control_list = ${fk_control_list}", 
                "ik_control_list = ${ik_control_list}", 
                "# fk match attributes needed to the switch", 
                "mc.addAttr(param_node, ln=\"fkMatchTransforms\", dt=\"string\")", 
                "mc.setAttr(\"{}.fkMatchTransforms\".format(param_node), ", 
                "        '[\"{}\",\"{}\",\"{}\"]'.format(fk_control_list[0], fk_control_list[1], \"{}_offset\".format(ik_control_list[1])), ", 
                "        type=\"string\")", 
                "", 
                "mc.addAttr(param_node, ln=\"fkControls\", dt=\"string\")", 
                "mc.setAttr(\"{}.fkControls\".format(param_node), ", 
                "        '[\"{}\",\"{}\",\"{}\",\"{}\"]'.format(*fk_control_list), ", 
                "        type=\"string\")", 
                "", 
                "# ik match attributes needed for the switch", 
                "mc.addAttr(param_node, ln=\"ikMatchTransforms\", dt=\"string\")", 
                "mc.setAttr(\"{}.ikMatchTransforms\".format(param_node), ", 
                "        '[\"{}\",\"{}\",\"{}\"]'.format(ik_joint_list[0], ik_joint_list[1], \"{}_offset\".format(fk_control_list[-2])), ", 
                "        type=\"string\")", 
                "", 
                "mc.addAttr(param_node, ln=\"ikControls\", dt=\"string\")", 
                "mc.setAttr(\"{}.ikControls\".format(param_node), ", 
                "        '[\"{}\",\"{}\", \"{}\",\"{}\"]'.format(*ik_control_list), ", 
                "        type=\"string\")"
            ]
        }, 
        "/limb/create/param/proxy_attributes": {
            "enabled": false, 
            "code": [
                "if ${create_proxy_attributes}:", 
                "    for control in ${fk_control_list}:", 
                "        mc.addAttr(control, ln=\"settings\", at=\"enum\", enumName=\"settings\",keyable=True)", 
                "        rig_attribute.lock(control, ['settings'])", 
                "        mc.addAttr(control, ln=\"ikfk\", at=\"double\", min=0, max=1, dv=0, ", 
                "                    keyable=True, enumName=\"Ik:FK\", proxy='${param_node}.ikfk')", 
                "", 
                "        mc.addAttr(control, ln='stretchTop', at='double', min=0.01, dv=1, ", 
                "                    k=True, proxy='${param_node}.stretchTop')", 
                "        mc.addAttr(control, ln='stretchBottom', at='double', min=0.01, dv=1, ", 
                "                    k=True, proxy='${param_node}.stretchBottom')", 
                "        ", 
                "    for control in ${ik_control_list}:", 
                "        mc.addAttr(control, ln=\"settings\", at=\"enum\", enumName=\"settings\",keyable=True)", 
                "        rig_attribute.lock(control, ['settings'])", 
                "        mc.addAttr(control, ln=\"ikfk\", at=\"double\", min=0, max=1, dv=0, ", 
                "                    keyable=True, enumName=\"Ik:FK\", proxy='${param_node}.ikfk')", 
                "", 
                "        mc.addAttr(control, ln='stretch', at='double', min=0, max=1, dv=0,", 
                "                    k=True, proxy='${param_node}.stretch')", 
                "        mc.addAttr(control, ln='stretchTop', at='double', min=0.01, dv=1, ", 
                "                    k=True, proxy='${param_node}.stretchTop')", 
                "        mc.addAttr(control, ln='stretchBottom', at='double', min=0.01, dv=1, ", 
                "                    k=True, proxy='${param_node}.stretchBottom')", 
                "        mc.addAttr(control, ln='softStretch', at='double', min=0.001, max=1, dv=0.001, ", 
                "                    k=True, proxy='${param_node}.softStretch')", 
                "        mc.addAttr(control, ln='pvPin', at='double', min=0, max=1, dv=1, ", 
                "                    k=True, proxy='${param_node}.pvPin')"
            ]
        }, 
        "/limb/create/param/stretch": {
            "enabled": true, 
            "code": [
                "# set softStretch to zero and zero out fk controls. This will allow the rest of the", 
                "# rig to build properly. We will have to turn these things back on somewhere in the ", 
                "# build later", 
                "# zero out controls", 
                "param_node = \"${param_node}\"", 
                "reverse_node =\"${name}_rvr\"", 
                "name = \"${name}\"", 
                "joint_list = ${joint_list}", 
                "ikfk_group = STAGE.ikfk_system.getGroup()", 
                "handle = STAGE.ikfk_system.getHandle()", 
                "ik_joint_list = STAGE.ikfk_system.getIkJointList()", 
                "fk_control_list = ${fk_control_list}", 
                "ik_control_list = ${ik_control_list}", 
                "", 
                "for control in fk_control_list:", 
                "    mc.setAttr(\"{}.r\".format(control), 0, 0, 0)", 
                "# create the ik stretchy system", 
                "stretch_target_joint_list = rig_ikfk.IKFKLimb.createStretchIK(handle, ikfk_group)", 
                "", 
                "#create attributes on param node and connect them to the grp node", 
                "mc.addAttr(param_node, ln='stretch', at='double', min=0, max=1, dv=0, k=True)", 
                "mc.addAttr(param_node, ln='stretchTop', at='double', min=0, dv = 1, k=True)", 
                "mc.addAttr(param_node, ln='stretchBottom', at='double', min=0, dv = 1, k=True)", 
                "mc.addAttr(param_node, ln='softStretch', at='double', min=0, max=1, dv=0.001, k=True)", 
                "mc.addAttr(param_node, ln='pvPin', at='double', min=0, max=1, dv=0, k=True)", 
                "mc.addAttr(param_node, ln='pvVis', at='long', min=0, max=1, dv=1, k=True)", 
                "#rig_control.tagAsControl(paramNode)", 
                "# add twist attribute to the param node", 
                "mc.addAttr(param_node, ln=\"twist\", at=\"double\", dv=0, keyable=True)", 
                "mc.connectAttr(\"{}.twist\".format(param_node), \"{}.twist\".format(handle), f=True)", 
                "", 
                "for attr in ['stretch','softStretch']:", 
                "    mc.connectAttr('{}.{}'.format(param_node, attr), '{}.{}'.format(ikfk_group, attr), f=True)", 
                "    ", 
                "for attr in ['stretchBottom', 'stretchTop']:", 
                "    pma_node = mc.createNode('plusMinusAverage', name='{}_{}_pma'.format(param_node, attr))", 
                "    mc.connectAttr('{}.{}'.format(param_node, attr), '{}.input1D[0]'.format(pma_node), f=True)", 
                "    mc.setAttr('{}.operation'.format(pma_node), 2)", 
                "    mc.connectAttr('{}.output1D'.format(pma_node), '{}.{}'.format(ikfk_group, attr), f=True)", 
                "", 
                "# connect pvVis to the visibility of the hierarchy of poleVector    ", 
                "mc.connectAttr(\"{}.pvVis\".format(param_node), \"{}.lodv\".format(mc.listRelatives(ik_control_list[0], p=True)[0]), f=True)   ", 
                "", 
                "blend_node = mc.ls(mc.listConnections(ik_joint_list[1], destination=False,source=True,scn=True),type=\"blendColors\")[0]", 
                "multiply_node = mc.createNode(\"multDoubleLinear\", n=\"{}_stretch_mdn\".format(param_node))", 
                "mc.connectAttr(\"{}.stretch\".format(param_node), \"{}.input1\".format(multiply_node),f=True)", 
                "#mc.connectAttr(\"{}.outputX\".format(reverse_node), \"{}.input2\".format(multiply_node), f=True)", 
                "mc.setAttr('{}.input2'.format(multiply_node), 1)", 
                "mc.connectAttr(\"{}.output\".format(multiply_node), \"{}.blender\".format(blend_node), f=True)", 
                "", 
                "# create pvPinning node network ---------------------------------------------------------", 
                "# create the upper and lower distance between nodes.", 
                "upper_limb_decomp = mc.createNode('decomposeMatrix', n=\"{}_upperPvPin_dcm\".format(name))", 
                "pv_decomp = mc.createNode('decomposeMatrix', n=\"{}_PvPin_dcm\".format(name))", 
                "upper_distance_between = mc.createNode('distanceBetween', n=\"{}_upperPvPin_dst\".format(name))", 
                "# make a jnt to use as distance location for upper limb and put it in the same location as upper limb", 
                "upper_dist_joint = mc.joint(n=\"{}_upper_dist_jnt\".format(name))", 
                "mc.xform(upper_dist_joint, ws=True, matrix=mc.xform(fk_control_list[0], q=True, ws=True, matrix=True))", 
                "mc.parent(upper_dist_joint, mc.listRelatives(fk_control_list[0],p=True)[0])", 
                "mc.connectAttr(\"{}.worldMatrix[0]\".format(upper_dist_joint), \"{}.inputMatrix\".format(upper_limb_decomp), f=True)", 
                "mc.connectAttr(\"{}.worldMatrix[0]\".format(ik_control_list[0]), \"{}.inputMatrix\".format(pv_decomp), f=True)", 
                "mc.connectAttr(\"{}.outputTranslate\".format(upper_limb_decomp), \"{}.point1\".format(upper_distance_between), f=True)", 
                "mc.connectAttr(\"{}.outputTranslate\".format(pv_decomp), \"{}.point2\".format(upper_distance_between), f=True)", 
                "", 
                "lower_limb_decomp = mc.createNode('decomposeMatrix', n=\"{}_lowerPvPin_dcm\".format(name))", 
                "lower_distance_between = mc.createNode('distanceBetween', n=\"{}_lowerPvPin_dst\".format(name))", 
                "mc.connectAttr(\"{}.worldMatrix[0]\".format(ik_control_list[1]), \"{}.inputMatrix\".format(lower_limb_decomp), f=True)", 
                "mc.connectAttr(\"{}.outputTranslate\".format(lower_limb_decomp), \"{}.point1\".format(lower_distance_between), f=True)", 
                "mc.connectAttr(\"{}.outputTranslate\".format(pv_decomp), \"{}.point2\".format(lower_distance_between), f=True)", 
                "", 
                "# >>>>>>>>>>>>>>>>>>>>>>>>>>>>", 
                "# connect this blend node to fk joint scale", 
                "# >>>>>>>>>>>>>>>>>>>>>>>>>>>>", 
                "# create the blendColor node for the pvPinning to override the stretch in the limb.", 
                "pv_pin_blend = mc.createNode(\"blendColors\", n=\"{}_pvPin_bcn\".format(name))", 
                "# normalize the outputs so we can put it into the stretch attribute on the joint.", 
                "mult_divide_normalize = mc.createNode(\"multiplyDivide\", n=\"{}_pvPin_mdn\".format(name))", 
                "mc.connectAttr(\"{}.outputR\".format(blend_node), \"{}.input1X\".format(mult_divide_normalize), f=True)", 
                "mc.connectAttr(\"{}.outputG\".format(blend_node), \"{}.input1Y\".format(mult_divide_normalize), f=True)", 
                "", 
                "# set the attributes to normalize the value before it goes into the blend colors node.", 
                "mc.setAttr(\"{}.input2X\".format(mult_divide_normalize), mc.getAttr(\"{}.input1X\".format(mult_divide_normalize)))", 
                "mc.setAttr(\"{}.input2Y\".format(mult_divide_normalize), mc.getAttr(\"{}.input1Y\".format(mult_divide_normalize)))", 
                "", 
                "# set the operation to divide.", 
                "mc.setAttr(\"{}.operation\".format(mult_divide_normalize), 2)", 
                "", 
                "# connect the attributes to the blend colors node.", 
                "mc.connectAttr(\"{}.outputX\".format(mult_divide_normalize), \"{}.color2R\".format(pv_pin_blend), f=True)", 
                "mc.connectAttr(\"{}.outputY\".format(mult_divide_normalize), \"{}.color2G\".format(pv_pin_blend), f=True)", 
                "", 
                "# get the aimVector and aim Attr", 
                "aim_distance = mc.getAttr(\"{}.t\".format(joint_list[1]))[0]", 
                "aim_attr, aim_vector = rig_transform.getDistanceVector(aim_distance)", 
                "# disconnect the translates. We will have to fix this in the stretch later.", 
                "mc.disconnectAttr(\"{}.outputR\".format(blend_node), \"{}.t{}\".format(ik_joint_list[1], aim_attr.strip(\"-\")))", 
                "mc.disconnectAttr(\"{}.outputG\".format(blend_node), \"{}.t{}\".format(ik_joint_list[2], aim_attr.strip(\"-\")))", 
                "", 
                "# make sure if it is a negative direction that we account for that and invert the values", 
                "# coming into the pinning blend node.", 
                "mult_divide_distance_normalize = mc.createNode(\"multiplyDivide\",  n=\"{}_pvDistance_mdn\".format(name))", 
                "mc.setAttr(\"{}.operation\".format(mult_divide_distance_normalize), 2)", 
                "if \"-\" in aim_attr:", 
                "    pv_pin_upper_rvr_mult_double = mc.createNode(\"multDoubleLinear\", n=\"{}_PvPinUpperRvr_mdl\".format(name))", 
                "    pv_pin_lower_rvr_mult_double = mc.createNode(\"multDoubleLinear\", n=\"{}_PvPinLowerRvr_mdl\".format(name))", 
                "    mc.connectAttr(\"{}.distance\".format(upper_distance_between), \"{}.input1\".format(pv_pin_upper_rvr_mult_double), f=True)", 
                "    mc.connectAttr(\"{}.distance\".format(lower_distance_between), \"{}.input1\".format(pv_pin_lower_rvr_mult_double), f=True)", 
                "", 
                "    for node in (pv_pin_lower_rvr_mult_double, pv_pin_upper_rvr_mult_double):", 
                "        mc.setAttr(\"{}.input2\".format(node), -1)", 
                "", 
                "    mc.connectAttr(\"{}.output\".format(pv_pin_upper_rvr_mult_double), \"{}.input1X\".format(mult_divide_distance_normalize), f=True)", 
                "    mc.connectAttr(\"{}.output\".format(pv_pin_lower_rvr_mult_double), \"{}.input1Y\".format(mult_divide_distance_normalize), f=True)", 
                "else:", 
                "    mc.connectAttr(\"{}.distance\".format(upper_distance_between), \"{}.input1X\".format(mult_divide_distance_normalize), f=True)", 
                "    mc.connectAttr(\"{}.distance\".format(lower_distance_between), \"{}.input1Y\".format(mult_divide_distance_normalize), f=True)", 
                "", 
                "mc.connectAttr(\"{}.outputX\".format(mult_divide_distance_normalize), \"{}.color1R\".format(pv_pin_blend), f=True)", 
                "mc.connectAttr(\"{}.outputY\".format(mult_divide_distance_normalize), \"{}.color1G\".format(pv_pin_blend), f=True)", 
                "# set the attributes to normalize the value before it goes into the blend colors node.", 
                "mc.setAttr(\"{}.input2X\".format(mult_divide_distance_normalize), mc.getAttr(\"{}.input1X\".format(mult_divide_normalize)))", 
                "mc.setAttr(\"{}.input2Y\".format(mult_divide_distance_normalize), mc.getAttr(\"{}.input1Y\".format(mult_divide_normalize)))", 
                "", 
                "# set the operation to divide.", 
                "mc.setAttr(\"{}.operation\".format(mult_divide_distance_normalize), 2)", 
                "", 
                "# create the multiplier to have pvPinning on during IK only and pinning on", 
                "pv_pin_mult_double = mc.createNode(\"multDoubleLinear\", n=\"{}_PvPin_mdl\".format(name))", 
                "mc.connectAttr(\"{}.pvPin\".format(param_node), \"{}.input1\".format(pv_pin_mult_double), f=True)", 
                "mc.connectAttr(\"{}.outputX\".format(reverse_node), \"{}.input2\".format(pv_pin_mult_double), f=True)", 
                "# connect the blend colors node to both ik joints and fk controls scale attributes", 
                "mc.connectAttr(\"{}.output\".format(pv_pin_mult_double), \"{}.blender\".format(pv_pin_blend), f=True)", 
                "", 
                "# connect the stretch to the blend", 
                "distance_top_bottom_bcn = mc.createNode('blendColors', name='{}_distance_top_bottom_bcn'.format(param_node))", 
                "mc.connectAttr(\"{}.output\".format(pv_pin_mult_double), \"{}.blender\".format(distance_top_bottom_bcn), f=True)", 
                "mc.connectAttr('{}.outputX'.format(mult_divide_distance_normalize), '{}.color1R'.format(distance_top_bottom_bcn), f=True)", 
                "mc.connectAttr('{}.outputY'.format(mult_divide_distance_normalize), '{}.color1G'.format(distance_top_bottom_bcn), f=True)", 
                "mc.connectAttr('{}.stretchTop'.format(param_node), '{}.color2R'.format(distance_top_bottom_bcn), f=True)", 
                "mc.connectAttr('{}.stretchBottom'.format(param_node), '{}.color2G'.format(distance_top_bottom_bcn), f=True)", 
                "", 
                "pin_distance_bcn = mc.createNode('blendColors', name='{}_pin_distance_bcn'.format(param_node))", 
                "mc.connectAttr('{}.output'.format(pv_pin_blend), '{}.color1'.format(pin_distance_bcn), f=True)", 
                "mc.connectAttr('{}.output'.format(distance_top_bottom_bcn), '{}.color2'.format(pin_distance_bcn), f=True)", 
                "mc.connectAttr('{}.stretch'.format(param_node), '{}.blender'.format(pin_distance_bcn), f=True)", 
                "", 
                "# Connect the stretch blend output to the joint chains", 
                "mc.connectAttr('{}.outputR'.format(pin_distance_bcn), '{}.s{}'.format(ik_joint_list[0], aim_attr.strip(\"-\")), f=True)", 
                "mc.connectAttr('{}.outputG'.format(pin_distance_bcn), '{}.s{}'.format(ik_joint_list[1], aim_attr.strip(\"-\")), f=True)", 
                "", 
                "# this will connect the param stretch  top and bottom to the fk controls", 
                "mc.connectAttr(\"{}.stretchTop\".format(param_node), \"{}.s{}\".format(fk_control_list[0], aim_attr.strip(\"-\")), f=True)", 
                "mc.connectAttr(\"{}.stretchBottom\".format(param_node), \"{}.s{}\".format(fk_control_list[1], aim_attr.strip(\"-\")), f=True)", 
                "mc.parent(stretch_target_joint_list[-1], \"{}_offset\".format(fk_control_list[-2]))", 
                "", 
                "STAGE.stretch_target_joint_list = stretch_target_joint_list", 
                ""
            ]
        }, 
        "/limb/fk_spaces": {
            "instance": "/space_switch", 
            "enabled": true
        }, 
        "/limb/ik_spaces": {
            "instance": "/space_switch", 
            "enabled": true
        }, 
        "/limb/set_control_defaults": {
            "child_order": [
                "set_fk_controls", 
                "set_ik_controls", 
                "set_joint_orients"
            ]
        }, 
        "/limb/set_control_defaults/set_fk_controls": {
            "code": [
                "for i, control in enumerate(self.fk_control_list[:-1]):", 
                "    mc.xform(control, ws=True, matrix=STAGE.bind_pose_positions[i])", 
                "    #mc.setAttr('{}.r'.format(control), *STAGE.bind_pose_rotations[i])"
            ]
        }, 
        "/limb/set_control_defaults/set_ik_controls": {
            "code": [
                "# # set the ik control back to original point in space it was built at.", 
                "#mc.xform(self.ik_control_list[1], ws=True, matrix=mc.xform('{}_offset'.format(self.ik_control_list[1]), q=True, ws=True, matrix=True))", 
                "rig_ikfk.IKFKLimb.ikMatchFk(self.fk_control_list[:-2] +['{}_offset'.format(self.ik_control_list[1])] , self.ik_control_list[1], self.ik_control_list[0], '{}_match'.format(self.ik_control_list[0]))"
            ]
        }, 
        "/limb/set_control_defaults/set_joint_orients": {
            "enabled": false, 
            "code": [
                "rig_joint.rotateToOrient(STAGE.ikfk_system.getIkJointList())", 
                "rig_joint.rotateToOrient(STAGE.ikfk_system.getFkJointList())", 
                "rig_joint.rotateToOrient(STAGE.ikfk_system.blendJointList())", 
                "rig_joint.rotateToOrient(self.joint_list)"
            ]
        }, 
        "/limb/set_zero_pose": {
            "comment": "This node is used to set the limb joints to be zero orientation and record their original positions.", 
            "code": [
                "# create a stage variable to store the positions for matrix of the joints", 
                "STAGE.bind_pose_positions = [mc.xform(joint, q=True, ws=True, matrix=True) for joint in ${joint_list}]", 
                "# zero out the rest of the orientations on the joints", 
                "for joint in self.joint_list:", 
                "    mc.xform(joint, ws=True, rotation=${world_orient_offset})"
            ]
        }, 
        "/look_at": {
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "anchor": {
                    "type": "str", 
                    "value": "'face_upper'"
                }, 
                "component_parent": {
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "eye_anchor_joint_list": {
                    "type": "list", 
                    "value": "['eyeSocket_l_bind', 'eyeSocket_r_bind']"
                }, 
                "eye_anchor_list": {
                    "type": "list", 
                    "value": "['eyeSocket_l', 'eyeSocket_r']"
                }, 
                "eye_control_list": {
                    "type": "list", 
                    "value": "['eye_l', 'eye_r']"
                }, 
                "eye_joint_list": {
                    "type": "list", 
                    "value": "['eye_l_bind', 'eye_r_bind']"
                }, 
                "look_at_rot": {
                    "type": "str", 
                    "value": "'lookAt_rot'"
                }, 
                "look_at_trs": {
                    "type": "str", 
                    "value": "'lookAt_trs'"
                }, 
                "name": {
                    "type": "raw", 
                    "value": "lookAt"
                }
            }
        }, 
        "/look_at/create": {
            "child_order": [
                "look_at_trs", 
                "look_at_rot", 
                "space_switch"
            ], 
            "enabled": true, 
            "code": [
                "mc.createNode('transform', n='${name}')", 
                "mc.parent('${name}', ${anchor})"
            ]
        }, 
        "/look_at/create/look_at_rot": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "position", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "control_name": {
                    "type": "raw", 
                    "value": "${look_at_rot}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'diamond'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['rz', 't', 'tx', 'ty', 'tz', 's', 'sx', 'sy', 'sz', 'v']"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'aim']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'${name}'"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/look_at/create/look_at_rot/connect": {
            "enabled": true, 
            "code": [
                "# aim constraint the lookAtRot control to the lookAt control", 
                "mc.aimConstraint(${look_at_trs}, '{}_aim'.format(${look_at_rot}), offset=(0, 0 ,0), weight=1, aimVector=(0, 0, 1), upVector= (0, 1, 0), wut=\"none\")", 
                "", 
                "# make the individual eye controls", 
                "for i, joint in enumerate(${eye_joint_list}):", 
                "    eye_socket_nul, eye_socket_ctrl = rig_control.create(name=${eye_anchor_list}[i], ", 
                "                                          controlType=\"null\",", 
                "                                          color=rig_common.YELLOW,", 
                "                                          hierarchy=['nul'],", 
                "                                          parent=${anchor},", 
                "                                          type=${type})", 
                "                                          ", 
                "    mc.xform(eye_socket_nul, ws=True, t=mc.xform(joint, q=True, ws=True, t=True))", 
                "    #point, orient constraint the socket joint to the socket control. Also connect scale", 
                "    mc.parentConstraint(eye_socket_ctrl, ${eye_anchor_joint_list}[i])", 
                "    mc.scaleConstraint(eye_socket_ctrl, ${eye_anchor_joint_list}[i])", 
                "    ", 
                "    eye_nul, eye_ort, eye_def_auto, eye_ctrl = rig_control.create(name=${eye_control_list}[i], ", 
                "                                                              controlType=\"circle\",", 
                "                                                              color=${color},", 
                "                                                              hierarchy=['nul', 'ort', 'def_auto'],", 
                "                                                              parent=${eye_anchor_list}[i],", 
                "                                                              type=${type})", 
                "", 
                "    rig_attribute.lockAndHide(eye_ctrl,['t', 'tx', 'ty', 'tz', 's', 'sx', 'sy', 'sz'])", 
                "", 
                "    mc.xform(eye_nul, ws=True, matrix=mc.xform(joint, q=True, ws=True, matrix=True))", 
                "    #mc.pointConstraint(eyeCtrl, joint)", 
                "    mc.orientConstraint(eye_ctrl, joint)", 
                "", 
                "    offset_joint = mc.duplicate(joint, name=\"{}_offset\".format(joint), rr=True, po=True)[0]", 
                "    mc.setAttr(\"{}.drawStyle\".format(offset_joint), 2)", 
                "    mc.parent(offset_joint, ${look_at_rot})", 
                "    mc.orientConstraint(offset_joint, eye_ort)"
            ]
        }, 
        "/look_at/create/look_at_rot/position": {
            "enabled": true, 
            "code": [
                "rig_transform.alignTranslate('{}_nul'.format(${control_name}), ${eye_joint_list})", 
                ""
            ]
        }, 
        "/look_at/create/look_at_trs": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "position"
            ], 
            "enabled": true, 
            "attrs": {
                "control_name": {
                    "type": "raw", 
                    "value": "${look_at_trs}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'square'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['r', 'rx', 'ry', 'rz', 's', 'sx', 'sy', 'sz', 'v']"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'ort']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'${name}'"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/look_at/create/look_at_trs/position": {
            "enabled": true, 
            "code": [
                "rig_transform.alignTranslate('{}_nul'.format(${control_name}), ${eye_joint_list})", 
                "# move the lookAt out in positive Z space", 
                "mc.xform('{}_ort'.format(${look_at_trs}), relative=True, t=(0, 0, 2))"
            ]
        }, 
        "/look_at/create/space_switch": {
            "instance": "/space_switch", 
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "raw", 
                    "value": "${look_at_trs}"
                }, 
                "constraint_node": {
                    "type": "raw", 
                    "value": "${look_at_trs}+'_nul'"
                }, 
                "constraint_type": {
                    "type": "str", 
                    "value": "'parent'"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "['world']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${component_parent}"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "['rig']"
                }
            }
        }, 
        "/mouth": {
            "child_order": [
                "create", 
                "lip_main", 
                "lip", 
                "rig_sets", 
                "bind_geometry"
            ], 
            "enabled": "/", 
            "comment": "This is the top node for the mouth rig", 
            "attrs": {
                "center_upper_cv_index": {
                    "type": "int", 
                    "value": "1"
                }, 
                "component_parent": {
                    "comment": "Name of node you want to parent the component to.", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "geometry": {
                    "comment": "Geometry that we will use to create wire deformers.", 
                    "type": "str", 
                    "value": "'body_geo'"
                }, 
                "head_pin": {
                    "comment": "Anchor you want to use for the pinning of the head", 
                    "type": "str", 
                    "value": "'face_mid_bind'"
                }, 
                "jaw_pin": {
                    "comment": "Anchor you want to use for the pinning of the jaw", 
                    "type": "str", 
                    "value": "'jaw_bind'"
                }, 
                "lip_curve": {
                    "comment": "Name of the curve used for the secondary deformation of the mouth. This is what the tweakers will drive.", 
                    "type": "str", 
                    "value": "'lip_curve'"
                }, 
                "lip_main_curve": {
                    "comment": "Name of the curve that will be used for the main deformermation of the mouth", 
                    "type": "str", 
                    "value": "'lip_main_curve'"
                }, 
                "lip_main_prefix": {
                    "comment": "Prefix for the naming of the control and other parts of the rig for lip_main", 
                    "type": "str", 
                    "value": "'lip_main'"
                }, 
                "lip_prefix": {
                    "comment": "Prefix for the naming of the control and other parts of the rig for lip", 
                    "type": "str", 
                    "value": "'lip'"
                }, 
                "name": {
                    "comment": "name of the component. This will be used to create a group and store this components data unless specified otherwise.", 
                    "type": "raw", 
                    "value": "mouth"
                }, 
                "orient_file": {
                    "comment": "path to the orients for the controls where the mouth controls are stored", 
                    "type": "str", 
                    "value": "''"
                }, 
                "system_parent": {
                    "comment": "Name for the group that will store the mouth wire rig system", 
                    "type": "str", 
                    "value": "'${name}'"
                }
            }
        }, 
        "/mouth/bind_geometry": {
            "enabled": true, 
            "code": [
                "for prefix, curve in zip([${lip_main_prefix}, ${lip_prefix}],[${lip_main_curve}, ${lip_curve}]):", 
                "    wire_deformer = \"{}_wire\".format(prefix)", 
                "    if mc.objExists(wire_deformer):", 
                "        mc.deformer(wire_deformer, e=1, g=${geometry})", 
                "    else:", 
                "        wire_deformer = mc.wire(${geometry}, gw=False, en=1.00, ce=0.00, li=0.00, ", 
                "                        w=curve, name=\"{}_wire\".format(prefix))[0]", 
                "        # set the default values for the wire deformer", 
                "        mc.setAttr(\"{}.rotation\".format(wire_deformer), 0)", 
                "        mc.setAttr(\"{}.dropoffDistance[0]\".format(wire_deformer), 100)", 
                "", 
                "bind_joint_list = list(set(mc.ls(\"lip_*_baseCurve_jnt\")).difference(set(mc.ls(\"lip_main_*_baseCurve_jnt\"))))", 
                "skincluster = mc.skinCluster(*bind_joint_list + [\"lip_curveBaseWire\"],", 
                "                                rui=False,", 
                "                                tsb=True,", 
                "                                name=\"lip_curveBaseWire_skinCluster\")[0]", 
                "", 
                "for jnt in bind_joint_list:", 
                "    index = [int(s) for s in jnt.split(\"_\") if s.isdigit()][0]", 
                "    mc.skinPercent(skincluster, \"lip_curveBaseWire.cv[{}]\".format(index), tv=[\"lip_{}_baseCurve_jnt\".format(index), 1])", 
                ""
            ]
        }, 
        "/mouth/create": {
            "enabled": true, 
            "code": [
                "# creating this variable so we only have to resolve the data once.", 
                "name = '${name}'", 
                "if not mc.objExists(name):", 
                "    mc.createNode(\"transform\", name=name)", 
                "", 
                "# parent the system to the component group if it exists", 
                "if mc.objExists(${component_parent}):", 
                "    mc.parent(name, ${component_parent})"
            ]
        }, 
        "/mouth/lip": {
            "child_order": [
                "create", 
                "tweak_controls", 
                "bindmesh_bind"
            ], 
            "enabled": true, 
            "comment": "Parent node for the lip tweaker setup"
        }, 
        "/mouth/lip/bindmesh_bind": {
            "enabled": true, 
            "code": [
                "#deform the lip bindmesh with the lip_main curve using a wire deformer.", 
                "wire_deformer = mc.wire(STAGE.lip_bindmesh_geometry, gw=False, en=1.00, ce=0.00, li=0.00,", 
                "        w=${lip_main_curve}, name=\"{}_wire\".format(${lip_main_prefix}))[0]", 
                "", 
                "# set the default values for the wire deformer", 
                "mc.setAttr(\"{}.rotation\".format(wire_deformer), 0)", 
                "mc.setAttr(\"{}.dropoffDistance[0]\".format(wire_deformer), 100)", 
                "", 
                "# create skinCluster for the base wire", 
                "base_curve = \"{}BaseWire\".format(${lip_main_curve})", 
                "lip_main_base_curve_skin = mc.skinCluster(*STAGE.lip_main_base_curve_joint_list+mc.ls(base_curve),", 
                "                            n=\"{}_skinCluster\".format(base_curve),", 
                "                            tsb=True)[0]", 
                "", 
                "# set the weights to have proper weighting", 
                "weight_object = rig_weights.getWeights(lip_main_base_curve_skin)", 
                "weight_list = list()", 
                "for i, inf in enumerate(weight_object):", 
                "    array = numpy.zeros_like(weight_object.getWeights(inf))[0]", 
                "    array[i] = 1", 
                "    weight_list.append(array)", 
                "", 
                "# set the weights to the weight object before setting it on the skinCluster", 
                "weight_object.setWeights(weight_list)", 
                "", 
                "# set the weights for the base curve", 
                "rig_weights.setWeights(lip_main_base_curve_skin, weight_object)"
            ]
        }, 
        "/mouth/lip/create": {
            "child_order": [
                "rename_controls"
            ], 
            "enabled": true, 
            "code": [
                "# control prefix for the lips", 
                "bindmesh_geometry, follicle_list, control_hierarchy_list, joint_list, base_curve_joint_list = rig_wire.buildCurveRig(${lip_curve}, ${lip_prefix} , parent=${system_parent}, hierarchy=['nul','ort', 'rot_def_auto', 'def_auto'], control_shape='null', control_type='face')", 
                "", 
                "STAGE.lip_bindmesh_geometry = bindmesh_geometry", 
                "STAGE.lip_follicle_list = follicle_list", 
                "STAGE.lip_control_hierarchy_list = control_hierarchy_list", 
                "STAGE.lip_joint_list = joint_list", 
                "STAGE.lip_base_curve_joint_list = base_curve_joint_list"
            ]
        }, 
        "/mouth/lip/create/rename_controls": {
            "code": [
                "# get the list of cv's on the curve", 
                "cv_list = mc.ls('{}.cv[*]'.format(${lip_curve}), fl=True)", 
                "cv_index_list = [i for i in xrange(len(cv_list))]", 
                "# use this index to figure out the names of the corners and the upper and lower controls", 
                "cv_center_upper_index = ${center_upper_cv_index}", 
                "cv_center_lower_index = int(len(cv_list) *.5 + cv_center_upper_index)", 
                "cv_right_corner_index = int(len(cv_list) * .25 + cv_center_upper_index)", 
                "cv_left_corner_index = int(len(cv_list) * .75 + cv_center_upper_index)", 
                "", 
                "# make sure to append the difference at the end.", 
                "cv_index_list = cv_index_list[cv_center_upper_index:] + cv_index_list[:cv_center_upper_index]", 
                "", 
                "# setup the name mapping", 
                "cv_list_upper_right_index = cv_index_list[cv_center_upper_index:cv_right_corner_index-1]", 
                "cv_list_upper_right_index.reverse()", 
                "cv_list_lower_right_index = cv_index_list[cv_right_corner_index:cv_center_lower_index-1]", 
                "cv_list_lower_left_index = cv_index_list[cv_center_lower_index:cv_left_corner_index-1]", 
                "cv_list_lower_left_index.reverse()", 
                "cv_list_upper_left_index = cv_index_list[cv_left_corner_index:]", 
                "", 
                "control_prefix = ${lip_prefix}", 
                "", 
                "# center upper control", 
                "control_hierarchy = STAGE.lip_control_hierarchy_list[cv_center_upper_index]", 
                "STAGE.lip_control_hierarchy_list[cv_center_upper_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_center_up\")) for ctrl in control_hierarchy]", 
                "# center lower control", 
                "control_hierarchy = STAGE.lip_control_hierarchy_list[cv_center_lower_index]", 
                "STAGE.lip_control_hierarchy_list[cv_center_lower_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_center_low\")) for ctrl in control_hierarchy]", 
                "# left corner control", 
                "control_hierarchy = STAGE.lip_control_hierarchy_list[cv_left_corner_index]", 
                "STAGE.lip_control_hierarchy_list[cv_left_corner_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_corner_l\")) for ctrl in control_hierarchy]", 
                "# right corner control", 
                "control_hierarchy = STAGE.lip_control_hierarchy_list[cv_right_corner_index]", 
                "STAGE.lip_control_hierarchy_list[cv_right_corner_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_corner_r\")) for ctrl in control_hierarchy]", 
                "# upper right control list", 
                "i = 0", 
                "for index in cv_list_upper_left_index:", 
                "    control_hierarchy = STAGE.lip_control_hierarchy_list[index]", 
                "    STAGE.lip_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_up_{}_l\".format(i))) for ctrl in control_hierarchy]", 
                "    i += 1", 
                "# upper right control list", 
                "i = 0", 
                "for index in cv_list_upper_right_index:", 
                "    control_hierarchy = STAGE.lip_control_hierarchy_list[index]", 
                "    STAGE.lip_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_up_{}_r\".format(i))) for ctrl in control_hierarchy]    ", 
                "    i += 1    ", 
                "# lowere left control list", 
                "i = 0", 
                "for index in cv_list_lower_left_index:", 
                "    control_hierarchy = STAGE.lip_control_hierarchy_list[index]", 
                "    STAGE.lip_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_low_{}_l\".format(i))) for ctrl in control_hierarchy]    ", 
                "    i += 1    ", 
                "# lower right control list", 
                "i = 0", 
                "for index in cv_list_lower_right_index:", 
                "    control_hierarchy = STAGE.lip_control_hierarchy_list[index]", 
                "    STAGE.lip_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lip_low_{}_r\".format(i))) for ctrl in control_hierarchy]    ", 
                "    i += 1    ", 
                "# parent the curves to their respective systems", 
                "mc.parent(${lip_curve}, '{}_grp'.format(${lip_prefix}))"
            ]
        }, 
        "/mouth/lip/tweak_controls": {
            "enabled": true, 
            "comment": "This will setup the cluster part of the tweakers controls", 
            "code": [
                "# Set the right side nuls to be mirrored", 
                "for control_list in STAGE.lip_control_hierarchy_list + \\", 
                "             STAGE.lip_main_control_hierarchy_list + \\", 
                "             STAGE.corner_control_hierarchy_list:", 
                "    nul = control_list[0]", 
                "    if nul.endswith('_r_nul'):", 
                "        mc.setAttr(nul+'.ry', -180)", 
                "        mc.setAttr(nul+'.sz', -1)"
            ]
        }, 
        "/mouth/lip_main": {
            "child_order": [
                "create", 
                "control_names", 
                "load_orient_file", 
                "pinning", 
                "setup_sdk"
            ], 
            "enabled": "/mouth", 
            "comment": "This is the parent node for the lip main rig setup"
        }, 
        "/mouth/lip_main/control_names": {
            "comment": "This will rename the controls based on the cv index of the curve provided", 
            "code": [
                "# get the list of cv's on the curve", 
                "cv_list = mc.ls('{}.cv[*]'.format(${lip_main_curve}), fl=True)", 
                "cv_index_list = [i for i in xrange(len(cv_list))]", 
                "# use this index to figure out the names of the corners and the upper and lower controls", 
                "cv_center_upper_index = ${center_upper_cv_index}", 
                "cv_center_lower_index = int(len(cv_list) *.5 + cv_center_upper_index)", 
                "cv_right_corner_index = int(len(cv_list) * .25 + cv_center_upper_index)", 
                "cv_left_corner_index = int(len(cv_list) * .75 + cv_center_upper_index)", 
                "", 
                "# make sure to append the difference at the end.", 
                "cv_index_list = cv_index_list[cv_center_upper_index:] + cv_index_list[:cv_center_upper_index]", 
                "", 
                "# setup the name mapping", 
                "cv_list_upper_right_index = cv_index_list[cv_center_upper_index:cv_right_corner_index-1]", 
                "cv_list_upper_right_index.reverse()", 
                "cv_list_lower_right_index = cv_index_list[cv_right_corner_index:cv_center_lower_index-1]", 
                "cv_list_lower_left_index = cv_index_list[cv_center_lower_index:cv_left_corner_index-1]", 
                "cv_list_lower_left_index.reverse()", 
                "cv_list_upper_left_index = cv_index_list[cv_left_corner_index:]", 
                "", 
                "# # set the variable for the base curve joint list", 
                "main_base_curve_joint_list = STAGE.lip_main_base_curve_joint_list", 
                "lip_main_control_hierarchy_list = STAGE.lip_main_control_hierarchy_list", 
                "# create a bindMesh for mouth corner controls.", 
                "corner_pos = [mc.xform(cv_list[cv_left_corner_index], q=True, ws=True, t=True),", 
                "                mc.xform(cv_list[cv_right_corner_index], q=True, ws=True, t=True)]", 
                "", 
                "# create the bindmesh ", 
                "bindmesh_geometry, follicle_list = rig_bindmesh.create(\"{}_corner\".format('${name}'), corner_pos)", 
                "", 
                "# lock and hide the mouth corner controls", 
                "for ctrl in mc.ls(\"mouth_corner_?\"):", 
                "    rig_attribute.lockAndHide(ctrl, ['r', 'rx', 'ry', 'rz', 's', 'sx', 'sy', 'sz'])", 
                "", 
                "# # set the visibility of the bindmesh", 
                "mc.setAttr(\"{}.v\".format(bindmesh_geometry), 0 )", 
                "mouth_corner_l_follicle = mc.rename(follicle_list[0], follicle_list[0].replace('_0_','_l_'))", 
                "mouth_corner_r_follicle = mc.rename(follicle_list[1], follicle_list[1].replace('_1_','_r_'))", 
                "", 
                "# set these variables on the stage so we can grab them later", 
                "STAGE.mouth_corner_l_follicle = mouth_corner_l_follicle", 
                "STAGE.mouth_corner_r_follicle = mouth_corner_r_follicle", 
                "STAGE.mouth_corner_bindmesh_geometry = bindmesh_geometry", 
                "", 
                "mc.parent([mouth_corner_l_follicle, mouth_corner_r_follicle, bindmesh_geometry], '${name}')", 
                "", 
                "control_prefix = ${lip_main_prefix}", 
                "", 
                "# center upper control", 
                "control_hierarchy = STAGE.lip_main_control_hierarchy_list[cv_center_upper_index]", 
                "STAGE.lip_main_control_hierarchy_list[cv_center_upper_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_center_up\")) for ctrl in control_hierarchy]", 
                "# center lower control", 
                "control_hierarchy = STAGE.lip_main_control_hierarchy_list[cv_center_lower_index]", 
                "STAGE.lip_main_control_hierarchy_list[cv_center_lower_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_center_low\")) for ctrl in control_hierarchy]", 
                "# left corner control", 
                "control_hierarchy = STAGE.lip_main_control_hierarchy_list[cv_left_corner_index]", 
                "STAGE.lip_main_control_hierarchy_list[cv_left_corner_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_corner_l\")) for ctrl in control_hierarchy]", 
                "# right corner control", 
                "control_hierarchy = STAGE.lip_main_control_hierarchy_list[cv_right_corner_index]", 
                "STAGE.lip_main_control_hierarchy_list[cv_right_corner_index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_corner_r\")) for ctrl in control_hierarchy]", 
                "# upper right control list", 
                "i = 0", 
                "for index in cv_list_upper_left_index:", 
                "    control_hierarchy = STAGE.lip_main_control_hierarchy_list[index]", 
                "    STAGE.lip_main_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_up_{}_l\".format(i))) for ctrl in control_hierarchy]", 
                "    i += 1", 
                "", 
                "# upper right control list", 
                "i = 0", 
                "for index in cv_list_upper_right_index:", 
                "    control_hierarchy = STAGE.lip_main_control_hierarchy_list[index]", 
                "    STAGE.lip_main_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_up_{}_r\".format(i))) for ctrl in control_hierarchy]    ", 
                "    i += 1 ", 
                "    ", 
                "# lowere left control list", 
                "i = 0", 
                "for index in cv_list_lower_left_index:", 
                "    control_hierarchy = STAGE.lip_main_control_hierarchy_list[index]", 
                "    STAGE.lip_main_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_low_{}_l\".format(i))) for ctrl in control_hierarchy]    ", 
                "    i += 1", 
                "    ", 
                "# lower right control list", 
                "i = 0", 
                "for index in cv_list_lower_right_index:", 
                "    control_hierarchy = STAGE.lip_main_control_hierarchy_list[index]", 
                "    STAGE.lip_main_control_hierarchy_list[index] = [mc.rename(ctrl, \"_\".join([name for name in ctrl.split(\"_\") if not name.isdigit()]).replace(control_prefix, \"lipMain_low_{}_r\".format(i))) for ctrl in control_hierarchy]    ", 
                "    i += 1", 
                "# parent the curves to their respective systems", 
                "mc.parent(${lip_main_curve}, '{}_grp'.format(${lip_main_prefix}))"
            ]
        }, 
        "/mouth/lip_main/create": {
            "enabled": true, 
            "comment": "This node will create the lip_main curve rig setup", 
            "code": [
                "bindmesh_geometry, follicle_list, lip_main_control_hierarchy_list, joint_list, base_curve_joint_list = rig_wire.buildCurveRig(${lip_main_curve}, ${lip_main_prefix} , parent=${system_parent}, hierarchy=['nul','ort', 'rot_def_auto', 'def_auto'], control_shape='null', control_type='face')", 
                "# delete the controls, parent joint to the node above the control", 
                "for jnt, lip_main_control_list in zip(joint_list, lip_main_control_hierarchy_list):", 
                "    # hide the base curve joint. Then parent it under the null node", 
                "    base_curve_joint = base_curve_joint_list[joint_list.index(jnt)]", 
                "    mc.setAttr(\"{}.v\".format(base_curve_joint), 0)", 
                "    mc.parent(base_curve_joint, lip_main_control_list[1])", 
                "    #mc.setAttr(\"{}.t\".format(base_curve_joint), 0, 0, 0)", 
                "    mc.parent(jnt,lip_main_control_list[-2])", 
                "    mc.delete(lip_main_control_list.pop(-1))", 
                "", 
                "", 
                "# put the variables on the STAGE so we can grab them later in the build", 
                "STAGE.lip_main_bindmesh_geometry = bindmesh_geometry", 
                "STAGE.lip_main_follicle_list = follicle_list", 
                "STAGE.lip_main_control_hierarchy_list = lip_main_control_hierarchy_list", 
                "STAGE.lip_main_joint_list = joint_list", 
                "STAGE.lip_main_base_curve_joint_list = base_curve_joint_list"
            ]
        }, 
        "/mouth/lip_main/load_orient_file": {
            "enabled": "/mouth/lip_main/create", 
            "comment": "Node is used for loading the orient file if it exists on disk.", 
            "code": [
                "# create the controls", 
                "# If there is a hierarchy argument passed in. We will loop through and create the hiearchy.", 
                "# move the orients", 
                "STAGE.node_data_obj = None", 
                "filepath_list = rig_common.toList(${orient_file})", 
                "for filepath in filepath_list:", 
                "    comp = False", 
                "    if os.path.isfile(filepath):", 
                "        if comp:", 
                "            new_data_obj = node_data.NodeData()", 
                "            new_data_obj.read(filepath)", 
                "            STAGE.node_data_obj = new_data_obj + STAGE.node_data_obj", 
                "        else:", 
                "            STAGE.node_data_obj = node_data.NodeData()", 
                "            STAGE.node_data_obj.read(filepath)"
            ]
        }, 
        "/mouth/lip_main/pinning": {
            "enabled": "/mouth/lip_main/create", 
            "comment": "This node will setup the pinning for the mouth rig", 
            "code": [
                "#pinning", 
                "STAGE.driver_mouth_corners = []", 
                "STAGE.anim_mouth_corners = []", 
                "STAGE.corner_control_hierarchy_list = []", 
                "jaw_pin_list = []", 
                "head_pin_list = []", 
                "for follicle in (STAGE.mouth_corner_l_follicle, STAGE.mouth_corner_r_follicle):", 
                "    parent = follicle", 
                "    control_name = follicle.split(\"_follicle\")[0]", 
                "    # Main mouth corner control", 
                "    # create the control with a large enough hierarchy to create proper SDK's", 
                "    control_hierarchy = rig_control.create(name=control_name, ", 
                "        controlType=\"square\", ", 
                "        hierarchy=['nul','ort', 'auto'], ", 
                "        color=rig_common.BLACK,", 
                "        parent=parent,", 
                "        type='face')", 
                "    rig_attribute.lockAndHide(control_hierarchy[-1], ['r', 'rx', 'ry', 'rz', 's', 'sx', 'sy', 'sz'])", 
                "    STAGE.corner_control_hierarchy_list.append(control_hierarchy)", 
                "    STAGE.anim_mouth_corners.append(control_name)", 
                "    driver_mouth_corner = mc.createNode(\"joint\", name=\"{}_driver\".format(control_name))", 
                "    STAGE.driver_mouth_corners.append(driver_mouth_corner)", 
                "    # mover the driver to the orient and parent it under the orient", 
                "    mc.parent(driver_mouth_corner, control_hierarchy[1])", 
                "    #mc.xform(driver_mouth_corner, ws=True, matrix=mc.xform(control_hierarchy[1], q=True, ws=True, matrix=True))", 
                "    ", 
                "    # turn off the visibility of the driver", 
                "    mc.setAttr(\"{}.drawStyle\".format(driver_mouth_corner), 2)", 
                "    # turn on the handle for the mouth corner control and move it ", 
                "    mc.setAttr(\"{}.displayHandle\".format(control_hierarchy[-1]), 1)", 
                "    mc.setAttr(\"{}.selectHandleX\".format(control_hierarchy[-1]) ,0.2)", 
                "    # zero out the mouth corner hierarchy so it's in the correct position.", 
                "    mc.setAttr(\"{}.translate\".format(control_hierarchy[0]), 0,0,0)", 
                "    #mc.setAttr(\"{}.rotate\".format(control_hierarchy[0]), 0,0,0)", 
                "    mc.delete(mc.listRelatives(control_hierarchy[-1], c=True, shapes=True)[0])", 
                "", 
                "    # create the drivers for the lip_L/R", 
                "    neutral = mc.createNode(\"transform\", name=\"{}_neutral\".format(control_name), parent=control_hierarchy[1])", 
                "    head_pin = mc.createNode(\"transform\", name=\"{}_headPin\".format(control_name), parent=control_hierarchy[1])", 
                "    jaw_pin = mc.createNode(\"transform\", name=\"{}_jawPin\".format(control_name), parent=control_hierarchy[1])", 
                "    # Store for constraining later", 
                "    head_pin_list.append(head_pin)", 
                "    jaw_pin_list.append(jaw_pin)", 
                "", 
                "    for pinGrp in [neutral, head_pin, jaw_pin]:", 
                "        cst = mc.parentConstraint(pinGrp, control_hierarchy[2])[0]", 
                "        mc.setAttr(cst+'.interpType', 2)", 
                "", 
                "    # constrain the driver to the control", 
                "    mc.pointConstraint(control_hierarchy[-1], driver_mouth_corner, mo=True)", 
                "", 
                "    if STAGE.node_data_obj:", 
                "        STAGE.node_data_obj.applyData([control_hierarchy[1]])", 
                "", 
                "    # create the head and jaw pinning.", 
                "    mc.addAttr(control_name, ln=\"pinning\", nn=\"----------\", at=\"enum\", enumName=\"Pinning\", keyable=True)", 
                "    rig_attribute.lock(control_name, \"pinning\")", 
                "    mc.addAttr(control_name, ln=\"pin\", at=\"double\", min=-10, max=10, dv=0, keyable=True)", 
                "    mc.setDrivenKeyframe(\"{}.{}W0\".format(cst,neutral), ", 
                "        cd=\"{}.pin\".format(control_name), v=1, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.{}W1\".format(cst,head_pin), ", 
                "        cd=\"{}.pin\".format(control_name), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.{}W2\".format(cst,jaw_pin), ", 
                "        cd=\"{}.pin\".format(control_name), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.{}W0\".format(cst,neutral), ", 
                "        cd=\"{}.pin\".format(control_name), v=0, dv=-10)", 
                "    mc.setDrivenKeyframe(\"{}.{}W1\".format(cst,head_pin), ", 
                "        cd=\"{}.pin\".format(control_name), v=0, dv=-10)", 
                "    mc.setDrivenKeyframe(\"{}.{}W2\".format(cst,jaw_pin), ", 
                "        cd=\"{}.pin\".format(control_name), v=1, dv=-10)", 
                "    mc.setDrivenKeyframe(\"{}.{}W0\".format(cst,neutral), ", 
                "        cd=\"{}.pin\".format(control_name), v=0, dv=10)", 
                "    mc.setDrivenKeyframe(\"{}.{}W1\".format(cst,head_pin), ", 
                "        cd=\"{}.pin\".format(control_name), v=1, dv=10)", 
                "    mc.setDrivenKeyframe(\"{}.{}W2\".format(cst,jaw_pin), ", 
                "        cd=\"{}.pin\".format(control_name), v=0, dv=10)", 
                "        ", 
                "        ", 
                "# constrain the head and jaw pinning. Needs to be done after nul's are mirrored", 
                "for jaw_pin in jaw_pin_list:", 
                "    mc.parentConstraint(${jaw_pin}, jaw_pin, mo=True)", 
                "for head_pin in head_pin_list:", 
                "    mc.parentConstraint(${head_pin}, head_pin, mo=True)"
            ]
        }, 
        "/mouth/lip_main/setup_sdk": {
            "enabled": true, 
            "comment": "Create the set driven keys for the lip main rig", 
            "code": [
                "driver_l_mouth_corner = STAGE.driver_mouth_corners[0]", 
                "driver_r_mouth_corner = STAGE.driver_mouth_corners[1]", 
                "    ", 
                "for attr in ['x','y','z']:", 
                "    for lip_main_control in STAGE.lip_main_control_hierarchy_list:", 
                "        # Translates", 
                "        if \"_l_\" in lip_main_control[3]:", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(lip_main_control[3],attr), ", 
                "                cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=0, dv=0)", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(lip_main_control[3],attr), ", 
                "                cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=1, dv=1)", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(lip_main_control[3],attr), ", 
                "                cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=-1, dv=-1)", 
                "    ", 
                "            dkey = mc.listConnections(\"{}.t{}\".format(driver_l_mouth_corner,attr), type='animCurveUL')[-1]", 
                "            dkey = mc.rename(dkey, lip_main_control[3]+'_translate'+attr.upper())", 
                "    ", 
                "            # RY Rotation driven by TX", 
                "            if attr == \"x\":", 
                "                mc.setDrivenKeyframe(\"{}.ry\".format(lip_main_control[2]), ", 
                "                    cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=0, dv=0)", 
                "                mc.setDrivenKeyframe(\"{}.ry\".format(lip_main_control[2]), ", 
                "                    cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=10, dv=1)", 
                "                mc.setDrivenKeyframe(\"{}.ry\".format(lip_main_control[2]), ", 
                "                    cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=-10, dv=-1)", 
                "    ", 
                "            # TY driving TZ", 
                "            if attr == \"y\":", 
                "                mc.setDrivenKeyframe(\"{}.tz\".format(lip_main_control[3]),", 
                "                                     cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=0, dv=0)", 
                "                mc.setDrivenKeyframe(\"{}.tz\".format(lip_main_control[3]),", 
                "                                     cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=0, dv=1)", 
                "                mc.setDrivenKeyframe(\"{}.tz\".format(lip_main_control[3]),", 
                "                                     cd=\"{}.t{}\".format(driver_l_mouth_corner,attr), v=0, dv=-1)", 
                "    ", 
                "                dkey = mc.listConnections(\"{}.t{}\".format(driver_l_mouth_corner,attr), type='animCurveUL')[-1]", 
                "                dkey = mc.rename(dkey, driver_l_mouth_corner+'_TY__'+lip_main_control[3]+'_TZ')    ", 
                "        elif \"_r_\" in lip_main_control[3]:    ", 
                "            # Translates", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(lip_main_control[3],attr), ", 
                "                cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=0, dv=0)", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(lip_main_control[3],attr), ", 
                "                cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=1, dv=1)", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(lip_main_control[3],attr), ", 
                "                cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=-1, dv=-1)", 
                "    ", 
                "            dkey = mc.listConnections(\"{}.t{}\".format(driver_r_mouth_corner,attr), type='animCurveUL')[-1]", 
                "            dkey = mc.rename(dkey, lip_main_control[3]+'_translate'+attr.upper())", 
                "    ", 
                "            # RY Rotation driven by TX", 
                "            if attr == \"x\":", 
                "                mc.setDrivenKeyframe(\"{}.ry\".format(lip_main_control[2]), ", 
                "                    cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=0, dv=0)", 
                "                mc.setDrivenKeyframe(\"{}.ry\".format(lip_main_control[2]), ", 
                "                    cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=10, dv=1)", 
                "                mc.setDrivenKeyframe(\"{}.ry\".format(lip_main_control[2]), ", 
                "                    cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=-10, dv=-1)", 
                "    ", 
                "            # TY driving TZ", 
                "            if attr == \"y\":", 
                "                mc.setDrivenKeyframe(\"{}.tz\".format(lip_main_control[3]),", 
                "                                     cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=0, dv=0)", 
                "                mc.setDrivenKeyframe(\"{}.tz\".format(lip_main_control[3]),", 
                "                                     cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=0, dv=1)", 
                "                mc.setDrivenKeyframe(\"{}.tz\".format(lip_main_control[3]),", 
                "                                     cd=\"{}.t{}\".format(driver_r_mouth_corner,attr), v=0, dv=-1)", 
                "    ", 
                "                dkey = mc.listConnections(\"{}.t{}\".format(driver_r_mouth_corner,attr), type='animCurveUL')[-1]", 
                "                dkey = mc.rename(dkey, driver_r_mouth_corner+'_TY__'+lip_main_control[3]+'_TZ')", 
                "                ", 
                "                ", 
                "# Set driven keys to be post and pre infinity", 
                "driven_key_list = mc.listConnections(driver_l_mouth_corner, type='animCurveUL')", 
                "driven_key_list += mc.listConnections(driver_r_mouth_corner, type='animCurveUL')", 
                "driven_key_list += mc.ls('lipMain_*_rot_def_auto*', type='animCurveUA')", 
                "for driven_key in driven_key_list:", 
                "    mc.setAttr('{}.preInfinity'.format(driven_key), 1)", 
                "    mc.setAttr('{}.postInfinity'.format(driven_key), 1)", 
                "    mc.keyTangent(driven_key, index=(0, 0), inTangentType='spline')", 
                "    mc.keyTangent(driven_key, index=(0, 0), outTangentType='spline')", 
                "    mc.keyTangent(driven_key, index=(2, 2), inTangentType='spline')", 
                "    mc.keyTangent(driven_key, index=(2, 2), outTangentType='spline')"
            ]
        }, 
        "/mouth/rig_sets": {
            "enabled": true, 
            "comment": "This node will create the rig sets for the mouth rig", 
            "code": [
                "# Rig Sets", 
                "#", 
                "rig_sets = 'RigSets'", 
                "if not mc.objExists(rig_sets):", 
                "    mc.sets(n=rig_sets, empty=1)", 
                "mouth_set = mc.sets(n='Mouth', empty=1)", 
                "mc.sets(mouth_set, e=1, add=rig_sets)", 
                "# Curves", 
                "mc.sets( [STAGE.lip_bindmesh_geometry, STAGE.lip_main_bindmesh_geometry,", 
                "         ${lip_curve}, ${lip_main_curve}], e=1, add=mouth_set)", 
                "", 
                "# Orient Sets", 
                "#", 
                "corner_set = mc.sets([x[1] for x in STAGE.corner_control_hierarchy_list], n='orients_MouthCorner')", 
                "main_set = mc.sets([x[1] for x in STAGE.lip_main_control_hierarchy_list], n='orients_lipMain')", 
                "tweak_set = mc.sets([x[1] for x in STAGE.lip_control_hierarchy_list], n='orients_lipTweakers')", 
                "", 
                "# create the sets", 
                "mc.sets([main_set, tweak_set, corner_set], e=1, add=mouth_set)", 
                "", 
                "# Driven Keys", 
                "#", 
                "#", 
                "for driver_axis in ['x', 'y', 'z']:", 
                "    driven_keys = mc.listConnections(STAGE.driver_mouth_corners[0]+'.t'+driver_axis, type='animCurveUL')", 
                "    driven_keys += mc.listConnections(STAGE.driver_mouth_corners[1]+'.t'+driver_axis, type='animCurveUL')", 
                "    for driven_axis in ['X', 'Y', 'Z']:", 
                "        d_keys = [n for n in driven_keys if 'translate' + driven_axis in n]", 
                "        if not d_keys:", 
                "            d_keys = [n for n in driven_keys if '_T' + driven_axis in n]", 
                "        if d_keys:", 
                "            d_set = mc.sets(d_keys, n='dkeys_T'+driver_axis.upper()+'_T'+driven_axis)", 
                "            mc.sets(d_set, e=1, add=mouth_set)", 
                "", 
                "# Rot Driven Keys", 
                "#", 
                "rot_def_auto = [x[2] for x in STAGE.lip_main_control_hierarchy_list]", 
                "ry_d_keys = []", 
                "rx_d_keys = []", 
                "for rot in rot_def_auto:", 
                "    driven_keys = mc.listConnections(rot, type='animCurveUA')", 
                "    if driven_keys:", 
                "        for dkey in driven_keys:", 
                "            if 'rotateY' in dkey:", 
                "                ry_d_keys.append(dkey)", 
                "            if 'rotateX' in dkey:", 
                "                rx_d_keys.append(dkey)", 
                "ry_d_keys_set = mc.sets(ry_d_keys, n='dkeys_RY')", 
                "mc.sets([ry_d_keys_set], e=1, add=mouth_set)", 
                "", 
                "# Anim controls", 
                "#", 
                "anim_controls = STAGE.anim_mouth_corners + [x[4] for x in STAGE.lip_control_hierarchy_list]", 
                "tweak_control = mc.sets(anim_controls, n='anim')", 
                "mc.sets(tweak_control, e=1, add=mouth_set)"
            ]
        }, 
        "/neck": {
            "child_order": [
                "create_spline", 
                "controls", 
                "head_pivot_connect", 
                "spaces"
            ], 
            "enabled": true, 
            "attrs": {
                "anchor": {
                    "type": "str", 
                    "value": "'chest_top'"
                }, 
                "component_parent": {
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "head_control": {
                    "type": "str", 
                    "value": "'head'"
                }, 
                "head_gimbal_control": {
                    "type": "raw", 
                    "value": "${head_control}+'_gimbal'"
                }, 
                "head_pivot": {
                    "type": "float", 
                    "value": "3.5"
                }, 
                "joint_list": {
                    "type": "raw", 
                    "value": "mc.ls('neck_?_bind', type='joint')"
                }, 
                "name": {
                    "type": "raw", 
                    "value": "neck"
                }, 
                "neck_control": {
                    "type": "str", 
                    "value": "'neck'"
                }, 
                "scale_factor": {
                    "type": "float", 
                    "value": ".4"
                }, 
                "skull_bind": {
                    "type": "str", 
                    "value": "'skull_bind'"
                }, 
                "skull_control": {
                    "type": "str", 
                    "value": "'skull'"
                }, 
                "spline_name": {
                    "type": "str", 
                    "value": "'neckIk'"
                }
            }
        }, 
        "/neck/controls": {
            "child_order": [
                "neck", 
                "head", 
                "head_gimbal", 
                "skull"
            ], 
            "enabled": true, 
            "attrs": {
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v', 'sx', 'sy', 'sz']"
                }
            }
        }, 
        "/neck/controls/head": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "poition_head"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${head_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hierarchy": {
                    "value": "['nul', 'cst']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${neck_control}"
                }
            }
        }, 
        "/neck/controls/head/poition_head": {
            "enabled": true, 
            "code": [
                "# make sure the nul is where the joint is", 
                "mc.xform('{}_nul'.format(${head_control}), ws=True, t=mc.xform(${skull_bind}, q=True, ws=True, t=True))"
            ]
        }, 
        "/neck/controls/head_gimbal": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "raw", 
                    "value": "${head_control}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${head_gimbal_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${head_control}"
                }
            }
        }, 
        "/neck/controls/head_gimbal/connect": {
            "enabled": true, 
            "code": [
                "head_gimbal_grp = mc.createNode(\"transform\", n=\"{}_grp\".format(${head_gimbal_control}))", 
                "# move the group into the same matrix as the control", 
                "mc.xform(head_gimbal_grp, ws=True, matrix=mc.xform(${head_gimbal_control}, q=True, ws=True, matrix=True))", 
                "# parent the group into the same space as the control", 
                "mc.parent(head_gimbal_grp, ${head_gimbal_control})", 
                "# constrain the gimbal group to the gimbal control", 
                "mc.connectAttr(\"{}.rp\".format(${head_control}), \"{}.rp\".format(${head_gimbal_control}), f=True)", 
                "", 
                "# make sure the nul is where the joint is", 
                "mc.xform('{}_nul'.format(${head_control}), ws=True, t=mc.xform(${skull_bind}, q=True, ws=True, t=True))"
            ]
        }, 
        "/neck/controls/neck": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${joint_list}[0]"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${neck_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul',\"ort\"]"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'${name}_grp'"
                }
            }
        }, 
        "/neck/controls/neck/connect": {
            "enabled": true, 
            "code": [
                "# parent the spline under the newly created control for the neck.", 
                "mc.parent(STAGE.spline.getGroup(), ${control_name})"
            ]
        }, 
        "/neck/controls/skull": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "attrs": {
                "align_rotation": {
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${skull_bind}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${skull_control}"
                }, 
                "control_type": {
                    "value": "'cube'"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${head_gimbal_control}"
                }
            }
        }, 
        "/neck/controls/skull/connect": {
            "code": [
                "skull_grp = mc.createNode(\"transform\", n=\"{}_grp\".format(${skull_control}), p=${skull_control})", 
                ""
            ]
        }, 
        "/neck/create_spline": {
            "enabled": true, 
            "code": [
                "# initialize the spline class", 
                "STAGE.spline = rig_spline.SplineBase(jointList=${joint_list} + [${skull_bind}], ", 
                "                                      splineName=${spline_name},", 
                "                                      scaleFactor=${scale_factor})", 
                "", 
                "# create the spline", 
                "STAGE.spline.create()", 
                "", 
                "mc.createNode('transform', n='${name}_grp')", 
                "if mc.objExists(${component_parent}):", 
                "    mc.parent('${name}_grp', ${component_parent})"
            ]
        }, 
        "/neck/head_pivot_connect": {
            "enabled": true, 
            "code": [
                "import maya.api.OpenMaya as om", 
                "# declare variables needed for the commands", 
                "clusters = STAGE.spline._clusters", 
                "# get the name of the curveInfo node. This is hard coded to be this way in the", 
                "# spline  code. If that changes, this will not work. We can change the code below", 
                "# to use the API to get the length of the curve instead of this node, but for now, this ", 
                "# is quicker because it's available already.", 
                "spline_curve_info = ${spline_name}+\"_curveInfo\"", 
                "head_gimbal_group = \"{}_grp\".format(${head_gimbal_control})", 
                "head_nul = '{}_nul'.format(${head_control})", 
                "", 
                "# create pivot attributes to use for moving the pivot and tangent heights.", 
                "mc.addAttr(${head_control}, ln=\"pivotHeight\", at=\"double\", dv=0, min=0, max=10, keyable=False)", 
                "mc.setAttr(\"{}.pivotHeight\".format(${head_control}), ${head_pivot})", 
                "", 
                "# create the remap node to use to remap the pivot height to the lenght of the curve", 
                "head_remap_node = mc.createNode(\"remapValue\", n=\"head_pivot_remap\")", 
                "", 
                "# map the 0-10 to the length of the curve on the spline", 
                "curve_length = mc.getAttr(\"{}.arcLength\".format(spline_curve_info))", 
                "", 
                "# set the max output value for the remap to be the length of the curve", 
                "mc.setAttr(\"{}.outputMax\".format(head_remap_node), curve_length)", 
                "", 
                "# set the input max", 
                "mc.setAttr(\"{}.inputMax\".format(head_remap_node), 10)", 
                "", 
                "# connect the slider for pivot to the input max", 
                "mc.connectAttr(\"{}.pivotHeight\".format(${head_control}), ", 
                "                \"{}.inputValue\".format(head_remap_node), f=True)", 
                "", 
                "# get the aim axis", 
                "head_pivot_nul_grp = mc.createNode(\"transform\", name=\"headPivot_aim_nul\")", 
                "head_pivot_aim_grp = mc.createNode(\"transform\", name=\"headPivot_aim_grp\")", 
                "head_pivot_driver = mc.createNode(\"transform\", name=\"headPivot_aim_drv\")", 
                "mc.parent(head_pivot_aim_grp, head_pivot_nul_grp)", 
                "mc.parent(head_pivot_nul_grp, head_gimbal_group)", 
                "mc.parent(head_pivot_driver, head_pivot_aim_grp)", 
                "mc.xform(head_pivot_nul_grp, ws=True, t=mc.xform(${joint_list}[0], q=True, ws=True, t=True))", 
                "# get the aim axis", 
                "aim_axis= rig_transform.getAimAxis(head_gimbal_group)", 
                "mc.parent(head_pivot_nul_grp, head_nul)", 
                "vector = om.MVector(*mc.getAttr(\"{}.t\".format(head_pivot_nul_grp)))", 
                "vector.normalize()", 
                "distance_value = max(vector, key=abs)", 
                "index = (vector.x, vector.y, vector.z).index(distance_value)", 
                "aim_vector = list()", 
                "for i in range(len(vector)):", 
                "    if i == index:", 
                "        aim_vector.append(1)", 
                "    else:", 
                "        aim_vector.append(0)", 
                "", 
                "# move the transform back to the skull", 
                "mc.xform(head_pivot_nul_grp, ws=True, matrix=mc.xform(${head_control}, q=True, ws=True, matrix=True))", 
                "mc.parent(head_pivot_driver, head_nul)", 
                "mc.pointConstraint(head_pivot_aim_grp, head_pivot_driver, mo=False)", 
                "mc.orientConstraint(head_pivot_aim_grp, head_pivot_driver, mo=False)", 
                "", 
                "mc.delete(mc.aimConstraint(${neck_control},head_pivot_nul_grp, w=1, upVector=(0,0,0), aimVector=aim_vector, wut=\"none\"))", 
                "", 
                "mc.connectAttr('{}.outValue'.format(head_remap_node), '{}.t{}'.format(head_pivot_aim_grp, aim_axis.strip('-')), f=True)", 
                "mc.connectAttr('{}.t'.format(head_pivot_driver), '{}.rotatePivot'.format(${head_control}), f=True)", 
                "mc.setAttr('{}_cst.rotatePivot'.format(${head_control}), *mc.getAttr('{}.t'.format(head_pivot_driver))[0])", 
                "", 
                "# parent the head control to the neck now.", 
                "#mc.parent(head_nul, ${neck_control})", 
                "mc.parent(clusters[2:], head_gimbal_group)", 
                "mc.orientConstraint(head_gimbal_group, STAGE.spline._endTwistNul, mo=1)", 
                "", 
                "# make the offset joint for the skull", 
                "skull_offset = mc.duplicate(${skull_bind}, po=True, rr=True, name=\"{}_offset\".format(${skull_bind}))[0]", 
                "mc.setAttr(skull_offset+'.v', 0)", 
                "mc.parent(skull_offset, ${skull_control}+'_grp')", 
                "mc.orientConstraint(skull_offset, STAGE.spline._ikJointList[-1], mo=1)", 
                "", 
                "# connect the scale of the gimbal group to the scale of skull bind", 
                "head_scale_mdn = mc.createNode(\"multiplyDivide\", n=\"head_scale_mdn\")", 
                "mc.connectAttr(\"{}.s\".format(${head_control}), \"{}.input1\".format(head_scale_mdn), f=True)", 
                "mc.connectAttr(\"{}.s\".format(${head_gimbal_control}), \"{}.input2\".format(head_scale_mdn), f=True)", 
                "mc.connectAttr(\"{}.output\".format(head_scale_mdn), \"{}.s\".format(${skull_bind}), f=True)", 
                "", 
                "if mc.objExists(${anchor}):", 
                "    mc.parentConstraint(${anchor}, '{}_nul'.format(${neck_control}), mo=1)", 
                "else:", 
                "    mc.warning('Anchor object [ {} ] does not exist.'.format(${anchor})) ", 
                "", 
                "#mc.parent('{}_nul'.format(${neck_control}), '${name}_grp')", 
                "mc.hide(STAGE.spline._group, clusters)", 
                "", 
                "# Head psd driver", 
                "driver_nul = mc.duplicate(head_nul, po=1, n='{}_driver_nul'.format(${head_control}))[0]", 
                "driver = mc.createNode('transform', n='{}_driver'.format(${head_control}), p=driver_nul)", 
                "mc.orientConstraint(${head_control}, driver)", 
                "", 
                "# Something is cause flipping with the decompose unless this rotate order is changed.", 
                "# Needs to be debugged, setting here for now", 
                "mc.setAttr(\"neckIk_end_twist.rotateOrder\", 5)"
            ]
        }, 
        "/neck/spaces": {
            "child_order": [
                "neck_spaces", 
                "head_spaces"
            ], 
            "enabled": true
        }, 
        "/neck/spaces/head_spaces": {
            "instance": "/space_switch", 
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "str", 
                    "value": "'head'"
                }, 
                "constraint_node": {
                    "type": "raw", 
                    "value": "${head_control} + '_cst'"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "['world']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'neck'"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "['rig']"
                }
            }
        }, 
        "/neck/spaces/neck_spaces": {
            "instance": "/space_switch", 
            "enabled": true, 
            "attrs": {
                "attribute_node": {
                    "type": "str", 
                    "value": "'neck'"
                }, 
                "constraint_node": {
                    "type": "str", 
                    "value": "'neck_ort'"
                }, 
                "name_list": {
                    "type": "list", 
                    "value": "['world']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'chest_top'"
                }, 
                "target_list": {
                    "type": "list", 
                    "value": "['rig']"
                }
            }
        }, 
        "/spine": {
            "child_order": [
                "create_spline", 
                "controls", 
                "preserve_length", 
                "psd_drivers"
            ], 
            "enabled": true, 
            "comment": "This will bind an IK FK spine setup. Will also add a wire deformer that will have three spine twekers for secondary shaping. There is spine length preservation as well.", 
            "attrs": {
                "bendy_curve": {
                    "comment": "Curve that will be used for ", 
                    "type": "str", 
                    "value": "'spine_curve'"
                }, 
                "chest_bind": {
                    "comment": "Chest join", 
                    "type": "str", 
                    "value": "'chest_bind'"
                }, 
                "chest_control": {
                    "comment": "Name of chest control that will be used to name the control during creation", 
                    "type": "str", 
                    "value": "'chest'"
                }, 
                "chest_ik_control": {
                    "comment": "Name of IK chest control that will be used to name the control during creation", 
                    "type": "str", 
                    "value": "'chest_ik'"
                }, 
                "chest_pivot": {
                    "comment": "Default chest pivot value. This determines offset position of the rotate pivot for the control", 
                    "type": "float", 
                    "value": "3.5"
                }, 
                "chest_top_control": {
                    "comment": "Name of chest top control that will be used during creation.", 
                    "type": "str", 
                    "value": "'chest_top'"
                }, 
                "component_parent": {
                    "comment": "Name of node you wish to parent this component under.", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "create_bendy_spline": {
                    "comment": "This determines whether we create a bendy tweaker  rig for the spine. It's secondary and not requiered for building the spine.", 
                    "type": "bool", 
                    "value": "True"
                }, 
                "geometry": {
                    "comment": "Name of geometry we will put the wire deformer on if the bendy curve rig is set to true.", 
                    "type": "str", 
                    "value": "'body_geo'"
                }, 
                "hip_swivel_control": {
                    "comment": "Name of the hip swivel control that will be used during creation.", 
                    "type": "str", 
                    "value": "'hip_swivel'"
                }, 
                "hip_swivel_pivot": {
                    "comment": "Value of the hip pivot offset from where the hip control is. ", 
                    "type": "raw", 
                    "value": 3.5
                }, 
                "hips_bind": {
                    "comment": "Name of the hip joint that will be used during build.", 
                    "type": "str", 
                    "value": "'hips_bind'"
                }, 
                "joint_list": {
                    "comment": "List of joints in the spine. ", 
                    "type": "raw", 
                    "value": "mc.ls('spine_*_bind')"
                }, 
                "movable_pivot_control": {
                    "comment": "Name of the movable pivot that will be used during creation.", 
                    "type": "str", 
                    "value": "'hipsPivot'"
                }, 
                "name": {
                    "comment": "Name for this component", 
                    "type": "raw", 
                    "value": "spine"
                }, 
                "scale_factor": {
                    "type": "float", 
                    "value": ".5"
                }, 
                "spline_name": {
                    "comment": "Name for the spline group and system", 
                    "type": "str", 
                    "value": "'spineIk'"
                }, 
                "torso_control": {
                    "comment": "Name of the torso control that will be used during creation.", 
                    "type": "str", 
                    "value": "'torso'"
                }
            }
        }, 
        "/spine/controls": {
            "child_order": [
                "movable_pivot", 
                "fk", 
                "ik", 
                "bendy_spine"
            ], 
            "enabled": true
        }, 
        "/spine/controls/bendy_spine": {
            "enabled": true, 
            "code": [
                "if ${create_bendy_spline} and mc.objExists(${bendy_curve}):", 
                "    bindmesh_geometry, follicle_list, control_hieracrchy_list, bend_joint_list, base_curve_joint_list = rig_wire.buildCurveRig(${bendy_curve}, name='${name}_bend', parent='${name}', control_type='body')", 
                "    ", 
                "    # hide the first and last bend control and untag them as controls.", 
                "    for ctrl in (control_hieracrchy_list[0][-1], control_hieracrchy_list[-1][-1]):", 
                "        rig_control.untagAsControl(ctrl)", 
                "        mc.setAttr('{}.v'.format(ctrl), 0)", 
                "    ", 
                "    if mc.objExists(${geometry}):", 
                "        #deform the lid bindmesh with the lid curve using a wire deformer.", 
                "        wire_deformer = mc.wire(${geometry}, gw=False, en=1.00, ce=0.00, li=0.00, ", 
                "                w=${bendy_curve}, name=\"{}_wire\".format(${bendy_curve}))[0]", 
                "        ", 
                "        base_curve = \"{}BaseWire\".format(${bendy_curve})", 
                "        mc.parent([${bendy_curve},base_curve], '${name}')", 
                "        baseCurveSkin = mc.skinCluster(*[base_curve_joint_list]+mc.ls(base_curve), ", 
                "                                    n=\"{}_skinCluster\".format(base_curve),", 
                "                                    tsb=True)[0]", 
                "    ", 
                "        # set the default values for the wire deformer", 
                "        mc.setAttr(\"{}.rotation\".format(wire_deformer), 0)", 
                "        mc.setAttr(\"{}.dropoffDistance[0]\".format(wire_deformer), 100)", 
                "    ", 
                "    bind_mesh_skin = mc.skinCluster(*${joint_list}+[${hips_bind},${chest_bind}]+mc.ls(bindmesh_geometry), ", 
                "                                        n=\"{}_skinCluster\".format(bindmesh_geometry),", 
                "                                        tsb=True)[0]", 
                "    ", 
                "    mc.skinPercent(bind_mesh_skin , '{}.vtx[0:3]'.format(bindmesh_geometry), transformValue=[(${hips_bind}, 1.0), (${joint_list}[0], 0.0)])", 
                "    mc.skinPercent(bind_mesh_skin , '{}.vtx[4:7]'.format(bindmesh_geometry),  transformValue=[(${joint_list}[0], 0.0), (${joint_list}[1], 1.0), (${joint_list}[2],0.0)])", 
                "    mc.skinPercent(bind_mesh_skin , '{}.vtx[8:11]'.format(bindmesh_geometry), transformValue=[(${joint_list}[3], 1.0), (${joint_list}[1], 0.0)])", 
                "    mc.skinPercent(bind_mesh_skin , '{}.vtx[12:15]'.format(bindmesh_geometry), transformValue=[(${joint_list}[2], 0.0), (${joint_list}[4], 0.0), (${chest_bind}, 1.0)])", 
                "    mc.skinPercent(bind_mesh_skin , '{}.vtx[16:19]'.format(bindmesh_geometry), transformValue=[(${chest_bind}, 1.0), (${joint_list}[1], 0.0), (${joint_list}[2],0.0)])"
            ]
        }, 
        "/spine/controls/fk": {
            "child_order": [
                "hips", 
                "hips_gimbal", 
                "torso", 
                "chest"
            ], 
            "enabled": true
        }, 
        "/spine/controls/fk/chest": {
            "instance": "/control", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "str", 
                    "value": "'chest_bind'"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${chest_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['sx', 'sy', 'sz','v']"
                }, 
                "hierarchy": {
                    "comment": "Hierarchy suffix list. This will create the hierarchy above the control useing the control name plus suffix name", 
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${torso_control}"
                }, 
                "rotationOrder": {
                    "type": "str", 
                    "value": "'xzy'"
                }
            }
        }, 
        "/spine/controls/fk/hips": {
            "instance": "/control", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "str", 
                    "value": "'hips_bind'"
                }, 
                "control_name": {
                    "type": "str", 
                    "value": "'hips'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['sx', 'sy', 'sz','v']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${movable_pivot_control}+'_grp'"
                }, 
                "rotationOrder": {
                    "type": "str", 
                    "value": "'xzy'"
                }
            }, 
            "code": [
                ""
            ]
        }, 
        "/spine/controls/fk/hips_gimbal": {
            "instance": "/control", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "str", 
                    "value": "'hips'"
                }, 
                "control_name": {
                    "type": "str", 
                    "value": "'hips_gimbal'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['sx', 'sy', 'sz','v']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'hips'"
                }, 
                "rotationOrder": {
                    "type": "str", 
                    "value": "'xzy'"
                }
            }, 
            "code": [
                ""
            ]
        }, 
        "/spine/controls/fk/torso": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "position"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${parent}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${torso_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['sx', 'sy', 'sz','v']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'hips_gimbal'"
                }, 
                "rotationOrder": {
                    "type": "str", 
                    "value": "'xzy'"
                }
            }, 
            "code": [
                ""
            ]
        }, 
        "/spine/controls/fk/torso/position": {
            "enabled": true, 
            "code": [
                "# position the torso.", 
                "mc.xform('{}_nul'.format(${control_name}), ws=True, matrix=STAGE.hip_matrix)", 
                "average_pos = rig_transform.getAveragePosition(mc.ls('spine_*_bind')[:2])", 
                "mc.xform('{}_nul'.format(${control_name}), ws=True, t=average_pos)"
            ]
        }, 
        "/spine/controls/ik": {
            "child_order": [
                "hip_swivel", 
                "chest", 
                "chest_top", 
                "chest_pivot", 
                "hip_pivot"
            ], 
            "enabled": true
        }, 
        "/spine/controls/ik/chest": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${chest_bind}"
                }, 
                "control_name": {
                    "type": "str", 
                    "value": "'chest_ik'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "[\"sx\", \"sy\", \"sz\",\"v\"]"
                }, 
                "hierarchy": {
                    "comment": "Hierarchy suffix list. This will create the hierarchy above the control useing the control name plus suffix name", 
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${chest_control}"
                }, 
                "rotationOrder": {
                    "type": "str", 
                    "value": "'xzy'"
                }
            }
        }, 
        "/spine/controls/ik/chest/connect": {
            "enabled": true, 
            "code": [
                "# connect the rotate pivots so the pivots for these two controls are in the same location.", 
                "mc.connectAttr(\"{}.rp\".format(${parent}),\"{}.rp\".format(${control_name}), f=True)", 
                "STAGE.chest_matrix = mc.xform(${control_name}, q=True, ws=True, matrix=True)"
            ]
        }, 
        "/spine/controls/ik/chest_pivot": {
            "enabled": true, 
            "code": [
                "# ==========================================================================================", 
                "# chest pivot", 
                "chest_pivot_value = ${chest_pivot}", 
                "chest_control = ${chest_control}", 
                "chest_nul = '{}_nul'.format(chest_control)", 
                "curve_info = \"{}_curveInfo\".format(${spline_name})", 
                "# create pivot attributes to use for moving the pivot and tangent heights.", 
                "mc.addAttr(chest_control, ln=\"pivotHeight\", at=\"double\", dv=0, min=0, max=10, keyable=True)", 
                "mc.setAttr(\"{}.pivotHeight\".format(chest_control), chest_pivot_value)", 
                "", 
                "# create the remap node to use to remap the pivot height to the lenght of the curve", 
                "chest_remap_node = mc.createNode(\"remapValue\", n=\"chest_pivot_remap\")", 
                "", 
                "# map the 0-10 to the length of the curve on the spine", 
                "curve_length = mc.getAttr(\"{}.arcLength\".format(curve_info))", 
                "", 
                "# set the max output value for the remap to be the length of the curve", 
                "mc.setAttr(\"{}.outputMax\".format(chest_remap_node), curve_length)", 
                "", 
                "# set the input max", 
                "mc.setAttr(\"{}.inputMax\".format(chest_remap_node), 10)", 
                "", 
                "# connect the slider for pivot to the input max", 
                "mc.connectAttr(\"{}.pivotHeight\".format(chest_control), \"{}.inputValue\".format(chest_remap_node), f=True)", 
                "", 
                "# get the aim axis", 
                "chest_pivot_nul_grp = mc.createNode(\"transform\", name=\"chestPivot_aim_nul\")", 
                "chest_pivot_aim_grp = mc.createNode(\"transform\", name=\"chestPivot_aim_grp\")", 
                "chest_pivot_driver = mc.createNode(\"transform\", name=\"chestPivot_aim_drv\")", 
                "mc.parent(chest_pivot_aim_grp, chest_pivot_nul_grp)", 
                "mc.parent(chest_pivot_nul_grp, chest_control)", 
                "mc.parent(chest_pivot_driver, chest_pivot_aim_grp)", 
                "", 
                "mc.xform(chest_pivot_nul_grp, ws=True, matrix=STAGE.chest_matrix)", 
                "mc.xform(chest_pivot_driver, ws=True, matrix=STAGE.hip_matrix)", 
                "aimAxis, aimVector = rig_transform.getDistanceVector(mc.getAttr('{}.t'.format(chest_pivot_driver))[0])", 
                "mc.parent(chest_pivot_nul_grp, chest_nul)", 
                "", 
                "# move the transform back to the skull", 
                "mc.xform(chest_pivot_driver, ws=True, matrix=STAGE.chest_matrix)", 
                "mc.xform(chest_pivot_nul_grp, ws=True, t=mc.xform(chest_nul, q=True, ws=True, t=True))", 
                "mc.orientConstraint(chest_nul, chest_pivot_nul_grp)", 
                "mc.parent(chest_pivot_driver, chest_nul)", 
                "mc.pointConstraint(chest_pivot_aim_grp, chest_pivot_driver)", 
                "mc.orientConstraint(chest_pivot_aim_grp, chest_pivot_driver)", 
                "", 
                "if '-' in aimAxis:", 
                "    chest_ctrl_pivot_mdl = mc.createNode('multDoubleLinear', n='chest_pivot_mdl')", 
                "    mc.connectAttr('{}.outValue'.format(chest_remap_node), '{}.input1'.format(chest_ctrl_pivot_mdl), f=True)", 
                "    mc.setAttr('{}.input2'.format(chest_ctrl_pivot_mdl), -1)", 
                "    mc.connectAttr('{}.output'.format(chest_ctrl_pivot_mdl), '{}.t{}'.format(chest_pivot_aim_grp, aimAxis.strip('-')), f=True)", 
                "    mc.connectAttr('{}.t'.format(chest_pivot_driver), '{}.rotatePivot'.format(chest_control), f=True)", 
                "else:", 
                "    mc.connectAttr('{}.outValue'.format(chest_remap_node), '{}.t{}'.format(chest_pivot_aim_grp, aimAxis), f=True)", 
                "    mc.connectAttr('{}.t'.format(chest_pivot_driver), '{}.rotatePivot'.format(chest_control), f=True)"
            ]
        }, 
        "/spine/controls/ik/chest_top": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${parent}"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${chest_top_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "[\"sx\", \"sy\", \"sz\", \"v\"]"
                }, 
                "hierarchy": {
                    "comment": "Hierarchy suffix list. This will create the hierarchy above the control useing the control name plus suffix name", 
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'chest_ik'"
                }
            }
        }, 
        "/spine/controls/ik/chest_top/connect": {
            "enabled": true, 
            "code": [
                "clusters = STAGE.spline._clusters", 
                "# make sure the clusters are connected.", 
                "mc.parent(clusters[2:], ${parent})", 
                "chest_top_grp = mc.createNode(\"transform\", name=\"{}_grp\".format(${control_name}))", 
                "mc.xform(chest_top_grp, ws=True, matrix=STAGE.chest_matrix)", 
                "mc.parent(chest_top_grp, ${control_name})", 
                "mc.orientConstraint(chest_top_grp, STAGE.spline._endTwistNul, mo=1)", 
                "", 
                "# Remove existing constraint on chestBind", 
                "orient_constraint = mc.orientConstraint(${chest_bind}, q=1)", 
                "point_constraint = mc.pointConstraint(${chest_bind}, q=1)", 
                "if orient_constraint:", 
                "    mc.delete(orient_constraint)", 
                "if point_constraint:", 
                "    mc.delete(point_constraint)", 
                "", 
                "# Connect the chest_bind to the chest top group", 
                "mc.pointConstraint(chest_top_grp, ${chest_bind}, mo=1)", 
                "mc.orientConstraint(chest_top_grp, ${chest_bind}, mo=1)", 
                "#mc.connectAttr(chestTopCtrl+'.s', self._chestBind+'.s')"
            ]
        }, 
        "/spine/controls/ik/hip_pivot": {
            "enabled": true, 
            "code": [
                "# ==========================================================================================", 
                "# hip swivel pivot", 
                "hip_swivel_control = ${hip_swivel_control}", 
                "hip_swivel_grp = '{}_grp'.format(${hip_swivel_control})", 
                "curve_info = \"{}_curveInfo\".format(${spline_name})", 
                "# map the 0-10 to the length of the curve on the spine", 
                "curve_length = mc.getAttr(\"{}.arcLength\".format(curve_info))", 
                "# declare chest_top_group", 
                "chest_top_grp = '{}_grp'.format(${chest_top_control})", 
                "# create pivot attributes to use for moving the pivot and tangent heights.", 
                "mc.addAttr(hip_swivel_control, ln=\"pivotHeight\", at=\"double\", dv=0, min=0, max=10, keyable=False)", 
                "mc.setAttr(\"{}.pivotHeight\".format(hip_swivel_control), ${hip_swivel_pivot})", 
                "", 
                "# create the remap node to use to remap the pivot height to the lenght of the curve", 
                "hip_swivel_remap = mc.createNode(\"remapValue\", n=\"hipSwivel_pivot_remap\")", 
                "", 
                "# set the max output value for the remap to be the length of the curve", 
                "mc.setAttr(\"{}.outputMax\".format(hip_swivel_remap), curve_length)", 
                "", 
                "# set the input max", 
                "mc.setAttr(\"{}.inputMax\".format(hip_swivel_remap), 10)", 
                "", 
                "# connect the slider for pivot to the input max", 
                "mc.connectAttr(\"{}.pivotHeight\".format(hip_swivel_control), ", 
                "                \"{}.inputValue\".format(hip_swivel_remap), f=True)", 
                "", 
                "# get the aim axis", 
                "temp_node = mc.createNode(\"transform\", name=\"temp\")", 
                "mc.parent(temp_node, '{}_grp'.format(hip_swivel_control))", 
                "mc.xform(temp_node, ws=True, matrix=STAGE.chest_matrix)", 
                "aim_axis, aim_vector = rig_transform.getDistanceVector(mc.getAttr('{}.t'.format(temp_node))[0])", 
                "mc.delete(temp_node)", 
                "if '-' in aim_axis:", 
                "    hip_swivel_pivot_mdl = mc.createNode('multDoubleLinear', n='hipSwivel_pivot_mdl')", 
                "", 
                "    mc.connectAttr(\"{}.outValue\".format(hip_swivel_remap), ", 
                "        '{}.input1'.format(hip_swivel_pivot_mdl), f=True)", 
                "", 
                "    mc.setAttr('{}.input2'.format(hip_swivel_pivot_mdl), -1)", 
                "", 
                "    mc.connectAttr('{}.output'.format(hip_swivel_pivot_mdl), ", 
                "        '{}.rotatePivot{}'.format(hip_swivel_control, aim_axis.strip('-').capitalize()), f=True)", 
                "else:", 
                "    mc.connectAttr(\"{}.outValue\".format(hip_swivel_remap), ", 
                "        '{}.rotatePivot{}'.format(hip_swivel_control, aim_axis.capitalize()), f=True)", 
                "", 
                "# Remove existing constraint on chestBind", 
                "orient_constraint = mc.orientConstraint(${chest_bind}, q=1)", 
                "point_constraint = mc.pointConstraint(${chest_bind}, q=1)", 
                "if orient_constraint:", 
                "    mc.delete(orient_constraint)", 
                "if point_constraint:", 
                "    mc.delete(point_constraint)", 
                "", 
                "mc.pointConstraint(chest_top_grp, ${chest_bind}, mo=1)", 
                "mc.orientConstraint(chest_top_grp, ${chest_bind}, mo=1)", 
                "#mc.connectAttr(chestTopCtrl+'.s', self._chestBind+'.s')", 
                "", 
                "mc.parentConstraint(hip_swivel_grp, ${hips_bind}, mo=1) ", 
                "mc.connectAttr(hip_swivel_grp+'.s', ${hips_bind}+'.s')", 
                "", 
                "# hide the spline", 
                "mc.hide(STAGE.spline._group, STAGE.spline._clusters)"
            ]
        }, 
        "/spine/controls/ik/hip_swivel": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${joint_list}[0]"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${hip_swivel_control}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'cube'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['sx', 'sy', 'sz','v']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'hips_gimbal'"
                }, 
                "rotationOrder": {
                    "type": "str", 
                    "value": "'xzy'"
                }
            }, 
            "code": [
                ""
            ]
        }, 
        "/spine/controls/ik/hip_swivel/connect": {
            "enabled": true, 
            "code": [
                "clusters = STAGE.spline._clusters#mc.ls('{}*cluster_?Handle'.format(${spline_name}))", 
                "ctrl = ${control_name}", 
                "# create a group that is driven by the ctrl", 
                "hip_swivel_grp = mc.createNode('transform', n='{}_grp'.format(ctrl))", 
                "", 
                "# move the group into the same matrix as the control", 
                "mc.xform(hip_swivel_grp, ws=True, matrix=mc.xform(ctrl, q=True, ws=True, matrix=True))", 
                "# parent the group into the same space as the control", 
                "mc.parent(hip_swivel_grp, ctrl)", 
                "mc.parent(clusters[0:2], hip_swivel_grp)", 
                "mc.orientConstraint(hip_swivel_grp, STAGE.spline._startTwistNul, mo=1)", 
                "", 
                "# Parent the entire ik group to the hips", 
                "mc.parent(STAGE.spline.getGroup(), ${parent})"
            ]
        }, 
        "/spine/controls/movable_pivot": {
            "enabled": true, 
            "code": [
                "# get the hip translation", 
                "hip_translation = mc.xform(${hips_bind}, q=True, ws=True, translation=True)", 
                "# store this on the stage for later use so we don't have to keep querying this value", 
                "STAGE.hip_translation = hip_translation", 
                "# create the movable pivot control", 
                "movable_pivot_nul, movable_pivot_ctrl = rig_control.create(name=${movable_pivot_control}, ", 
                "                                                controlType=\"cube\",", 
                "                                                hideAttrs=[\"sx\", \"sy\", \"sz\",\"v\"],", 
                "                                                hierarchy=['nul'],", 
                "                                                color=rig_common.RED)", 
                "", 
                "# create the grp that we will use to move the pivot of the hips", 
                "movable_pivot_grp = mc.createNode(\"transform\", name=\"{}_grp\".format(movable_pivot_ctrl))", 
                "mc.xform(movable_pivot_nul, ws=True, t=hip_translation)", 
                "mc.xform(movable_pivot_grp, ws=True, t=hip_translation)", 
                "mc.parent(movable_pivot_grp, movable_pivot_nul)", 
                "mc.parent(movable_pivot_nul, '${name}')", 
                "# get the hip matrix", 
                "STAGE.hip_matrix = mc.xform(movable_pivot_ctrl, q=True, ws=True, matrix=True)", 
                "", 
                "# connect the movable pivot control to the grp", 
                "mc.connectAttr(\"{}.t\".format(movable_pivot_ctrl), \"{}.rotatePivot\".format(movable_pivot_grp), f=True)", 
                "mc.connectAttr(\"{}.r\".format(movable_pivot_ctrl), \"{}.r\".format(movable_pivot_grp), f=True)"
            ]
        }, 
        "/spine/create_spline": {
            "enabled": true, 
            "code": [
                "# initialize the spline class", 
                "STAGE.spline = rig_spline.SplineBase(jointList=${joint_list} + [${chest_bind}],", 
                "                                splineName=${spline_name},", 
                "                                scaleFactor=${scale_factor})", 
                "# create the spline", 
                "STAGE.spline.create()", 
                "", 
                "mc.createNode('transform', n='${name}')", 
                "if mc.objExists(${component_parent}):", 
                "    mc.parent('${name}', ${component_parent})"
            ]
        }, 
        "/spine/preserve_length": {
            "enabled": true, 
            "code": [
                "# ------------------------------------------------------------------------------------", 
                "# Length Preservation", 
                "# ------------------------------------------------------------------------------------", 
                "rig_spline.preserveLength(name='{}_length'.format(${spline_name}),", 
                "                      curve='{}_curve'.format(${spline_name}),", 
                "                      primary_control='chest',", 
                "                      rotate_controls=[${torso_control}, ${chest_control}, ${chest_ik_control}],", 
                "                      no_rotate_cvs=[2, 3],", 
                "                      parent='${name}',", 
                "                      position_output_child='{}_nul'.format(${chest_top_control}))", 
                "# Something is cause flipping with the decompose unless this rotate order is changed.", 
                "# Needs to be debugged, setting here for now                  ", 
                "mc.setAttr(\"{}_end_twist.rotateOrder\".format(${spline_name}), 5)"
            ]
        }, 
        "/spine/psd_drivers": {
            "code": [
                "# Chest driver", 
                "chest_driver = mc.createNode('transform', n='chest_driver', p=${torso_control})", 
                "mc.orientConstraint(${chest_ik_control}, chest_driver)", 
                "mc.pointConstraint(${chest_ik_control}, chest_driver)"
            ]
        }, 
        "/tongue": {
            "child_order": [
                "create", 
                "controls"
            ], 
            "enabled": true, 
            "comment": "Tongue component. This will be used for tongue rigs. Any additonal functionality to how the tongue works should be put here.", 
            "attrs": {
                "anchor": {
                    "comment": "Name of the node you want this component to be driven by.", 
                    "type": "str", 
                    "value": "'jaw_bind'"
                }, 
                "component_parent": {
                    "comment": "Name of the parent node you want this component to live under.", 
                    "type": "str", 
                    "value": "'rig'"
                }, 
                "joint_list": {
                    "comment": "List of joints to use when building the rig", 
                    "type": "raw", 
                    "value": "mc.ls('tongue_?_bind')"
                }, 
                "name": {
                    "comment": "name of the component", 
                    "type": "raw", 
                    "value": "tongue"
                }, 
                "spline_name": {
                    "comment": "Name for the spline system", 
                    "type": "str", 
                    "value": "'tongueIK'"
                }
            }
        }, 
        "/tongue/controls": {
            "enabled": true, 
            "code": [
                "# Tongue Base", 
                "tongue_base_nul, tongue_base_control = rig_control.create(name=\"tongue_base\",", 
                "                                  controlType=None,", 
                "                                  color=rig_common.RED,", 
                "                                  hierarchy=['nul'],", 
                "                                  type='face')", 
                "", 
                "# Hook up scale", 
                "scale_nul = mc.createNode('transform', p=${joint_list}[0], n='tongue_scale_nul')", 
                "mc.parent(scale_nul, mc.listRelatives(${joint_list}[0], p=1)[0])", 
                "mc.parent(${joint_list}[0], scale_nul)", 
                "mc.connectAttr(tongue_base_control+'.s', scale_nul+'.s')", 
                "mc.setAttr(${joint_list}[0]+'.segmentScaleCompensate', 0)", 
                "", 
                "matrix = mc.xform(${joint_list}[0], q=True, ws=True, matrix=True)", 
                "mc.xform(tongue_base_nul, ws=True, matrix=matrix)", 
                "", 
                "# Parent the entire ik group to the neck", 
                "mc.parent(STAGE.spline.getGroup(), tongue_base_control)", 
                "", 
                "# tongue Mid", 
                "tongue_mid_nul, tongue_mid_control = rig_control.create(name=\"tongue_mid\",", 
                "                                  controlType=None,", 
                "                                  color=rig_common.RED,", 
                "                                  hideAttrs=['sx', 'sy', 'sz', 'v'],", 
                "                                  hierarchy=['nul'],", 
                "                                  type='face')", 
                "", 
                "# move the middle control between the last the middle joints", 
                "mc.delete(mc.parentConstraint(${joint_list}[-2], ${joint_list}[1], tongue_mid_nul))", 
                "", 
                "mc.parent(tongue_mid_nul, tongue_base_control)", 
                "", 
                "# tongue Tip", 
                "tongue_tip_nul, tongue_tip_control = rig_control.create(name=\"tongue_tip\",", 
                "                                  controlType=None,", 
                "                                  color=rig_common.RED,", 
                "                                  hideAttrs=['sx', 'sy', 'sz', 'v'],", 
                "                                  hierarchy=['nul'],", 
                "                                  type='face')", 
                "", 
                "# make the tongue tip matches the last joint in the chain", 
                "matrix=mc.xform(${joint_list}[-1], q=True, ws=True, matrix=True)", 
                "mc.xform(tongue_tip_nul, ws=True, matrix=matrix)", 
                "", 
                "cluster_list = STAGE.spline._clusters", 
                "mc.parent(tongue_tip_nul, tongue_mid_control)", 
                "mc.parent(cluster_list[2:], tongue_tip_control)", 
                "mc.orientConstraint(tongue_tip_control, STAGE.spline._endTwistNul, mo=1)", 
                "#mc.parentConstraint(tongueTipCtrl, self._skullBind, mo=1)", 
                "#mc.connectAttr(headCtrl+'.s', self._skullBind+'.s')", 
                "", 
                "if mc.objExists(${anchor}):", 
                "    mc.parentConstraint(${anchor}, tongue_base_nul, mo=1)", 
                "else:", 
                "    mc.warning('Anchor object [ {} ] does not exist.'.format(anchor)) ", 
                "", 
                "mc.parent(tongue_base_nul, '${name}')", 
                "mc.hide(STAGE.spline._group, cluster_list)"
            ]
        }, 
        "/tongue/create": {
            "enabled": true, 
            "code": [
                "# create the spline", 
                "STAGE.spline = rig_spline.SplineBase(jointList=${joint_list}, splineName=${spline_name})", 
                "STAGE.spline.create()", 
                "", 
                "# creating this variable so we only have to resolve the data once.", 
                "name = '${name}'", 
                "if not mc.objExists(name):", 
                "    mc.createNode(\"transform\", name=name)", 
                "    # parent the system to the component group if it exists", 
                "    if mc.objExists(${component_parent}):", 
                "        mc.parent(name, ${component_parent})"
            ]
        }
    }
}
