{
    "version": "1.17", 
    "alias": "face_rig", 
    "color": "#99cc33", 
    "mute": false, 
    "solo": false, 
    "meta_data": {
        "positions": {
            "/apply/deformers/clusters/transfer_blink_clusters": [
                0.0, 
                0.0
            ], 
            "/apply/deformers/clusters/transfer_lid_clusters": [
                0.0, 
                0.0
            ], 
            "/apply/deformers/clusters/transfer_lip_cluster": [
                0.0, 
                0.0
            ], 
            "/center/face_lower/jaw/tongue": [
                0.0, 
                0.0
            ], 
            "/center/head_wire": [
                0.0, 
                0.0
            ], 
            "/center/mouth/mouth_main_to_bindmesh": [
                0.0, 
                0.0
            ], 
            "/delivery/convert_to_skinclusters/blink_cluster_skincluster": [
                0.0, 
                0.0
            ], 
            "/delivery/convert_to_skinclusters/face_cluster_skincluster": [
                0.0, 
                0.0
            ], 
            "/delivery/convert_to_skinclusters/face_post_wire_skincluster": [
                0.0, 
                0.0
            ], 
            "/delivery/convert_to_skinclusters/face_pre_cluster_skincluster": [
                0.0, 
                0.0
            ], 
            "/delivery/convert_to_skinclusters/face_wire_skincluster": [
                0.0, 
                0.0
            ], 
            "/delivery/convert_to_skinclusters/lip_bindmesh_post_skincluster": [
                0.0, 
                0.0
            ], 
            "/delivery/convert_to_skinclusters/lip_cluster_skincluster": [
                0.0, 
                0.0
            ], 
            "/face_cluster_control": [
                -1926.060401940699, 
                -1178.9742989595227
            ], 
            "/left/blink": [
                0.0, 
                0.0
            ], 
            "/left/brow": [
                0.0, 
                0.0
            ], 
            "/left/cheek2": [
                0.0, 
                0.0
            ], 
            "/left/cheeks": [
                0.0, 
                0.0
            ], 
            "/left/cheeks/cheek_lift": [
                0.0, 
                0.0
            ], 
            "/left/cheeks/cheek_puff": [
                0.0, 
                0.0
            ], 
            "/left/cheeks/mouth_corner_distance": [
                0.0, 
                0.0
            ], 
            "/left/ear": [
                0.0, 
                0.0
            ], 
            "/left/lip_lower": [
                0.0, 
                0.0
            ], 
            "/left/lip_upper": [
                0.0, 
                0.0
            ], 
            "/mirror_face_wires": [
                -2061.5122146712097, 
                -1805.1401675315192
            ], 
            "/post_build/pick_walking/face": [
                0.0, 
                0.0
            ]
        }, 
        "collapse": {
            "/arm": false, 
            "/arm/limb": false, 
            "/center": false, 
            "/center/face_upper": false, 
            "/center/face_upper/face_mid": false, 
            "/center/face_upper/head_tip": false, 
            "/center/face_upper/nose_bridge": false, 
            "/center/face_upper/teeth_upper": false, 
            "/center/look_at": false, 
            "/center/look_at/create": false, 
            "/center/look_at/create/look_at_trs": false, 
            "/center/look_at/create/look_at_trs/position": false, 
            "/cluster_control": false, 
            "/cluster_control/create": false, 
            "/left": false, 
            "/left/arm": false, 
            "/left/arm/limb": false, 
            "/left/arm/limb/clavicle_connect": false, 
            "/mouth": false, 
            "/mouth/lip_main": false, 
            "/mouth/lip_main/controls": false
        }
    }, 
    "nodes": {
        "/": {
            "child_order": [
                "apply", 
                "center", 
                "face_cluster_control", 
                "left", 
                "mirror_face_wires", 
                "post_build"
            ], 
            "attrs": {
                "brow_l_geo": {
                    "comment": "Left brow geometry name", 
                    "type": "str", 
                    "value": "'brow_r_proxy'"
                }, 
                "brow_r_geo": {
                    "comment": "Right brow geometry name", 
                    "type": "str", 
                    "value": "'brow_l_proxy'"
                }, 
                "eye_l_geo_list": {
                    "comment": "Eye geometry list for the left side", 
                    "type": "list", 
                    "value": "['eyeball_l_geo']"
                }, 
                "eye_r_geo_list": {
                    "comment": "Eye geometry list for the right side", 
                    "type": "list", 
                    "value": "['eyeball_r_geo']"
                }, 
                "face_geo": {
                    "comment": "Name of the geometry that will be used for the face geometry", 
                    "type": "str", 
                    "value": "'body_geo'"
                }, 
                "hair_geo_list": {
                    "comment": "Hair geometry names", 
                    "type": "list", 
                    "value": "['hair_proxy']"
                }, 
                "lash_lower_l_geo": {
                    "comment": "lower lash geometry names for the left side", 
                    "type": "str", 
                    "value": "'lash_lower_l_proxy'"
                }, 
                "lash_lower_r_geo": {
                    "comment": "lower lash geometry names for the right side", 
                    "type": "str", 
                    "value": "'lash_lower_r_proxy'"
                }, 
                "lash_upper_l_geo": {
                    "comment": "upper lash geometry names for the left side", 
                    "type": "str", 
                    "value": "'lash_upper_l_proxy'"
                }, 
                "lash_upper_r_geo": {
                    "comment": "upper lash geometry names for the right side", 
                    "type": "str", 
                    "value": "'lash_upper_r_proxy'"
                }, 
                "teeth_lower_geo_list": {
                    "comment": "Lower teeth geometry name", 
                    "type": "list", 
                    "value": "['teeth_lower_geo', 'gums_lower_geo']"
                }, 
                "teeth_upper_geo_list": {
                    "comment": "Upper teeth geometry name", 
                    "type": "list", 
                    "value": "['teeth_upper_geo', 'gums_upper_geo']"
                }, 
                "tongue_geo": {
                    "comment": "Tongue geometry name", 
                    "type": "str", 
                    "value": "'tongue_geo'"
                }
            }
        }, 
        "/apply": {
            "child_order": [
                "controls", 
                "deformers", 
                "deformer_order", 
                "sdk", 
                "freeze_wire"
            ], 
            "enabled": true
        }, 
        "/apply/deformers/bindmesh": {
            "child_order": [
                "auto_weight", 
                "skincluster", 
                "cluster"
            ], 
            "enabled": true
        }, 
        "/apply/deformers/bindmesh/auto_weight": {
            "enabled": true, 
            "attrs": {
                "source": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "target_list": {
                    "type": "raw", 
                    "value": "mc.ls(['lid*_bindmesh', 'lip*_bindmesh', 'mouth*_bindmesh', 'brow*_bindmesh'])"
                }
            }
        }, 
        "/apply/deformers/clusters": {
            "child_order": [
                "transfer_blink_clusters", 
                "transfer_lid_clusters", 
                "transfer_lip_cluster"
            ], 
            "enabled": true, 
            "comment": "This node will import the clusters and transfer from the face geometry over to the bindmesh geometry and any other geometry you want to transfer cluster to."
        }, 
        "/apply/deformers/clusters/transfer_blink_clusters": {
            "enabled": true, 
            "comment": "Transfers the clusters from the face geometry to the bindmesh geometry for the blink clusters", 
            "attrs": {
                "source": {
                    "comment": "Source geometry to be used for transfer. Where the cluster originates from", 
                    "type": "raw", 
                    "value": "${face_geo}"
                }
            }, 
            "code": [
                "", 
                "source = ${source}", 
                "temp = mc.createNode(\"closestPointOnMesh\", name=\"temp\")", 
                "source_dag = rig_transform.getDagPath(source)", 
                "source_dag.extendToShape()", 
                "mc.connectAttr(\"{}.outMesh\".format(source_dag.fullPathName()), \"{}.inMesh\".format(temp), f=True)", 
                "for side in ['l','r']:", 
                "    for section in ['Upper', 'Lower']:", 
                "        base_wire = \"blink{}_{}_curveBaseWire\".format(section, side)", 
                "        mesh = \"blink{}_{}_bindmesh\".format(section, side)", 
                "        new_cluster_list=rig_cluster.transferCluster(source, mesh, \"blink{}_{}_cluster\".format(section, side), handle=True, surfaceAssociation=\"closestPoint\", createNew=True)", 
                "        for deformer in new_cluster_list:", 
                "            weight_object = rig_weights.getWeights(deformer, geometry=mesh)", 
                "            source_weight_object = rig_weights.getWeights(deformer.split(\"__\")[-1], geometry=source)", 
                "            weight_list = list()", 
                "            ", 
                "            i = 0", 
                "            weights = weight_object.getWeights()[0]", 
                "            source_weights = source_weight_object.getWeights()[0]", 
                "            for wt in weights:", 
                "                j = i", 
                "                if j + 1 >= len(weights):", 
                "                    break", 
                "                # get the closest point on the curve so we can use that to get the closest", 
                "                m_point = rig_curve.getPointOnCurveFromPosition(base_wire, \"{}.cp[{}]\".format(mesh, j))", 
                "                mc.setAttr(\"{}.inPosition\".format(temp), m_point.x, m_point.y, m_point.z)", 
                "                vert_id = mc.getAttr(\"{}.closestVertexIndex\".format(temp))", 
                "                weight_value = source_weights[vert_id]", 
                "                while i <= j + 3:", 
                "                    weights[i] = weight_value", 
                "                    i +=1", 
                "                    ", 
                "            weight_list.append(weights)", 
                "            weight_object.setWeights(weight_list)", 
                "            rig_weights.setWeights(deformer, weight_object, geometry=mesh)", 
                "                ", 
                "        # now we will transfer the wts", 
                "        #mc.copyDeformerWeights(ss=mesh, ds=base_wire, sd=\"blink{}_{}_bindmesh__blink{}_{}_cluster\".format(section, side, section, side), dd=\"blink{}_{}_curveBaseWire__blink{}_{}_cluster\".format(section, side, section, side), sa=\"closestPoint\", noMirror=True)", 
                "mc.delete(temp)", 
                ""
            ]
        }, 
        "/apply/deformers/clusters/transfer_lid_clusters": {
            "enabled": true, 
            "attrs": {
                "source": {
                    "comment": "Source geometry to be used for transfer. Where the cluster originates from", 
                    "type": "raw", 
                    "value": "${face_geo}"
                }
            }, 
            "code": [
                "source = ${source}", 
                "temp = mc.createNode(\"closestPointOnMesh\", name=\"temp\")", 
                "sourceDag = rig_transform.getDagPath(source)", 
                "sourceDag.extendToShape()", 
                "mc.connectAttr(\"%s.outMesh\" % (sourceDag.fullPathName()), \"%s.inMesh\" % (temp), f=True)", 
                "deltamush = mc.deltaMush(source,smoothingIterations=10,smoothingStep=1.0, pinBorderVertices=True,envelope=1, foc=True)[0]", 
                "mc.setAttr(deltamush+\".displacement\", 0)", 
                "for side in ['l','r']:", 
                "    mesh = \"lid_%s_bindmesh\" % (side)", 
                "    curve = \"lid_%s_curve\" % (side)", 
                "    new_cluster_list = list()", 
                "    new_cluster_list.extend(mc.ls(\"%s*socketStretch_%s_cluster\" % (mesh,side)))", 
                "    for section in ['Upper', 'Lower']: ", 
                "        new_cluster_list.extend(rig_cluster.transferCluster(source, mesh, \"blink%s_%s_cluster\" % (section, side), handle=True, surfaceAssociation=\"closestPoint\", createNew=True))", 
                "        ", 
                "    for deformer in new_cluster_list:", 
                "        weight_object = rig_weights.getWeights(deformer, geometry=mesh)", 
                "        source_weight_object = rig_weights.getWeights(deformer.split(\"__\")[-1], geometry=source)", 
                "        weight_list = list()", 
                "        i = 0", 
                "        weights = weight_object.getWeights()[0]", 
                "        sourceWeights = source_weight_object.getWeights()[0]", 
                "        for wt in weights:", 
                "            j = i", 
                "            if j + 1 >= len(weights):", 
                "                break", 
                "            # get the closest point on the curve so we can use that to get the closest", 
                "            m_point = rig_curve.getPointOnCurveFromPosition(curve, \"%s.cp[%s]\" % (mesh, j))", 
                "            mc.setAttr(\"%s.inPosition\" % (temp), m_point.x, m_point.y, m_point.z)", 
                "            vert_id = mc.getAttr(\"%s.closestVertexIndex\" % (temp))", 
                "            weight_value = sourceWeights[vert_id]", 
                "            while i <= j + 3:", 
                "                weights[i] = weight_value", 
                "                i +=1", 
                "                ", 
                "        weight_list.append(weights)", 
                "        weight_object.setWeights(weight_list)", 
                "        rig_weights.setWeights(deformer, weight_object, geometry=mesh)", 
                "", 
                "mc.delete(deltamush)", 
                "mc.delete(temp)", 
                ""
            ]
        }, 
        "/apply/deformers/clusters/transfer_lip_cluster": {
            "enabled": true, 
            "attrs": {
                "deformer_list": {
                    "type": "list", 
                    "value": "['lip_upper_cluster', 'lip_lower_cluster', 'lip_upper_translate_cluster', 'lip_lower_translate_cluster', 'lip_upper_?_cluster', 'lip_lower_?_cluster']"
                }, 
                "localize_list": {
                    "type": "list", 
                    "value": "['lip_upper_auto', 'lip_lower_auto', 'lip_upper_translate_auto', 'lip_lower_translate_auto', 'lip_upper_?_auto', 'lip_lower_?_auto']"
                }, 
                "source": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "target": {
                    "type": "str", 
                    "value": "'lip_bindmesh'"
                }
            }, 
            "code": [
                "source = ${source}", 
                "target = ${target}", 
                "deltamush = mc.deltaMush(source, smoothingIterations=10,smoothingStep=1.0, pinBorderVertices=True,envelope=1, foc=True)[0]", 
                "mc.setAttr(deltamush+\".displacement\", 0)", 
                "for cluster, localNode in zip(mc.ls(${deformer_list}), mc.ls(${localize_list})):", 
                "    new_cluster_list=rig_cluster.transferCluster(source, target, cluster, handle=True, surfaceAssociation=\"closestPoint\", createNew=True)", 
                "    for deformer in new_cluster_list:", 
                "        weight_object = rig_weights.getWeights(deformer, geometry=target)", 
                "        source_weight_object = rig_weights.getWeights(deformer.split(\"__\")[-1], geometry=source)", 
                "        rig_cluster.localize(deformer, localNode, \"model\")", 
                "        weight_list = list()", 
                "mc.delete(deltamush)", 
                ""
            ]
        }, 
        "/apply/freeze_wire": {
            "child_order": [
                "freeze_wire_expression"
            ], 
            "attrs": {
                "refresh_wire_list": {
                    "type": "list", 
                    "value": "['lip_wire', 'lip_main_wire', 'lid*wire']"
                }, 
                "skip_wire_list": {
                    "comment": "List of wires you don't want to freeze", 
                    "type": "list", 
                    "value": "['head_wire', 'head_low_wire']"
                }, 
                "wire_list": {
                    "type": "raw", 
                    "value": "mc.ls(list(set(mc.listHistory(${body_geo}) + mc.listHistory(${face_geo}))), type=\"wire\")"
                }
            }, 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    controls = rig_control.getControls()", 
                "    if controls:", 
                "        # Got to bind pose", 
                "        rig_control.toPoseAttr(controls, 0)", 
                "    if mc.objExists('jaw'):", 
                "        mc.setAttr('jaw.rx', -15)", 
                "        ", 
                "    for node in mc.ls('*_blendshape'):", 
                "        mc.setAttr('{}.envelope'.format(node), 0)", 
                "    ", 
                "    for deformer in ${wire_list}:", 
                "        if deformer in ${skip_wire_list}:", 
                "            continue", 
                "        mc.setAttr(\"{}.freezeGeometry\".format(deformer), 0)", 
                "        mc.setAttr(\"{}.freezeGeometry\".format(deformer), 1)", 
                "        ", 
                "    # Doing lips again after because freezing other wires after seems to ", 
                "    refresh_wire_list = mc.ls(${refresh_wire_list})", 
                "    for deformer in refresh_wire_list:", 
                "        mc.setAttr(\"{}.freezeGeometry\".format(deformer), 0)", 
                "        mc.refresh()", 
                "        mc.setAttr(\"{}.freezeGeometry\".format(deformer), 1)", 
                "    ", 
                "    # set poseAttr for freezing when rig is loaded.", 
                "    rig_control.setPoseAttr(controls, 9)", 
                "    if controls:", 
                "        # Got to bind pose", 
                "        rig_control.toPoseAttr(controls, 0)", 
                "        ", 
                "    if mc.objExists('jaw'):", 
                "        mc.setAttr('jaw.rx', 0)", 
                "        ", 
                "    for node in mc.ls('*_blendshape'):", 
                "        mc.setAttr('{}.envelope'.format(node), 1)", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                ""
            ]
        }, 
        "/apply/freeze_wire/freeze_wire_expression": {
            "instance": "", 
            "enabled": true, 
            "comment": "This will freeze the wire at a specific pose that you will want to make sure works for you character.", 
            "code": [
                "mc.scriptNode(st=1, sourceType=\"python\", bs=\"\"\"", 
                "import maya.cmds as mc", 
                "cmd = '''import maya.cmds as mc", 
                "from collections import OrderedDict", 
                "def getControls():", 
                "    controls = mc.ls('*.__control__'.format() ,o=True, fl=True)", 
                "    if not controls:", 
                "        controls = mc.ls('*:*.__control__', fl=True,o=True)", 
                "", 
                "    return controls", 
                "", 
                "def setPoseAttr(controls, poseAttr=0):", 
                "    skipAttrs = (\"message\")", 
                "    for ctrl in controls:", 
                "        # store the attribute names", 
                "        ctrlPoseAttr = \"{}.poseAttr_{}\".format(ctrl,poseAttr)", 
                "        poseAttrName = ctrlPoseAttr.split(\".\")[-1]", 
                "        ctrlAttrDict = OrderedDict()", 
                "", 
                "        # go through each attribute and store it in the dictionary", 
                "        for attr in mc.listAttr(ctrl, keyable=True):", 
                "            if not mc.getAttr(\"{}.{}\".format(ctrl,attr),type=True) in skipAttrs:", 
                "                ctrlAttrDict[str(attr)] = mc.getAttr(\"{}.{}\".format(ctrl,attr))", 
                "", 
                "        # if the pose doesn't exist, then we will create it.", 
                "        if not poseAttrName in mc.listAttr(ctrl):", 
                "            mc.addAttr(ctrl, ln=poseAttrName, dt= \"string\")", 
                "", 
                "        # set the attribute", 
                "        mc.setAttr(ctrlPoseAttr, str(ctrlAttrDict), type=\"string\")", 
                "", 
                "def toPoseAttr(controls, poseAttr=0):", 
                "    # loop throught the controls and try and set the attributes back to the way they were stored.", 
                "    for ctrl in controls:", 
                "        ctrlPoseAttr = \"{}.poseAttr_{}\".format(ctrl,poseAttr)", 
                "        poseAttrName = ctrlPoseAttr.split(\".\")[-1]", 
                "", 
                "        # check to see if the attribute exists.", 
                "        if not poseAttrName in mc.listAttr(ctrl):", 
                "            continue", 
                "", 
                "        # if the attribute exists then we can eval it into an OrderedDict        ", 
                "        ctrlAttrDict = eval(mc.getAttr(ctrlPoseAttr))", 
                "", 
                "        # loop through the attributes and set them if we can.", 
                "        for attr in ctrlAttrDict:", 
                "            try:", 
                "                # set the attributes if we can.", 
                "                mc.setAttr(\"{}.{}\".format(ctrl,attr), ctrlAttrDict[attr])", 
                "            except:", 
                "                # raise a warning for now if we can't set it. ", 
                "                #Usually this is because it's connected or locked.", 
                "                pass", 
                "", 
                "", 
                "controlList = getControls()", 
                "autoKeyframeState = mc.autoKeyframe(q=True, state=True)", 
                "mc.autoKeyframe(state=False)", 
                "setPoseAttr(controlList, poseAttr=10) ", 
                "for wire in ${wire_list}:", 
                "    mc.setAttr(\"{}.freezeGeometry\".format(wire), 0)", 
                "    ", 
                "psdNodes = mc.ls('*_blendshape', r=1)", 
                "psdValues = {}", 
                "for psd in psdNodes:", 
                "    psdValues[psd] = mc.getAttr(psd+'.envelope')", 
                "    mc.setAttr(psd+'.envelope', 0)", 
                "", 
                "toPoseAttr(controlList, 9)", 
                "mc.refresh()", 
                "for wire in ${wire_list}:", 
                "    if wire in ${skip_wire_list}:", 
                "        continue", 
                "    mc.setAttr(\"{}.freezeGeometry\".format(wire), 1)", 
                "    ", 
                "toPoseAttr(controlList,10)", 
                "", 
                "for ctrl in controlList:", 
                "    mc.deleteAttr(\"{}.poseAttr_10\".format(ctrl))", 
                "    ", 
                "for psd in psdNodes:", 
                "    mc.setAttr(psd+'.envelope', psdValues[psd])", 
                "    ", 
                "mc.autoKeyframe(state=autoKeyframeState)", 
                "'''", 
                "mc.evalDeferred(cmd)", 
                "\"\"\", n='poseFreeze')", 
                "        "
            ]
        }, 
        "/center": {
            "child_order": [
                "spine", 
                "neck", 
                "face_lower", 
                "face_upper", 
                "mouth", 
                "look_at", 
                "head_wire"
            ], 
            "enabled": true
        }, 
        "/center/face_lower": {
            "instance": "", 
            "child_order": [
                "jaw", 
                "mouth_main"
            ], 
            "enabled": true, 
            "attrs": {
                "face_lower": {
                    "type": "str", 
                    "value": "'face_lower'"
                }, 
                "face_lower_joint": {
                    "type": "str", 
                    "value": "'face_lower_bind'"
                }, 
                "hide_attributes": {
                    "type": "list", 
                    "value": "[\"v\", \"sx\", \"sy\", \"sz\"]"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "jaw_joint": {
                    "type": "str", 
                    "value": "'jaw_bind'"
                }, 
                "lip_lower": {
                    "type": "str", 
                    "value": "'lip_lower'"
                }, 
                "mouth_main": {
                    "type": "str", 
                    "value": "'mouthMain'"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${/center/neck.skull_control}+'_grp'"
                }, 
                "teeth_lower": {
                    "type": "str", 
                    "value": "'teeth_lower'"
                }, 
                "teeth_lower_joint": {
                    "type": "str", 
                    "value": "'teeth_lower_bind'"
                }
            }, 
            "code": [
                " # FACE LOWER", 
                "if mc.objExists(${face_lower_joint}):", 
                "    # Create the faceLower and jaw control", 
                "    face_lower_nul, face_lower_ctrl = rig_control.create(name=${face_lower}, ", 
                "                                      controlType=\"null\",", 
                "                                      color=rig_common.YELLOW,", 
                "                                      hierarchy=${hierarchy},", 
                "                                      parent=${parent},", 
                "                                      type='face')", 
                "", 
                "    rig_attribute.lockAndHide(face_lower_ctrl ,${hide_attributes})", 
                "    # position the faceLowerNul and connect the joint to the control", 
                "    mc.xform(face_lower_nul, ws=True, matrix=mc.xform(${face_lower_joint}, q=True, ws=True, matrix=True))", 
                "    mc.pointConstraint(face_lower_ctrl, ${face_lower_joint})", 
                "    mc.orientConstraint(face_lower_ctrl, ${face_lower_joint})"
            ]
        }, 
        "/center/face_lower/jaw": {
            "child_order": [
                "sdk", 
                "lip_lower", 
                "lip_lower_translate", 
                "teeth_lower", 
                "tongue"
            ], 
            "enabled": true, 
            "attrs": {
                "hide_attributes": {
                    "type": "list", 
                    "value": "[\"v\", \"sx\", \"sy\", \"sz\"]"
                }, 
                "jaw": {
                    "type": "str", 
                    "value": "'jaw'"
                }
            }, 
            "code": [
                "# JAW", 
                "if mc.objExists(${jaw_joint}):", 
                "    # create the jaw control ", 
                "    jaw_nul, jaw_def_auto, jaw_ctrl = rig_control.create(name=${jaw}, ", 
                "                                      controlType=\"null\",", 
                "                                      color=rig_common.YELLOW,", 
                "                                      hierarchy=['nul', 'def_auto'],", 
                "                                      type='face')", 
                "", 
                "    rig_attribute.lockAndHide(jaw_ctrl ,${hide_attributes})", 
                "", 
                "    # position the jaw control and connect the joint to the control", 
                "    mc.xform(jaw_nul, ws=True, matrix=mc.xform(${jaw_joint}, q=True, ws=True, matrix=True))", 
                "    mc.pointConstraint(jaw_ctrl, ${jaw_joint})", 
                "    mc.orientConstraint(jaw_ctrl, ${jaw_joint})", 
                "    # create jaw driver, parent it to the jaw nul, then move it to the correct position", 
                "    jaw_driver = mc.createNode(\"joint\", name=\"{}_driver\".format(${jaw}))", 
                "    mc.parent(jaw_driver, jaw_nul)", 
                "    mc.xform(jaw_driver, ws=True, matrix=mc.xform(jaw_nul, q=True, ws=True, matrix=True))", 
                "    mc.orientConstraint(jaw_ctrl, jaw_driver)", 
                "    # create normRX on the driver", 
                "    mc.addAttr(jaw_driver, ln=\"normRX\", at=\"double\", keyable=True)", 
                "    mult_jaw = mc.createNode(\"multDoubleLinear\", name=\"{}_driver_norm_mult\".format(${jaw}))", 
                "    mc.connectAttr(\"{}.rx\".format(${jaw_joint}), \"{}.input1\".format(mult_jaw), f=True)", 
                "    mc.setAttr(\"{}.input2\".format(mult_jaw), .1)", 
                "    mc.connectAttr(\"{}.output\".format(mult_jaw), \"{}.normRX\".format(jaw_driver), f=True)", 
                "    # turn off the visibility of the driver", 
                "    mc.setAttr(\"{}.drawStyle\".format(jaw_driver), 2)", 
                "    ", 
                "    if mc.objExists(${face_lower}):", 
                "        mc.parent(jaw_nul, ${face_lower})"
            ]
        }, 
        "/center/face_lower/jaw/lip_lower": {
            "enabled": true, 
            "code": [
                "# create the lip lower cluster", 
                "if mc.objExists(${jaw}):", 
                "    rig_cluster.create(${face_geo}, name=${lip_lower}, parent=${jaw})", 
                "", 
                "    # rename the cluster and control                                    ", 
                "    mc.rename(${lip_lower}, '{}_cluster'.format(${lip_lower}))", 
                "    mc.rename('{}_ctrl'.format(${lip_lower}), ${lip_lower})", 
                "    mc.xform(\"{}_nul\".format(${lip_lower}), ws=True, matrix=mc.xform(${jaw}, q=True, ws=True, matrix=True))", 
                "    mc.setAttr(\"{}.displayHandle\".format(${lip_lower}), 1)", 
                "    rig_control.tagAsControl(${lip_lower}, type='face')", 
                "    rig_attribute.lockAndHide([${lip_lower}], ['v'])"
            ]
        }, 
        "/center/face_lower/jaw/lip_lower_translate": {
            "code": [
                "if mc.objExists(${jaw}):", 
                "    # cluster just for translation", 
                "    cluster_name = '{}_translate'.format(${lip_lower})", 
                "    rig_cluster.create(${face_geo}, name=cluster_name, parent=${jaw})", 
                "    mc.rename(cluster_name, '{}_cluster'.format(cluster_name))", 
                "    mc.xform(\"{}_nul\".format(cluster_name), ws=True, matrix=mc.xform(${jaw}, q=True, ws=True, matrix=True))", 
                "", 
                "    # ort connect", 
                "    mc.connectAttr(${lip_lower}+'_ort.t', cluster_name+'_ort.t')", 
                "    mc.connectAttr(${lip_lower}+'_ort.r', cluster_name+'_ort.r')", 
                "    mc.connectAttr(${lip_lower}+'_ort.s', cluster_name+'_ort.s')", 
                "    ", 
                "    # Remove lip lower anim controls connection to it's own cluster so it can be hooked up to this new tranlsate cluster.", 
                "    mc.delete(mc.pointConstraint(${lip_lower}+'_cls_hdl', q=1))", 
                "    ", 
                "    # Now connect the lip lower anim control to translate only cluster", 
                "    mc.connectAttr(${lip_lower}+'.t', ${lip_lower}+'_translate_ctrl.t')", 
                "", 
                "    ", 
                ""
            ]
        }, 
        "/center/face_lower/jaw/sdk": {
            "code": [
                "if mc.objExists(${jaw}):", 
                "    if mc.objExists('{}_def_auto'.format(${jaw})):", 
                "        # create the setDriven keys for the jaw control auto null", 
                "        mc.setDrivenKeyframe(\"{}_def_auto.tz\".format(${jaw}), ", 
                "                        cd=\"{}.rx\".format(${jaw}), v=.25, dv=-15, ott='flat', itt='flat')", 
                "        mc.setDrivenKeyframe(\"{}_def_auto.tz\".format(${jaw}), ", 
                "                        cd=\"{}.rx\".format(${jaw}), v=-0, dv=0)", 
                "        mc.setInfinity('{}_def_auto'.format(${jaw}), at='.tz', pri= 'linear', poi= 'linear')", 
                "", 
                "    if mc.objExists('{}_def_auto'.format(${jaw})):", 
                "        # create the setDriven keys for the jaw driver (for the purpose of jaw PSD combos)", 
                "        mc.setDrivenKeyframe(\"{}_driver.tx\".format(${jaw}), ", 
                "                        cd=\"{}.rx\".format(${jaw}), v=0.0, dv=0.0, ott='clamped', itt='clamped')", 
                "        mc.setDrivenKeyframe(\"{}_driver.tx\".format(${jaw}), ", 
                "                        cd=\"{}.rx\".format(${jaw}), v=-1.0, dv=30.0, ott='clamped', itt='clamped')", 
                "        mc.setInfinity('{}_driver'.format(${jaw}), at='.tx', pri= 'linear', poi= 'linear')", 
                "     "
            ]
        }, 
        "/center/face_lower/jaw/teeth_lower": {
            "enabled": true, 
            "attrs": {
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'def_auto']"
                }
            }, 
            "code": [
                "# Lower teeth control", 
                "if mc.objExists(${teeth_lower_joint}) and mc.objExists(${jaw}):", 
                "    teeth_lower_nul, teeth_lower_def_auto, teeth_lower_ctrl = rig_control.create(name=${teeth_lower}, ", 
                "                                                          controlType=\"null\",", 
                "                                                          color=rig_common.RED,", 
                "                                                          hierarchy=${hierarchy},", 
                "                                                          parent=${jaw},", 
                "                                                          type='face')", 
                "", 
                "    mc.xform(teeth_lower_nul, ws=True, matrix=mc.xform(${teeth_lower_joint}, q=True, ws=True, matrix=True))", 
                "    mc.pointConstraint(teeth_lower_ctrl, ${teeth_lower_joint})", 
                "    mc.orientConstraint(teeth_lower_ctrl, ${teeth_lower_joint})", 
                "    mc.connectAttr('{}.s'.format(teeth_lower_ctrl), '{}.s'.format(${teeth_lower_joint}), f=True)"
            ]
        }, 
        "/center/face_lower/jaw/tongue": {
            "instance": "/tongue", 
            "enabled": true
        }, 
        "/center/face_lower/mouth_main": {
            "enabled": true, 
            "code": [
                "if mc.objExists(${face_lower}):", 
                "    rig_cluster.create(${face_geo}, name=${mouth_main}, parent=${face_lower})", 
                "", 
                "    # rename the cluster and control                                    ", 
                "    mc.rename(${mouth_main}, '{}_cluster'.format(${mouth_main}))", 
                "    mc.rename('{}_ctrl'.format(${mouth_main}), ${mouth_main})", 
                "    mc.xform(\"{}_nul\".format(${mouth_main}), ws=True, matrix=mc.xform(${face_lower}, q=True, ws=True, matrix=True))", 
                "    mc.setAttr(\"{}.displayHandle\".format(${mouth_main}), 1)", 
                "    rig_control.tagAsControl(${mouth_main}, type='face')", 
                "    rig_attribute.lockAndHide(${mouth_main}, 'v')"
            ]
        }, 
        "/center/face_upper": {
            "instance": "", 
            "child_order": [
                "nose_bridge", 
                "face_mid", 
                "head_tip"
            ], 
            "enabled": true, 
            "attrs": {
                "face_lower": {
                    "type": "raw", 
                    "value": "${/center/face_lower.face_lower}"
                }, 
                "face_mid": {
                    "type": "str", 
                    "value": "'face_mid'"
                }, 
                "face_mid_driver": {
                    "type": "str", 
                    "value": "'face_mid_driver'"
                }, 
                "face_mid_joint": {
                    "type": "str", 
                    "value": "'face_mid_bind'"
                }, 
                "face_upper": {
                    "type": "str", 
                    "value": "'face_upper'"
                }, 
                "face_upper_joint": {
                    "type": "str", 
                    "value": "'face_upper_bind'"
                }, 
                "head_tip": {
                    "type": "str", 
                    "value": "'head_tip'"
                }, 
                "head_tip_joint": {
                    "type": "str", 
                    "value": "'head_tip_bind'"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "jaw": {
                    "type": "raw", 
                    "value": "${/center/face_lower/jaw.jaw}"
                }, 
                "jaw_compression_joint": {
                    "type": "str", 
                    "value": "'jaw_compression_driver'"
                }, 
                "jaw_joint": {
                    "type": "raw", 
                    "value": "${/center/face_lower.jaw_joint}"
                }, 
                "lip_upper": {
                    "type": "str", 
                    "value": "'lip_upper'"
                }, 
                "nose": {
                    "type": "str", 
                    "value": "'nose'"
                }, 
                "nose_bridge": {
                    "type": "str", 
                    "value": "'nose_bridge'"
                }, 
                "nose_bridge_joint": {
                    "type": "str", 
                    "value": "'nose_bridge_bind'"
                }, 
                "nose_joint": {
                    "type": "str", 
                    "value": "'nose_bind'"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${/center/face_lower.parent}"
                }, 
                "skull_joint": {
                    "type": "str", 
                    "value": "'skull_bind'"
                }, 
                "teeth_lower": {
                    "type": "raw", 
                    "value": "${/center/face_lower.teeth_lower}"
                }, 
                "teeth_upper": {
                    "type": "str", 
                    "value": "'teeth_upper'"
                }, 
                "teeth_upper_joint": {
                    "type": "str", 
                    "value": "'teeth_upper_bind'"
                }
            }, 
            "code": [
                "if mc.objExists(${face_upper_joint}):", 
                "    # Create the faceLower and jaw control", 
                "    face_upper_nul, face_upper_ctrl = rig_control.create(name=\"face_upper\", ", 
                "                                      controlType=\"null\",", 
                "                                      color=rig_common.YELLOW,", 
                "                                      hierarchy=${hierarchy},", 
                "                                      parent=${parent},", 
                "                                      type='face')", 
                "", 
                "    rig_attribute.lockAndHide(face_upper_ctrl,[\"v\", \"sx\", \"sy\", \"sz\"])", 
                "    # position the faceLowerNul and connect the joint to the control", 
                "    mc.xform(face_upper_nul, ws=True, matrix=mc.xform(${face_upper_joint}, q=True, ws=True, matrix=True))", 
                "    mc.pointConstraint(face_upper_ctrl, ${face_upper_joint})", 
                "    mc.orientConstraint(face_upper_ctrl, ${face_upper_joint})", 
                "", 
                "    # setup the jaw compression", 
                "    if not mc.objExists(${jaw_compression_joint}):", 
                "        mc.joint(name=${jaw_compression_joint})", 
                "        mc.xform(${jaw_compression_joint}, ws=True, q=True, rotation=mc.xform(${jaw_compression_joint}, q=True, ws=True, rotation=True))", 
                "        mc.xform(${jaw_compression_joint}, ws=True, t=rig_transform.getAveragePosition([${teeth_upper}, ${teeth_lower}]))", 
                "", 
                "    # create the faceDiff joint and parent it to the faceUpperCtrl", 
                "    face_diff = mc.duplicate(${jaw_compression_joint}, po=True, name=\"face_upper_diff\")[0]", 
                "    mc.parent(face_diff, ${face_upper})", 
                "    parent = ${rig_group}", 
                "    group_list = [\"jaw_compression_grp\", \"jaw_compression_nul\", \"jaw_compression_cnt\", \"jaw_compressiong_offset\"]", 
                "    for group in group_list:", 
                "        mc.createNode(\"transform\", name=group)", 
                "        mc.parent(group, parent)", 
                "        parent = group", 
                "", 
                "    # position the jaw groups ", 
                "    mc.parentConstraint(${skull_joint}, group_list[0], mo=False)", 
                "    mc.xform(group_list[1], ws=True, matrix=mc.xform(${jaw_joint}, q=True, ws=True, matrix=True))", 
                "    for attr in ['t', 'r', 's']:", 
                "        mc.connectAttr(\"{}.{}\".format(${jaw},attr), \"{}.{}\".format(group_list[2],attr), f=True)", 
                "", 
                "    mc.xform(group_list[-1], ws=True, matrix=mc.xform(${jaw_compression_joint}, q=True, ws=True, matrix=True))", 
                "    # parent the jawCompression joint to the last of the group nodes", 
                "    mc.parent(${jaw_compression_joint}, group_list[-1])", 
                "    # point constrain the jawCompression joint to the faceDiff joint", 
                "    mc.pointConstraint(face_diff, ${jaw_compression_joint}, mo=False)", 
                "", 
                "    # turn off the visibility of the joints", 
                "    for jnt in [face_diff, ${jaw_compression_joint}]:", 
                "        mc.setAttr(\"{}.v\".format(jnt), 0)"
            ]
        }, 
        "/center/face_upper/face_mid": {
            "child_order": [
                "lip_upper", 
                "lip_upper_translate", 
                "lip_curl", 
                "teeth_upper"
            ], 
            "enabled": true, 
            "code": [
                "parent = ${face_lower}", 
                "group_list = [\"face_mid_nul\", \"face_upper_driver\", \"face_mid_offset\", \"face_mid_ort\", \"face_mid_def_auto\"]", 
                "for group in group_list:", 
                "    mc.createNode(\"transform\", name=group)", 
                "    mc.parent(group, parent)", 
                "    parent = group", 
                "", 
                "# make the driver joint and parent it to the def auto and turn off visibility", 
                "mid_driver = mc.joint(name=${face_mid_driver})", 
                "mc.setAttr(\"{}.drawStyle\".format(${face_mid_driver}), 2 )", 
                "", 
                "mc.xform(group_list[0], ws=True, matrix=mc.xform(${face_upper}, q=True, ws=True, matrix=True))", 
                "for attr in ['t', 'r', 's']:", 
                "    mc.connectAttr(\"{}.{}\".format(${face_upper}, attr), \"{}.{}\".format(group_list[1],attr), f=True)", 
                "mc.xform(group_list[2], ws=True, matrix=mc.xform(${face_mid_joint}, q=True, ws=True, matrix=True))", 
                "# create the set drivens", 
                "if mc.objExists(${face_upper_joint}):", 
                "    # create the setDriven keys for the jaw control", 
                "    mc.setDrivenKeyframe(\"{}.rx\".format(group_list[-1]), ", 
                "                    cd=\"{}.ty\".format(${jaw_compression_joint}), v=10, dv=-0.7)", 
                "    mc.setDrivenKeyframe(\"{}.rx\".format(group_list[-1]), ", 
                "                    cd=\"{}.ty\".format(${jaw_compression_joint}), v=-0, dv=0)", 
                "    for attr in ['y', 'z']:", 
                "        mc.setDrivenKeyframe(\"{}.t{}\".format(group_list[-1],attr), ", 
                "                        cd=\"{}.ty\".format(${jaw_compression_joint}), v=-1, dv=-0.7)", 
                "        mc.setDrivenKeyframe(\"{}.t{}\".format(group_list[-1],attr), ", 
                "                        cd=\"{}.ty\".format(${jaw_compression_joint}), v=0, dv=0)", 
                "", 
                "# constrain the joint to the driver", 
                "mc.pointConstraint(mid_driver, ${face_mid_joint}, mo=False)", 
                "mc.orientConstraint(mid_driver, ${face_mid_joint}, mo=False)", 
                ""
            ]
        }, 
        "/center/face_upper/face_mid/lip_curl": {
            "attrs": {
                "curl_attr": {
                    "type": "str", 
                    "value": "'curl'"
                }
            }, 
            "code": [
                "upper_control = ${lip_upper}", 
                "lower_control = ${../../../face_lower.lip_lower}", 
                "", 
                "curl_attr = ${curl_attr}", 
                "", 
                "upperCurl = upper_control+'.'+curl_attr", 
                "lowerCurl = lower_control+'.'+curl_attr", 
                "", 
                "#create curl attrs on controls", 
                "mc.addAttr(upper_control, ln=curl_attr, at='double', dv=0, k=1)", 
                "mc.addAttr(lower_control, ln=curl_attr, at='double', dv=0, k=1)", 
                "", 
                "#reverse direction of upper lip curl", 
                "mul = mc.createNode('multiplyDivide', n='{}_slide_rx_mul'.format(upper_control))", 
                "mc.setAttr('{}.input2X'.format(mul), -1)", 
                "mc.connectAttr(upperCurl, '{}.input1X'.format(mul), f=True)", 
                "", 
                "# Connect output into def_autos of the lip upper", 
                "mc.connectAttr('{}.outputX'.format(mul), upper_control+'_cls_hdl.rotateAxisX', f=True)", 
                "", 
                "# Connect output into def_autos of the lower upper", 
                "mc.connectAttr(lowerCurl, lower_control+'_cls_hdl.rotateAxisX', f=1)"
            ]
        }, 
        "/center/face_upper/face_mid/lip_upper": {
            "instance": "/face_cluster_control", 
            "child_order": [
                "create", 
                "align_orientation"
            ], 
            "enabled": true, 
            "attrs": {
                "control_name": {
                    "type": "raw", 
                    "value": "${lip_upper}"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v']"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul','ort']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${face_mid_driver}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }, 
            "code": [
                ""
            ]
        }, 
        "/center/face_upper/face_mid/lip_upper/align_orientation": {
            "attrs": {
                "align_to_node": {
                    "value": "''"
                }, 
                "scale_offset": {
                    "type": "tuple", 
                    "value": "(1, 1, 1)"
                }
            }
        }, 
        "/center/face_upper/face_mid/lip_upper_translate": {
            "code": [
                "if mc.objExists(${face_mid_driver}):", 
                "    # cluster just for translation", 
                "    cluster_name = '{}_translate'.format(${lip_upper})", 
                "    rig_cluster.create(${face_geo}, name=cluster_name, parent=${face_mid_driver})", 
                "    mc.rename(cluster_name, '{}_cluster'.format(cluster_name))", 
                "    mc.xform(\"{}_nul\".format(cluster_name), ws=True, matrix=mc.xform(${face_mid_driver}, q=True, ws=True, matrix=True))", 
                "", 
                "    # Remove lip upper anim controls connection to it's own cluster so it can be hooked up to this new tranlsate cluster.", 
                "    mc.delete(mc.pointConstraint(${lip_upper}+'_cls_hdl', q=1))", 
                "    ", 
                "    mc.connectAttr(${lip_upper}+'_ort.t', ${lip_upper}+'_translate_ort.t')", 
                "    mc.connectAttr(${lip_upper}+'_ort.r', ${lip_upper}+'_translate_ort.r')", 
                "", 
                "    # Now connect the lip upper anim control to translate only cluster", 
                "    mc.connectAttr(${lip_upper}+'.t', ${lip_upper}+'_translate_ctrl.t')", 
                "    ", 
                ""
            ]
        }, 
        "/center/face_upper/face_mid/teeth_upper": {
            "enabled": true, 
            "attrs": {
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'def_auto']"
                }
            }, 
            "code": [
                "if mc.objExists(${teeth_upper_joint}):", 
                "    teeth_upper_nul, teeth_upper_def_auto, teeth_upper_ctrl = rig_control.create(name=${teeth_upper}, ", 
                "                                                          controlType=\"null\",", 
                "                                                          color=rig_common.RED,", 
                "                                                          hierarchy=${hierarchy},", 
                "                                                          parent=${face_mid_driver},", 
                "                                                          type='face')", 
                "", 
                "    mc.xform(teeth_upper_nul, ws=True, matrix=mc.xform(${teeth_upper_joint}, q=True, ws=True, matrix=True))", 
                "    mc.pointConstraint(teeth_upper_ctrl, ${teeth_upper_joint})", 
                "    mc.orientConstraint(teeth_upper_ctrl, ${teeth_upper_joint})", 
                "    mc.scaleConstraint(teeth_upper_ctrl, ${teeth_upper_joint})"
            ]
        }, 
        "/center/face_upper/head_tip": {
            "instance": "/control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "align_to_node": {
                    "type": "raw", 
                    "value": "${head_tip_joint}"
                }, 
                "color": {
                    "type": "raw", 
                    "value": "rig_common.YELLOW"
                }, 
                "control_name": {
                    "type": "raw", 
                    "value": "${head_tip}"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "[\"v\", \"sx\", \"sy\", \"sz\"]"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${face_upper}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/center/face_upper/head_tip/connect": {
            "enabled": true, 
            "code": [
                "mc.pointConstraint(${control_name}, ${head_tip_joint})", 
                "mc.orientConstraint(${control_name}, ${head_tip_joint})"
            ]
        }, 
        "/center/face_upper/nose_bridge": {
            "child_order": [
                "sdk", 
                "nose"
            ], 
            "enabled": true, 
            "attrs": {
                "hide_attributes": {
                    "type": "list", 
                    "value": "[\"v\", \"sx\", \"sy\", \"sz\"]"
                }, 
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'def_auto', 'rot_def_auto']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'face_upper'"
                }
            }, 
            "code": [
                "if mc.objExists(${nose_bridge_joint}):", 
                "    # Create the faceLower and jaw control", 
                "    nose_bridge_nul, nose_bridge_def_auto, nose_bridge_rot_def_auto, nose_bridge_ctrl = rig_control.create(name=${nose_bridge}, ", 
                "                                      controlType=\"null\",", 
                "                                      color=rig_common.YELLOW,", 
                "                                      hierarchy=${hierarchy},", 
                "                                      type='face')", 
                "", 
                "    rig_attribute.lockAndHide(nose_bridge_ctrl, ${hide_attributes})", 
                "", 
                "    # jaw compression affecting the nose_bridge", 
                "    if mc.objExists(${face_upper}):", 
                "        mc.parent(nose_bridge_nul, ${face_upper})", 
                "        # create the setDriven keys for the nose bridge", 
                "        mc.setDrivenKeyframe(\"{}.rx\".format(nose_bridge_rot_def_auto), ", 
                "                        cd=\"{}.ty\".format(${jaw_compression_joint}), v=-3.74, dv=-3)", 
                "        mc.setDrivenKeyframe(\"{}.rx\".format(nose_bridge_rot_def_auto), ", 
                "                        cd=\"{}.ty\".format(${jaw_compression_joint}), v=0, dv=-1)", 
                "        mc.setInfinity(nose_bridge_rot_def_auto, at='.rx', pri= 'linear', poi= 'linear')", 
                "", 
                "        mc.setDrivenKeyframe(\"{}.sy\".format(nose_bridge_rot_def_auto), ", 
                "            cd=\"{}.ty\".format(${jaw_compression_joint}), v=1, dv=0)                                        ", 
                "        mc.setDrivenKeyframe(\"{}.sy\".format(nose_bridge_rot_def_auto), ", 
                "            cd=\"{}.ty\".format(${jaw_compression_joint}), v=1.004, dv=5)    ", 
                "        mc.setDrivenKeyframe(\"{}.sy\".format(nose_bridge_rot_def_auto), ", 
                "            cd=\"{}.ty\".format(${jaw_compression_joint}), v=.98, dv=-2)                        ", 
                "        mc.setInfinity(nose_bridge_rot_def_auto, at='.sy', pri= 'linear', poi= 'linear')", 
                "                                                                                ", 
                "        for attr in ['y', 'z']:", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(nose_bridge_rot_def_auto,attr), ", 
                "                            cd=\"{}.ty\".format(${jaw_compression_joint}), v=0, dv=0)", 
                "            mc.setDrivenKeyframe(\"{}.t{}\".format(nose_bridge_rot_def_auto,attr), ", 
                "                            cd=\"{}.ty\".format(${jaw_compression_joint}), v=.01, dv=-.7)", 
                "            mc.setInfinity(nose_bridge_rot_def_auto, at='.ty', pri= 'linear', poi= 'linear')", 
                "            mc.setInfinity(nose_bridge_rot_def_auto, at='.tz', pri= 'linear', poi= 'linear')", 
                "    else:", 
                "        mc.parent(nose_bridge_nul, ${anchor})", 
                "    # position the faceLowerNul and connect the joint to the control", 
                "    mc.xform(nose_bridge_nul, ws=True, matrix=mc.xform(${nose_bridge_joint}, q=True, ws=True, matrix=True))", 
                "    mc.pointConstraint(nose_bridge_ctrl, ${nose_bridge_joint})", 
                "    mc.orientConstraint(nose_bridge_ctrl, ${nose_bridge_joint})", 
                "    mc.connectAttr(nose_bridge_ctrl+'.s', ${nose_bridge_joint}+'.s')"
            ]
        }, 
        "/center/face_upper/nose_bridge/nose": {
            "child_order": [
                "sdk"
            ], 
            "enabled": true, 
            "attrs": {
                "hierarchy": {
                    "type": "list", 
                    "value": "['nul', 'def_auto', 'rot_def_auto']"
                }
            }, 
            "code": [
                "if mc.objExists(${nose_joint}):", 
                "    # Create the faceLower and jaw control", 
                "    ctrl_hierarchy = rig_control.create(name=\"nose\", ", 
                "                                      controlType=\"null\",", 
                "                                      color=rig_common.YELLOW,", 
                "                                      hierarchy=${hierarchy},", 
                "                                      type='face')", 
                "    nose_nul, nose_def_auto, nose_rot_def_auto, nose_ctrl = ctrl_hierarchy", 
                "    ", 
                "    if mc.objExists(${nose_bridge_joint}):", 
                "        mc.parent(nose_nul, ${nose_bridge})", 
                "    else:", 
                "        mc.parent(nose_nul, ${anchor})", 
                "    ", 
                "    # position the faceLowerNul and connect the joint to the control", 
                "    mc.xform(nose_nul, ws=True, matrix=mc.xform(${nose_joint}, q=True, ws=True, matrix=True))", 
                "    mc.pointConstraint(nose_ctrl, ${nose_joint})", 
                "    mc.orientConstraint(nose_ctrl, ${nose_joint})", 
                "    mc.connectAttr('{}.s'.format(nose_ctrl), '{}.s'.format(${nose_joint}))"
            ]
        }, 
        "/center/face_upper/nose_bridge/nose/sdk": {
            "code": [
                "#lower face affecting nose", 
                "", 
                "if mc.objExists(${face_lower}):", 
                "    # create the setDriven keys for lower jaw RZ side to side movement", 
                "    # for nose tx ", 
                "    mc.setDrivenKeyframe(\"{}.tx\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.tx\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=.1, dv=-20)", 
                "    mc.setDrivenKeyframe(\"{}.tx\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=-.1, dv=20)                    ", 
                "    mc.setInfinity(${nose}+'_def_auto', at='.tx', pri= 'linear', poi= 'linear')", 
                "    # for nose rz", 
                "    mc.setDrivenKeyframe(\"{}.rz\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.rz\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=8, dv=-25)", 
                "    mc.setDrivenKeyframe(\"{}.rz\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=-8, dv=25)                    ", 
                "    mc.setInfinity(${nose}+'_def_auto', at='.rz', pri= 'linear', poi= 'linear')", 
                "", 
                "    # create the setDriven keys for lower jaw RX back and forward movement", 
                "    # for nose ty", 
                "    mc.setDrivenKeyframe(\"{}.ty\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.ty\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=-.14, dv=-10)", 
                "    mc.setDrivenKeyframe(\"{}.ty\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=.11, dv=10)                    ", 
                "    mc.setInfinity(${nose}+'_def_auto', at='.ty', pri= 'linear', poi= 'linear')  ", 
                "    #for nose tz  ", 
                "    mc.setDrivenKeyframe(\"{}.tz\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.tz\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=-.07, dv=-10)", 
                "    mc.setDrivenKeyframe(\"{}.tz\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=.068, dv=10)                    ", 
                "    mc.setInfinity(${nose}+'_def_auto', at='.tz', pri= 'linear', poi= 'linear')     ", 
                "    #for nose rx", 
                "    mc.setDrivenKeyframe(\"{}.rx\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}.rx\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=1.46, dv=-10)", 
                "    mc.setDrivenKeyframe(\"{}.rx\".format(${nose}+'_def_auto'), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=-6, dv=10)                    ", 
                "    mc.setInfinity(${nose}+'_def_auto', at='.rx', pri= 'linear', poi= 'linear')", 
                "    ", 
                ""
            ]
        }, 
        "/center/face_upper/nose_bridge/sdk": {
            "code": [
                "#lower face affecting nose_bridge_def_auto", 
                "", 
                "if mc.objExists(${face_lower}):", 
                "    # sdks for face lower forward and back in RX to nose bridge RX", 
                "    mc.setDrivenKeyframe(\"{}_def_auto.rx\".format(${nose_bridge}), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}_def_auto.rx\".format(${nose_bridge}), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=1.19, dv=-16)", 
                "    mc.setDrivenKeyframe(\"{}_def_auto.rx\".format(${nose_bridge}), ", 
                "                    cd=\"{}.rx\".format(${face_lower}), v=-3, dv=19)                    ", 
                "    mc.setInfinity('{}_def_auto'.format(${nose_bridge}), at='.rx', pri= 'linear', poi= 'linear')", 
                "", 
                "    # sdks for face lower swing side to side in RZ to nose bridge RZ", 
                "    mc.setDrivenKeyframe(\"{}_def_auto.rz\".format(${nose_bridge}), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}_def_auto.rz\".format(${nose_bridge}), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=2.5, dv=-25)", 
                "    mc.setDrivenKeyframe(\"{}_def_auto.rz\".format(${nose_bridge}), ", 
                "                    cd=\"{}.rz\".format(${face_lower}), v=-2.5, dv=25)                    ", 
                "    mc.setInfinity('{}_def_auto'.format(${nose_bridge}), at='.rz', pri= 'linear', poi= 'linear')", 
                "", 
                "    # sdks for face lower twist side to side in RY to nose bridge RZ", 
                "    mc.setDrivenKeyframe(\"{}_rot_def_auto.rz\".format(${nose_bridge}), ", 
                "                    cd=\"{}.ry\".format(${face_lower}), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"{}_rot_def_auto.rz\".format(${nose_bridge}), ", 
                "                    cd=\"{}.ry\".format(${face_lower}), v=-4, dv=-15)", 
                "    mc.setDrivenKeyframe(\"{}_rot_def_auto.rz\".format(${nose_bridge}), ", 
                "                    cd=\"{}.ry\".format(${face_lower}), v=4, dv=15)                    ", 
                "    mc.setInfinity('{}_rot_def_auto'.format(${nose_bridge}), at='.rz', pri= 'linear', poi= 'linear')"
            ]
        }, 
        "/center/head_wire": {
            "instance": "", 
            "child_order": [
                "head_wire_cluster"
            ], 
            "enabled": true, 
            "comment": "This will add a head wire to the rig", 
            "attrs": {
                "bind_joint_list": {
                    "type": "list", 
                    "value": "['skull_bind']"
                }, 
                "control_name_list": {
                    "type": "list", 
                    "value": "['headwire_top', 'headwire_mid', 'headwire_low']"
                }, 
                "head_low_curve": {
                    "type": "str", 
                    "value": "'head_low_curve'"
                }, 
                "head_low_wire_geometry": {
                    "type": "raw", 
                    "value": "mc.ls([${face_geo}, ${tongue_geo}] + ${teeth_upper_geo_list} + ${teeth_lower_geo_list})"
                }, 
                "head_low_wire_name": {
                    "type": "str", 
                    "value": "'head_low_wire'"
                }, 
                "head_wire_curve": {
                    "comment": "The curve to be used for the head wire", 
                    "type": "str", 
                    "value": "'head_curve'"
                }, 
                "head_wire_geometry": {
                    "comment": "The geometry you want to add the head wire to.", 
                    "type": "raw", 
                    "value": "mc.ls([${face_geo}, ${lash_upper_l_geo}, ${lash_lower_l_geo}, ${lash_upper_r_geo}, ${lash_lower_r_geo},  ${brow_l_geo}, ${brow_r_geo}, ${tongue_geo}, ${brow_l_geo}, ${brow_r_geo}] + ${teeth_upper_geo_list} + ${teeth_lower_geo_list} + ${eye_l_geo_list} + ${eye_r_geo_list} + ${hair_geo_list})\n"
                }, 
                "head_wire_name": {
                    "comment": "What yoiu will name the deformer", 
                    "type": "str", 
                    "value": "'head_wire'"
                }, 
                "head_wire_parent": {
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "squash_axis": {
                    "type": "tuple", 
                    "value": "('X', 'Z')"
                }
            }, 
            "code": [
                "# head wire variable names", 
                "curve = ${head_wire_curve}", 
                "deformer_name = ${head_wire_name}", 
                "", 
                "# heead_low wire variable bames", 
                "low_deformer_name = ${head_low_wire_name}", 
                "", 
                "parent = ${head_wire_parent}", 
                "bind_joint_list = ${bind_joint_list}", 
                "control_name_list = ${control_name_list}", 
                "geometry = ${head_wire_geometry}  ", 
                "head_low_geometry = ${head_low_wire_geometry}", 
                "# Curve rig            ", 
                "curve_rig = rig_wire.buildCurveRig(curve, name=deformer_name, ctrl_names=control_name_list, parent=parent, control_type='face')                               ", 
                "bindmesh_geometry, follicle_list, control_hierarchy_list, joint_list, base_curve_joint_list = curve_rig", 
                "low_curve = mc.duplicate(curve, name=${head_low_curve})[0]", 
                "", 
                "# Lock and hide scale and rotates", 
                "for ctrl in control_name_list:", 
                "    rig_attribute.lockAndHideAttrs(ctrl, ['rx', 'ry', 'rz', 'sx', 'sy', 'sz'])", 
                "", 
                "# make sure the deformer names have _wire at the end of them.", 
                "if not '_wire' in deformer_name:", 
                "    deformer_name = '{}_wire'.format(deformer_name)", 
                "if not '_wire' in low_deformer_name:", 
                "    low_deformer_name = '{}_wire'.format(low_deformer_name)", 
                "", 
                "# Create deformer and set dropoffDistance", 
                "head_wire_deformer = mc.wire(geometry, gw=False, en=1.00, ce=0.00, li=0.00, w=curve, name=deformer_name)[0]", 
                "head_low_wire_deformer = mc.wire(head_low_geometry, gw=False, en=1.00, ce=0.00, li=0.00, w=low_curve, name=low_deformer_name)[0]", 
                "mc.setAttr(\"{}.dropoffDistance[0]\".format(head_wire_deformer), 100)", 
                "mc.setAttr(\"{}.dropoffDistance[0]\".format(head_low_wire_deformer), 100)", 
                "", 
                "# get the baseWire names", 
                "base_curve = \"{}BaseWire\".format(curve)", 
                "low_base_curve = \"{}BaseWire\".format(low_curve)", 
                "", 
                "mc.parent([curve,base_curve, low_curve, low_base_curve], deformer_name+'_grp')", 
                "", 
                "# setup the skinning for the curves ", 
                "mc.delete(curve, ch=True)", 
                "# head_curve binding", 
                "curve_skin = mc.skinCluster(joint_list+mc.ls(curve), ", 
                "                            n=\"{}_skinCluster\".format(curve),", 
                "                            tsb=True)[0]", 
                "", 
                "base_curve_skin = mc.skinCluster(base_curve_joint_list[:-1]+joint_list[2:]+mc.ls(base_curve), ", 
                "                            n=\"{}_skinCluster\".format(base_curve),", 
                "                            tsb=True)[0]", 
                "                            ", 
                "base_mesh_skin = mc.skinCluster(bind_joint_list, bindmesh_geometry, ", 
                "                                n=\"{}_skinCluster\".format(bindmesh_geometry),", 
                "                                tsb=True)[0]", 
                "", 
                "# head_low_curve binding", 
                "low_curve_skin = mc.skinCluster(base_curve_joint_list[:-1]+joint_list[2:]+mc.ls(low_curve), ", 
                "                            n=\"{}_skinCluster\".format(low_curve),", 
                "                            tsb=True)[0]", 
                "", 
                "low_base_curve_skin = mc.skinCluster(base_curve_joint_list+mc.ls(low_base_curve), ", 
                "                            n=\"{}_skinCluster\".format(low_base_curve),", 
                "                            tsb=True)[0]"
            ]
        }, 
        "/center/head_wire/head_wire_cluster": {
            "instance": "/cluster_control", 
            "child_order": [
                "create", 
                "connect"
            ], 
            "attrs": {
                "control_name": {
                    "type": "str", 
                    "value": "'head_low'"
                }, 
                "display_handle": {
                    "value": "False"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${head_low_wire_geometry}"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'face_upper'"
                }, 
                "tag_as_control": {
                    "value": "False"
                }, 
                "type": {
                    "value": "'face'"
                }
            }
        }, 
        "/center/head_wire/head_wire_cluster/connect": {
            "comment": "This node will connect the squash and stretch for the cluster based on the lenght of the curve. There will be sdk's provided and archetypes should never override these. This is character specific.", 
            "code": [
                "# create the curve info node to use the archLength of the curve to drive the SDK's", 
                "curve_info_node = mc.createNode('curveInfo', name='{}_cin'.format(${head_low_wire_name}))", 
                "base_curve_info_node = mc.createNode('curveInfo', name='{}Base_cin'.format(${head_low_wire_name}))", 
                "# get the shapes for the curves so we can plug them into the curveInfor nodes.", 
                "low_curve_shape = mc.listRelatives(${head_low_curve}, c=True, shapes=True)[0]", 
                "low_curve_base_shape = mc.listRelatives('{}BaseWire'.format(${head_low_curve}), c=True, shapes=True)[0]", 
                "# connect the arc curves to the curveInfo nodes.", 
                "mc.connectAttr('{}.local'.format(low_curve_shape), '{}.inputCurve'.format(curve_info_node), f=True)", 
                "mc.connectAttr('{}.local'.format(low_curve_base_shape), '{}.inputCurve'.format(base_curve_info_node), f=True)", 
                "# get the length of the curve from the node", 
                "current_driver = \"{}.arcLength\".format(curve_info_node)", 
                "current_arc_length = mc.getAttr(current_driver)", 
                "# create the multiplyDivide node and make the connections", 
                "squetch_mdn = mc.createNode('multiplyDivide', n='{}_squetch_mdn'.format(${control_name}))", 
                "mc.connectAttr('{}.arcLength'.format(base_curve_info_node), '{}.input1X'.format(squetch_mdn), f=True)", 
                "mc.connectAttr('{}.arcLength'.format(curve_info_node), '{}.input2X'.format(squetch_mdn), f=True)", 
                "mc.setAttr('{}.operation'.format(squetch_mdn), 2)", 
                "# create the plusMinusAverage node so we can make the connections", 
                "squetch_pma = mc.createNode('plusMinusAverage', n='{}_squetch_pma'.format(${control_name}))", 
                "", 
                "for attr in ${squash_axis}:", 
                "    mc.setDrivenKeyframe(\"{}.input3D[0].input3D{}\".format(squetch_pma, attr.lower()),", 
                "                            currentDriver='{}.outputX'.format(squetch_mdn),", 
                "                            dv=0,", 
                "                            itt=\"linear\",", 
                "                            ott= \"linear\", ", 
                "                            value=0)", 
                "    mc.setDrivenKeyframe(\"{}.input3D[0].input3D{}\".format(squetch_pma, attr.lower()),", 
                "                            currentDriver='{}.outputX'.format(squetch_mdn),", 
                "                            dv=1,", 
                "                            itt=\"linear\",", 
                "                            ott= \"linear\", ", 
                "                            value=0)", 
                "                            ", 
                "    mc.setDrivenKeyframe(\"{}.input3D[0].input3D{}\".format(squetch_pma, attr.lower()),", 
                "                            currentDriver='{}.outputX'.format(squetch_mdn),", 
                "                            dv=2,", 
                "                            itt=\"linear\",", 
                "                            ott= \"linear\", ", 
                "                            value=0)", 
                "                            ", 
                "    mc.connectAttr('{}.outputX'.format(squetch_mdn), '{}.input3D[1].input3D{}'.format(squetch_pma, attr.lower()), f=True)", 
                "    mc.connectAttr('{}.output3D{}'.format(squetch_pma, attr.lower()), '{}.scale{}'.format(${control_name}, attr), f=True)"
            ]
        }, 
        "/center/head_wire/head_wire_cluster/create": {}, 
        "/center/look_at": {
            "instance": "/look_at", 
            "child_order": [
                "create"
            ], 
            "enabled": true
        }, 
        "/center/look_at/create": {
            "child_order": [
                "look_at_trs", 
                "look_at_rot"
            ], 
            "enabled": true
        }, 
        "/center/look_at/create/look_at_rot": {
            "child_order": [
                "create", 
                "position", 
                "connect"
            ], 
            "enabled": true, 
            "attrs": {
                "color": {
                    "type": "raw", 
                    "value": "rig_common.GREEN"
                }
            }
        }, 
        "/center/look_at/create/look_at_trs": {
            "child_order": [
                "create", 
                "position"
            ], 
            "enabled": true, 
            "attrs": {
                "color": {
                    "type": "raw", 
                    "value": "rig_common.GREEN"
                }
            }
        }, 
        "/center/mouth": {
            "instance": "/mouth", 
            "child_order": [
                "create", 
                "lip_main", 
                "lip", 
                "rig_sets", 
                "bind_geometry", 
                "mouth_main_to_bindmesh"
            ], 
            "enabled": true, 
            "attrs": {
                "geometry": {
                    "value": "${face_geo}"
                }, 
                "head_pin": {
                    "type": "raw", 
                    "value": "${/center/face_upper.face_mid_joint}"
                }, 
                "jaw_pin": {
                    "type": "str", 
                    "value": "'jaw_bind'"
                }, 
                "lip_cuve": {
                    "type": "str", 
                    "value": "'lip_curve'"
                }, 
                "lip_main_curve": {
                    "type": "str", 
                    "value": "'lip_main_curve'"
                }, 
                "orient_file": {
                    "type": "raw", 
                    "value": "${/apply/controls/control_orients.filepath}"
                }, 
                "system_parent": {
                    "type": "str", 
                    "value": "'mouth'"
                }
            }
        }, 
        "/center/mouth/mouth_main_to_bindmesh": {
            "enabled": true, 
            "code": [
                "# add the mouth main cluster if the handle exists in the scene", 
                "for mesh in mc.ls([STAGE.lip_main_bindmesh_geometry, STAGE.lip_bindmesh_geometry, STAGE.mouth_corner_bindmesh_geometry]):", 
                "    if mc.objExists(mesh) and mc.objExists(\"mouthMain_cls_hdl\"):", 
                "        mc.select(mesh, r=True)", 
                "        cls = mc.cluster(name=\"{}_mouthMain_cluster\".format(mesh), wn=['mouthMain_cls_hdl','mouthMain_cls_hdl'],bs=1)[0]", 
                "        rig_cluster.localize(cls, 'mouthMain_auto', 'model')"
            ]
        }, 
        "/delivery/convert_to_skinclusters": {
            "instance": "", 
            "child_order": [
                "to_freeze_pose", 
                "body_wire_skincluster", 
                "face_post_wire_skincluster", 
                "face_wire_skincluster", 
                "lip_bindmesh_post_skincluster", 
                "face_cluster_skincluster", 
                "face_pre_cluster_skincluster", 
                "blink_cluster_skincluster", 
                "lip_cluster_skincluster", 
                "face_post_cluster_skincluster", 
                "remove_freeze_pose"
            ], 
            "attrs": {
                "wire_list": {
                    "comment": "Wire you want to make sure freeze stays intact when transferring deformers to skinClusters", 
                    "type": "list", 
                    "value": "['lip_wire', 'lip_main_wire']"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/blink_cluster_skincluster": {
            "instance": "/cluster_to_skincluster", 
            "attrs": {
                "cluster_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"blinkUpper_?_cluster\", \"blinkLower_?_cluster\"], type=\"cluster\")"
                }, 
                "deformer_name": {
                    "type": "str", 
                    "value": "'blink_cluster_sc'"
                }, 
                "keep_clusters": {
                    "comment": "Whether or not to keep the clusters around", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "root_pre_matrix": {
                    "comment": "Node the will be used for the preMatrix", 
                    "type": "str", 
                    "value": "'trs_aux'"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/face_cluster_skincluster": {
            "instance": "/cluster_to_skincluster", 
            "attrs": {
                "cluster_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"ear_?_cluster\", \"brow_corrugator_?_cluster\", \"socketStretch_?_cluster\", \"lip_upper_?_cluster\", \"lip_lower_?_cluster\", \"sneer_?_cluster\", \"cheekLift_?_cluster\"], type=\"cluster\")\n"
                }, 
                "deformer_name": {
                    "type": "str", 
                    "value": "'face_cluster_sc'"
                }, 
                "keep_clusters": {
                    "comment": "Whether or not to keep the clusters around", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "comment": "The root parent", 
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "root_pre_matrix": {
                    "comment": "Node the will be used for the preMatrix", 
                    "type": "str", 
                    "value": "'trs_aux'"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/face_post_cluster_skincluster": {
            "instance": "/cluster_to_skincluster", 
            "attrs": {
                "cluster_list": {
                    "type": "raw", 
                    "value": "mc.ls(['head_low_cluster'], type=\"cluster\")"
                }, 
                "deformer_name": {
                    "type": "str", 
                    "value": "'face_post_cluster_sc'"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/face_post_wire_skincluster": {
            "instance": "/wire_to_skincluster", 
            "attrs": {
                "deformer_name": {
                    "type": "str", 
                    "value": "'face_post_wire_sc'"
                }, 
                "joint_depth": {
                    "type": "int", 
                    "value": "3"
                }, 
                "keep_wires": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "root_pre_matrix": {
                    "type": "str", 
                    "value": "'trs_aux'"
                }, 
                "wire_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"lip_wire\"], type=\"wire\")"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/face_pre_cluster_skincluster": {
            "instance": "/cluster_to_skincluster", 
            "attrs": {
                "cluster_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"lid_squash_?_cluster\", \"socketLift_?_cluster\", \"cheek_?_cluster\"], type=\"cluster\")"
                }, 
                "deformer_name": {
                    "type": "str", 
                    "value": "'face_pre_cluster_sc'"
                }, 
                "keep_clusters": {
                    "comment": "Whether or not to keep the clusters around", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "root_pre_matrix": {
                    "comment": "Node the will be used for the preMatrix", 
                    "type": "str", 
                    "value": "'trs_aux'"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/face_wire_skincluster": {
            "instance": "/wire_to_skincluster", 
            "comment": "Face wire skincluster\n", 
            "attrs": {
                "deformer_name": {
                    "type": "str", 
                    "value": "'face_wire_sc'"
                }, 
                "joint_depth": {
                    "type": "int", 
                    "value": "3"
                }, 
                "keep_wires": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "root_pre_matrix": {
                    "type": "str", 
                    "value": "'trs_aux'"
                }, 
                "wire_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"lip_main_wire\", \"brow*wire\", \"lid_?_curve_wire\"], type=\"wire\")"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/lip_bindmesh_post_skincluster": {
            "instance": "/wire_to_skincluster", 
            "attrs": {
                "deformer_name": {
                    "type": "str", 
                    "value": "'lip_bindmesh_face_post_wire_sc'"
                }, 
                "joint_depth": {
                    "type": "int", 
                    "value": "3"
                }, 
                "keep_wires": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "root_pre_matrix": {
                    "type": "str", 
                    "value": "'trs_aux'"
                }, 
                "target_geometry": {
                    "type": "list", 
                    "value": "['lip_bindmesh']"
                }, 
                "wire_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"lip_bindmesh_wire\"], type=\"wire\")"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/lip_cluster_skincluster": {
            "instance": "/cluster_to_skincluster", 
            "attrs": {
                "cluster_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"lip_upper_cluster\", \"lip_lower_cluster\"], type=\"cluster\")"
                }, 
                "deformer_name": {
                    "type": "str", 
                    "value": "'lip_cluster_sc'"
                }, 
                "keep_clusters": {
                    "comment": "Whether or not to keep the clusters around", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "root_parent": {
                    "type": "raw", 
                    "value": "${rig_group}"
                }, 
                "root_pre_matrix": {
                    "comment": "Node the will be used for the preMatrix", 
                    "type": "str", 
                    "value": "'trs_aux'"
                }
            }
        }, 
        "/delivery/convert_to_skinclusters/remove_freeze_pose": {
            "comment": "This node is used to make sure things are removed from the freeze pose state that we used earlier to make sure the tranfer of the deformers to skinClusters are intact.", 
            "code": [
                "# # make the connection between the duplicate mesh and the wire deformer.", 
                "for wire in mc.ls(${wire_list}):", 
                "    mc.setAttr('{}.bindToOriginalGeometry'.format(wire), 0)", 
                "    ", 
                "# set pose back to neutral", 
                "# set the rig to the freeze pose.", 
                "controls = rig_control.getControls()", 
                "rig_control.toPoseAttr(controls, 0)", 
                "", 
                "mc.delete(mc.ls(STAGE.duplicate_face_trs))", 
                "", 
                "# Turn blendshape back on", 
                "blendshape = ${face_geo}+'_blendShape'", 
                "if mc.objExists(blendshape):", 
                "    print('turn on blendshape')", 
                "    mc.setAttr(blendshape+'.envelope', 1)"
            ]
        }, 
        "/delivery/convert_to_skinclusters/to_freeze_pose": {
            "comment": "This node is used to make sure that the freeze is kept intact while tranfering deformers to skinClusters.", 
            "code": [
                "# set the rig to the freeze pose.", 
                "controls = rig_control.getControls()", 
                "rig_control.toPoseAttr(controls, 9)", 
                "", 
                "# Turn off the blendshape becaues it is messing up the yank", 
                "blendshape = ${face_geo}+'_blendShape'", 
                "if mc.objExists(blendshape):", 
                "    mc.setAttr(blendshape+'.envelope', 0)", 
                "    ", 
                "# duplicate the face geometry in the freeze pose", 
                "STAGE.duplicate_face_trs = mc.duplicate(${face_geo})[0]", 
                "duplicate_face_shape = mc.listRelatives(STAGE.duplicate_face_trs, c=True, shapes=True)[0]", 
                "", 
                "# # make the connection between the duplicate mesh and the wire deformer.", 
                "for wire in mc.ls(${wire_list}):", 
                "    mc.connectAttr('{}.outMesh'.format(duplicate_face_shape), '{}.originalGeometry[0]'.format(wire), f=True)", 
                "    mc.setAttr('{}.bindToOriginalGeometry'.format(wire), 1)", 
                "    ", 
                ""
            ]
        }, 
        "/delivery/unique_deformers": {
            "instance": "", 
            "attrs": {
                "deformer_list": {
                    "type": "list", 
                    "value": "['lip_main_wire', 'socketStretch_l_cluster', 'socketStretch_r_cluster']"
                }, 
                "geometry_list": {
                    "type": "list", 
                    "value": "['lip_bindmesh', 'l_eyeinside_geo', 'r_eyeinside_geo']"
                }
            }
        }, 
        "/face_cluster_control": {
            "instance": "/cluster_control", 
            "child_order": [
                "create", 
                "align_orientation"
            ], 
            "attrs": {
                "side_multiplier": {
                    "type": "int", 
                    "value": "1"
                }, 
                "side_rotate_multiplier": {
                    "type": "int", 
                    "value": "0"
                }
            }
        }, 
        "/face_cluster_control/align_orientation": {
            "attrs": {
                "scale_offset": {
                    "type": "tuple", 
                    "value": "(1, 1*${side_multiplier}, 1)"
                }
            }, 
            "code": [
                "# Get the names of the nul and orients. This could be re-done at some point.", 
                "control_nul = '{}_nul'.format(${control_name})", 
                "# Ensure there is -1 value on scaleZ for mirror if we're on the right side", 
                "mc.setAttr('{}.s'.format(control_nul), *${scale_offset})", 
                "    ", 
                "# make sure the nodes exists and if it's on the right side we will change to orient", 
                "if mc.objExists(control_nul) and mc.objExists(${align_to_node}):", 
                "    mc.xform(control_nul, ws=True, rotation=(0, 0, ${side_rotate_multiplier}))", 
                ""
            ]
        }, 
        "/left": {
            "child_order": [
                "arm", 
                "leg", 
                "sneer", 
                "brow", 
                "blink", 
                "ear", 
                "cheeks", 
                "lip_upper", 
                "lip_lower"
            ], 
            "enabled": true
        }, 
        "/left/blink": {
            "instance": "/blink", 
            "enabled": true, 
            "attrs": {
                "eye_geometry": {
                    "type": "raw", 
                    "value": "${eye_${side}_geo_list}"
                }, 
                "geometry": {
                    "value": "${face_geo}"
                }, 
                "lash_lower_geometry": {
                    "type": "raw", 
                    "value": "${lash_lower_${side}_geo}"
                }, 
                "lash_upper_geometry": {
                    "type": "raw", 
                    "value": "${lash_upper_${side}_geo}"
                }
            }
        }, 
        "/left/blink/blink_collision/lid_squash/create": {
            "attrs": {
                "geometry": {
                    "value": "mc.ls(${face_geo}, ${lash_lower_geometry}, ${lash_upper_geometry})"
                }
            }
        }, 
        "/left/blink/blink_rig_setup/lid_wire": {
            "attrs": {
                "geometry": {
                    "value": "mc.ls(${lash_upper_geometry}, ${lash_lower_geometry}, ${face_geo})"
                }
            }
        }, 
        "/left/blink/blink_rig_setup/lower": {
            "attrs": {
                "geometry": {
                    "value": "mc.ls(${lash_lower_geometry}, ${face_geo}) "
                }
            }
        }, 
        "/left/blink/blink_rig_setup/upper": {
            "attrs": {
                "geometry": {
                    "value": "mc.ls(${lash_upper_geometry}, ${face_geo}) "
                }
            }
        }, 
        "/left/brow": {
            "instance": "/brow", 
            "child_order": [
                "create", 
                "brow_main", 
                "brow_inner", 
                "brow_peak", 
                "corrugator", 
                "curve_rig"
            ], 
            "enabled": true, 
            "attrs": {
                "geometry": {
                    "value": "${face_geo}"
                }
            }
        }, 
        "/left/cheeks": {
            "instance": "", 
            "child_order": [
                "cheek", 
                "cheek_puff", 
                "cheek_lift", 
                "mouth_corner_distance"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "type": "bool", 
                    "value": "False"
                }
            }
        }, 
        "/left/cheeks/cheek": {
            "instance": "/face_cluster_control", 
            "enabled": true, 
            "attrs": {
                "control_name": {
                    "type": "str", 
                    "value": "'cheek_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${/center/face_upper.face_upper}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/left/cheeks/cheek_lift": {
            "instance": "/face_cluster_control", 
            "enabled": true, 
            "attrs": {
                "control_name": {
                    "type": "str", 
                    "value": "'cheekLift_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'lidLower_${side}'"
                }, 
                "tag_as_control": {
                    "type": "bool", 
                    "value": "False"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/left/cheeks/cheek_puff": {
            "instance": "/face_cluster_control", 
            "enabled": true, 
            "attrs": {
                "control_name": {
                    "type": "str", 
                    "value": "'cheekPuff_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${/center/face_upper.face_mid_driver}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/left/cheeks/mouth_corner_distance": {
            "enabled": true, 
            "code": [
                "dkeys = []", 
                "distance_locator_list = []", 
                "distance_node_list = []", 
                "side = '${side}'", 
                "distance_locator = mc.createNode(\"transform\", n=\"distance_loc_{}\".format(side))", 
                "distance_locator_list.append(distance_locator)", 
                "mc.xform(distance_locator, ws=True, matrix=mc.xform(\"eye_{}_bind\".format(side), q=True, ws=True, matrix=True))", 
                "mc.parent(distance_locator, \"face_upper\")", 
                "mouth_corner_dcm = mc.createNode(\"decomposeMatrix\", name=\"mouth_corner_{}_decomposeMatrix\".format(side))", 
                "distance_locator_dcm = mc.createNode(\"decomposeMatrix\", name=\"distance_loc_{}_decomposeMatrix\".format(side))", 
                "", 
                "mc.connectAttr(\"mouth_corner_{}.worldMatrix[0]\".format(side), \"{}.inputMatrix\".format(mouth_corner_dcm))", 
                "mc.connectAttr(\"distance_loc_{}.worldMatrix[0]\".format(side), \"{}.inputMatrix\".format(distance_locator_dcm))", 
                "", 
                "distance_node = mc.createNode(\"distanceBetween\", n=\"mouth_corner_{}_distance\".format(side))", 
                "distance_node_list.append(distance_node)", 
                "mc.connectAttr(\"{}.outputTranslate\".format(mouth_corner_dcm), \"{}.point1\".format(distance_node), f=True)", 
                "mc.connectAttr(\"{}.outputTranslate\".format(distance_locator_dcm), \"{}.point2\".format(distance_node), f=True)", 
                "    ", 
                "", 
                "current_distance = mc.getAttr(\"{}.distance\".format(distance_node))        ", 
                "for axis in ['x', 'y', 'z']:", 
                "    #mc.setDrivenKeyframe(\"cheekPuff_{}_def_auto.s{}\".format(side, axis), ", 
                "    #                            cd=\"{}.distance\".format(distance_node), v=1, dv=current_distance)", 
                "    #mc.setDrivenKeyframe(\"cheekPuff_{}_def_auto.s{}\".format(side, axis), ", 
                "    #                            cd=\"{}.distance\".format(distance_node), v=2, dv=current_distance-2)", 
                "                                ", 
                "                                ", 
                "    if axis == \"y\":", 
                "        mc.setDrivenKeyframe(\"cheek_{}_def_auto.t{}\".format(side, axis), ", 
                "                                    cd=\"{}.distance\".format(distance_node), v=0, dv=current_distance)", 
                "        mc.setDrivenKeyframe(\"cheek_{}_def_auto.t{}\".format(side, axis), ", 
                "                                    cd=\"{}.distance\".format(distance_node), v=2, dv=current_distance-2)", 
                "", 
                "# lid lower rotation", 
                "mc.setDrivenKeyframe(\"lidLower_{}_def_auto.rx\".format(side), ", 
                "                                cd=\"{}.distance\".format(distance_node), v=0, dv=current_distance)", 
                "mc.setDrivenKeyframe(\"lidLower_{}_def_auto.rx\".format(side), ", 
                "                                cd=\"{}.distance\".format(distance_node), v=6, dv=current_distance-2)", 
                "", 
                "if mc.objExists(\"cheekLift_{}_def_auto\".format(side)):", 
                "    mc.setDrivenKeyframe(\"cheekLift_{}_def_auto.rx\".format(side), ", 
                "                                    cd=\"{}.distance\".format(distance_node), v=0, dv=current_distance)", 
                "    mc.setDrivenKeyframe(\"cheekLift_{}_def_auto.rx\".format(side), ", 
                "                                    cd=\"{}.distance\".format(distance_node), v=6, dv=current_distance-2)", 
                "", 
                "    mc.addAttr(\"lidLower_{}\".format(side), ln=\"cheekLift\", at=\"double\", keyable=True)", 
                "    mc.setDrivenKeyframe(\"cheekLift_{}.rx\".format(side), ", 
                "                                    cd=\"lidLower_{}.cheekLift\".format(side), v=0, dv=0)", 
                "    mc.setDrivenKeyframe(\"cheekLift_{}.rx\".format(side), ", 
                "                                    cd=\"lidLower_{}.cheekLift\".format(side), v=50, dv=10)", 
                "    mc.setDrivenKeyframe(\"cheekLift_{}.rx\".format(side), ", 
                "                                    cd=\"lidLower_{}.cheekLift\".format(side), v=-50, dv=-10)", 
                "        ", 
                "# Rig Sets", 
                "# ", 
                "if mc.objExists('MouthDist'):", 
                "    mc.sets(distance_locator_list + distance_node_list, add='MouthDist')", 
                "    mouthDistSet = 'MouthDist'", 
                "else:", 
                "    mouthDistSet = mc.sets(distance_locator_list + distance_node_list, n='MouthDist')", 
                "", 
                "# Driven keys ", 
                "for node in distance_node_list:", 
                "    current_dkeys = mc.listConnections(node+'.distance')", 
                "    dkeys += current_dkeys", 
                "    ", 
                "if mc.objExists('MouthDist_dkeys'):", 
                "    mc.sets(dkeys, add='MouthDist_dkeys')", 
                "    dkeySet = 'MouthDist_dkeys'", 
                "else:", 
                "    dkeySet = mc.sets(dkeys, n='MouthDist_dkeys')", 
                "    ", 
                "mc.sets(dkeySet, add=mouthDistSet)", 
                "", 
                "if mc.objExists('Mouth'):", 
                "    mc.sets(mouthDistSet, add='Mouth')"
            ]
        }, 
        "/left/ear": {
            "instance": "/face_cluster_control", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "value": "False"
                }, 
                "align_to_node": {
                    "type": "raw", 
                    "value": "${parent}"
                }, 
                "control_name": {
                    "type": "str", 
                    "value": "'ear_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v']"
                }, 
                "parent": {
                    "type": "str", 
                    "value": "'face_upper'"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/left/lip_lower": {
            "instance": "../lip_upper", 
            "enabled": true, 
            "attrs": {
                "control_name": {
                    "type": "str", 
                    "value": "'lip_lower_${side}'"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${/center/face_lower/jaw.jaw}"
                }
            }
        }, 
        "/left/lip_upper": {
            "instance": "/face_cluster_control", 
            "enabled": true, 
            "attrs": {
                "align_rotation": {
                    "value": "False"
                }, 
                "control_name": {
                    "type": "str", 
                    "value": "'lip_upper_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'nul'"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v']"
                }, 
                "parent": {
                    "type": "raw", 
                    "value": "${/center/face_upper.face_mid_driver}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/left/sneer": {
            "instance": "/face_cluster_control", 
            "child_order": [
                "create"
            ], 
            "enabled": true, 
            "comment": "Sneer control", 
            "attrs": {
                "align_rotation": {
                    "value": "False"
                }, 
                "control_name": {
                    "comment": "Name to be used for the sneer control.", 
                    "type": "str", 
                    "value": "'sneer_${side}'"
                }, 
                "control_type": {
                    "type": "str", 
                    "value": "'null'"
                }, 
                "geometry": {
                    "type": "raw", 
                    "value": "${face_geo}"
                }, 
                "hide_attrs": {
                    "type": "list", 
                    "value": "['v', 'rx', 'ry', 'rz']"
                }, 
                "parent": {
                    "comment": "Name of the parent for the sneer control.", 
                    "type": "raw", 
                    "value": "${/center/face_upper.nose}"
                }, 
                "type": {
                    "type": "str", 
                    "value": "'face'"
                }
            }
        }, 
        "/load/model/hide_geos": {
            "attrs": {
                "geo_list": {
                    "type": "raw", 
                    "value": "mc.ls(['cornea_?_geo', 'eye_?_locator'])"
                }
            }
        }, 
        "/mirror_face_wires": {
            "attrs": {
                "brow_curve_list": {
                    "type": "raw", 
                    "value": "mc.ls(\"brow*\", type=\"nurbsCurve\", ni=True)"
                }, 
                "eye_curve_list": {
                    "comment": "Eye curves the will be mirrored", 
                    "type": "list", 
                    "value": "[mc.listRelatives(curve, p=True)[0] for curve in mc.ls(\"lid*\", type=\"nurbsCurve\", ni=True) + mc.ls(\"blink*\", type=\"nurbsCurve\", ni=True) + ${brow_curve_list}]"
                }, 
                "lip_curve_list": {
                    "comment": "List of lip curves that will be mirrored", 
                    "type": "raw", 
                    "value": "mc.ls(\"lip*\", type=\"nurbsCurve\", ni=True)"
                }, 
                "lip_curve_map": {
                    "comment": "Mapping of the lip curve cvs and which one needs to mirror the other", 
                    "type": "dict", 
                    "value": "{\"center\":(1, 9), \"left\":(0, 10, 11, 12, 13, 14 , 15), \"right\":(2, 8, 7, 6, 5, 4, 3)}"
                }
            }, 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    # Mirror", 
                "    for node in ${eye_curve_list}:", 
                "        if rig_common.getSideToken(node) is 'l':", 
                "            rig_curve.mirror(node)", 
                "", 
                "    for curve in ${lip_curve_list}:", 
                "        for left_index, right_index in zip(${lip_curve_map}[\"left\"], ${lip_curve_map}[\"right\"]):", 
                "            left_position = mc.xform(\"%s.cv[%s]\" % (curve, left_index), q=True, ws=True, t=True)", 
                "            mc.xform(\"%s.cv[%s]\" % (curve, right_index), ws=True, t=(left_position[0] *-1, left_position[1],left_position[2]))", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)", 
                ""
            ]
        }, 
        "/post_build": {
            "child_order": [
                "breathing", 
                "switch_expression", 
                "tag_controllers", 
                "control_visibility", 
                "pick_walking", 
                "frame_camera", 
                "lock_hidden_attrs"
            ], 
            "enabled": true
        }, 
        "/post_build/pick_walking": {
            "child_order": [
                "body", 
                "face"
            ], 
            "enabled": true
        }, 
        "/post_build/pick_walking/face": {
            "enabled": true, 
            "comment": "All of the face pickwalking can be stored on this node or it's children", 
            "code": [
                "# --------------------------------------------------", 
                "# Pickwalking", 
                "# --------------------------------------------------", 
                "", 
                "# Face upper children - note: excluding 'eyeSocket_l', 'eyeSocket_r' because it is making the lide tweakers not go all the way around", 
                "children = ['face_lower', 'head_tip',  'cheek_r', 'cheek_l', 'nose_bridge']", 
                "parent = 'head'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Lid Tweakers", 
                "", 
                "children = ['lid_up_3_l', 'lid_up_4_l', 'lid_up_5_l', 'lid_corner_outer_l', 'lid_low_6_l', 'lid_low_5_l', 'lid_low_4_l', 'lid_low_3_l', 'lid_low_2_l', 'lid_corner_inner_l', 'lid_up_1_l', 'lid_up_2_l']", 
                "parent = 'lidLower_l'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "children = ['lid_up_3_r', 'lid_up_2_r', 'lid_up_1_r', 'lid_corner_inner_r', 'lid_low_2_r', 'lid_low_3_r', 'lid_low_4_r', 'lid_low_5_r', 'lid_low_6_r', 'lid_corner_outer_r', 'lid_up_5_r', 'lid_up_4_r']", 
                "parent = 'lidLower_r'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Upper lids", 
                "children = ['lidLower_l']", 
                "parent = 'lidUpper_l'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "children = ['lidLower_r']", 
                "parent = 'lidUpper_r'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Lower lids", 
                "children = ['lidUpper_l']", 
                "parent = 'eyeSocket_l'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "children = ['lidUpper_r']", 
                "parent = 'eyeSocket_r'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Brows", 
                "", 
                "children = ['brow_peak_r', 'brow_main_r', 'brow_corrugator_r', 'brow_inner_r', 'brow_inner_l', 'brow_corrugator_l', 'brow_main_l', 'brow_peak_l']", 
                "parent = 'head_tip'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# lip tweakers", 
                "children = ['lip_center_up', 'lip_up_2_l', 'lip_up_1_l', 'lip_up_0_l', 'lip_corner_l', 'lip_low_0_l', 'lip_low_1_l', 'lip_low_2_l', 'lip_center_low', 'lip_low_2_r', 'lip_low_1_r', 'lip_low_0_r', 'lip_corner_r', 'lip_up_0_r', 'lip_up_1_r', 'lip_up_2_r']", 
                "parent = 'lip_lower'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Lip lower", 
                "children = ['lip_lower']", 
                "parent = 'lip_upper'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Lip upper and mouth corners", 
                "children = ['mouth_corner_r', 'mouth_corner_l']", 
                "parent = 'mouthMain'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Mouth main and tongue base - 'lip_upper' removed ", 
                "children = ['mouthMain', 'tongue_base', 'teeth_upper']", 
                "parent = 'jaw'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Tongue mid", 
                "children = ['tongue_mid']", 
                "parent = 'tongue_base'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Tongue tip", 
                "children = ['tongue_tip']", 
                "parent = 'tongue_mid'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Lower teeth", 
                "children = ['teeth_lower']", 
                "parent = 'teeth_upper'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Nose and sneers", 
                "children = ['sneer_r', 'sneer_l', 'nose', ]", 
                "parent = 'nose_bridge'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Cheek puff", 
                "children = ['cheekPuff_l']", 
                "parent = 'cheek_l'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "children = ['cheekPuff_r']", 
                "parent = 'cheek_r'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Head wire mid", 
                "children = ['headwire_mid']", 
                "parent = 'headwire_top'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# Head wire low", 
                "children = ['headwire_low']", 
                "parent = 'headwire_mid'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# jaw", 
                "children = ['jaw']", 
                "parent = 'face_lower'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')", 
                "", 
                "# face upper and head wire top", 
                "children = ['headwire_top', 'face_upper']", 
                "parent = 'head'", 
                "if mc.objExists(parent):", 
                "    mc.select(mc.ls(children), parent)", 
                "    mm.eval('TagAsControllerParent')"
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face": {
            "instance": "/button", 
            "child_order": [
                "mirror_lips", 
                "mirror_lids", 
                "mirror_brows", 
                "mirror_cheeks", 
                "mirror_nose", 
                "mirror_ears", 
                "mirror_all"
            ], 
            "attrs": {
                "button_color": {
                    "value": "rgba(0, 116, 178, 1)"
                }
            }
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_all": {
            "child_order": [
                "mirror_lips", 
                "mirror_lids", 
                "mirror_brows", 
                "mirror_cheeks", 
                "mirror_nose", 
                "mirror_ears"
            ], 
            "code": [
                ""
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_all/mirror_brows": {
            "instance": "../../mirror_brows/mirror"
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_all/mirror_cheeks": {
            "instance": "../../mirror_cheeks/mirror"
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_all/mirror_ears": {
            "instance": "../../mirror_ears/mirror"
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_all/mirror_lids": {
            "instance": "../../mirror_lids/mirror"
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_all/mirror_lips": {
            "instance": "../../mirror_lips/mirror"
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_all/mirror_nose": {
            "instance": "../../mirror_nose/mirror"
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_brows": {
            "instance": "../mirror_lids", 
            "child_order": [
                "mirror"
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_brows/mirror": {
            "attrs": {
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"brow*bend*_l_ort\", 'brow*corrugator*_l_ort'])"
                }
            }
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_cheeks": {
            "instance": "../mirror_lids", 
            "child_order": [
                "mirror"
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_cheeks/mirror": {
            "attrs": {
                "node_list": {
                    "value": "mc.ls([\"cheek*_l_ort\"])"
                }
            }
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_ears": {
            "instance": "../mirror_lids", 
            "child_order": [
                "mirror"
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_ears/mirror": {
            "attrs": {
                "node_list": {
                    "value": "mc.ls([\"ear*_l_ort\"])"
                }
            }
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_lids": {
            "instance": "/menuItem", 
            "child_order": [
                "mirror"
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_lids/mirror": {
            "instance": "/mirror_orients", 
            "attrs": {
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"lid*_l_ort\"])"
                }, 
                "rotate_vector": {
                    "type": "tuple", 
                    "value": "(1, 1, 1)"
                }, 
                "scale_vector": {
                    "type": "tuple", 
                    "value": "(1, 1, 1)"
                }
            }
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_lips": {
            "instance": "../mirror_lids", 
            "child_order": [
                "mirror"
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_lips/mirror": {
            "attrs": {
                "node_list": {
                    "type": "raw", 
                    "value": "mc.ls([\"lip*_l_ort\"])"
                }, 
                "scale_vector": {
                    "type": "tuple", 
                    "value": "(1, 1, 1)"
                }
            }
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_nose": {
            "instance": "../mirror_lids", 
            "child_order": [
                "mirror"
            ]
        }, 
        "/rig_workflow/workflow/controls/orients/mirror_face/mirror_nose/mirror": {
            "attrs": {
                "node_list": {
                    "value": "mc.ls([\"sneer*_l_ort\"])"
                }
            }
        }, 
        "/rig_workflow/workflow/curves": {}, 
        "/rig_workflow/workflow/curves/mirror_curves/mirror_face_curves": {
            "instance": "/menuItem", 
            "child_order": [
                "mirror"
            ], 
            "attrs": {
                "text": {
                    "value": "wire face curves"
                }
            }
        }, 
        "/rig_workflow/workflow/curves/mirror_curves/mirror_face_curves/mirror": {
            "instance": "/mirror_face_wires"
        }, 
        "/rig_workflow/workflow/curves/mirror_curves/mirror_selected_curves/mirror/mirror_lip": {
            "attrs": {
                "lip_curve_list": {
                    "type": "raw", 
                    "value": "mc.listRelatives(mc.ls(\"lip*\", type=\"nurbsCurve\", ni=True), p=True) or []"
                }, 
                "lip_curve_map": {
                    "type": "raw", 
                    "value": "${/rig_workflow/workflow/curves/mirror_curves/mirror_face_curves/mirror.lip_curve_map}"
                }
            }, 
            "code": [
                "mc.undoInfo(openChunk=1)", 
                "try:", 
                "    for curve in ${node_list}:", 
                "        if curve in ${lip_curve_list}:", 
                "            for left_index, right_index in zip(${lip_curve_map}[\"left\"], ${lip_curve_map}[\"right\"]):", 
                "                left_position = mc.xform(\"%s.cv[%s]\" % (curve, left_index), q=True, ws=True, t=True)", 
                "                mc.xform(\"%s.cv[%s]\" % (curve, right_index), ws=True, t=(left_position[0] *-1, left_position[1],left_position[2]))", 
                "except:", 
                "    traceback.print_exc()", 
                "mc.undoInfo(closeChunk=1)"
            ]
        }, 
        "/rig_workflow/workflow/freeze_wires/freeze/freeze_wire_expression": {
            "enabled": false
        }
    }
}